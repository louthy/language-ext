using LanguageExt.Traits;
using static LanguageExt.Prelude;

namespace LanguageExt.Megaparsec;

/// <summary>
/// `ParseError` represents a parse error parametrised over the
/// stream type `S` and the custom data `E`.
/// 
/// `Semigroup` and `Monoid` instances of the data type allow us to merge
/// parse errors from different branches of parsing. When merging two
/// 'ParseError's, the longest match is preferred; if positions are the same,
/// custom data sets and collections of message items are combined. Note that
/// fancy errors take precedence over trivial errors in merging.
/// </summary>
/// <typeparam name="T">Token type</typeparam> 
/// <typeparam name="E">Error type</typeparam> 
public abstract record ParseError<T, E>(int Offset)
{
    /// <summary>
    /// Trivial errors, generated by the Megaparsec's machinery. The data
    /// constructor includes the offset of error, unexpected token (if any),
    /// and expected tokens.
    /// </summary>
    public record Trivial(int Offset, Option<ErrorItem<T>> Unexpected, Set<ErrorItem<T>> Expected)
        : ParseError<T, E>(Offset)
    {
        public override Func<State<S, T, E>, K<M, B>> WithHints<S, M, B>(
            Hints<T> hs, 
            Func<ParseError<T, E>, State<S, T, E>, K<M, B>> f) => 
            curry(f)(ParseError.Trivial<T, E>(Offset, Unexpected, Expected + hs.Errors));
    }

    /// <summary>
    /// Fancy, custom errors.
    /// </summary>
    public record Fancy(int Offset, Set<ErrorFancy<E>> Errors)
        : ParseError<T, E>(Offset)
    {
        public override Func<State<S, T, E>, K<M, B>> WithHints<S, M, B>(
            Hints<T> hs, 
            Func<ParseError<T, E>, State<S, T, E>, K<M, B>> f) => 
            curry(f)(this);
    }

    public abstract Func<State<S, T, E>, K<M, B>> WithHints<S, M, B>(
        Hints<T> hs, 
        Func<ParseError<T, E>, State<S, T, E>, K<M, B>> f);
}
