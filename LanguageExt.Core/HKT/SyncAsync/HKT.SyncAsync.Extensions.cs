// <auto-generated/>

using System;
using System.Text;
using System.Linq;
using System.Threading.Tasks;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using LanguageExt.TypeClasses;
using LanguageExt.ClassInstances;
using static LanguageExt.Prelude;

namespace LanguageExt
{
    /// <summary>
    /// Async monad transformer for OptionAsync, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class OptionAsyncT_SyncAsync_Extensions
    {
        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Arr&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<OptionAsync<C>> SelectMany< A, B, C>(
            this Arr<OptionAsync<A>> ma,
            Func<A, OptionAsync<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MArr<OptionAsync<A>>, Arr<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MArr<OptionAsync<B>>, Arr<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MArr<OptionAsync<C>>, Arr<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Arr&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<OptionAsync<C>> SelectMany< A, B, C>(
            this Arr<OptionAsync<A>> ma,
            Func<A, Task<OptionAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MArr<OptionAsync<A>>, Arr<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MArr<OptionAsync<B>>, Arr<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MArr<OptionAsync<C>>, Arr<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Arr&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<OptionAsync<C>> SelectMany< A, B, C>(
            this Arr<OptionAsync<A>> ma,
            Func<A, OptionAsync<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MArr<OptionAsync<A>>, Arr<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MArr<OptionAsync<B>>, Arr<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MArr<OptionAsync<C>>, Arr<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Arr&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<OptionAsync<C>> SelectMany< A, B, C>(
            this Arr<OptionAsync<A>> ma,
            Func<A, Task<OptionAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MArr<OptionAsync<A>>, Arr<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MArr<OptionAsync<B>>, Arr<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MArr<OptionAsync<C>>, Arr<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<OptionAsync<A>> Where< A>(this Arr<OptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MArr<OptionAsync<A>>, Arr<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).Bind<MArr<OptionAsync<A>>, Arr<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<OptionAsync<A>> Where< A>(this Arr<OptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MArr<OptionAsync<A>>, Arr<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).BindAsync<MArr<OptionAsync<A>>, Arr<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<OptionAsync<B>> Select< A, B>(this Arr<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MArr<OptionAsync<A>>, Arr<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Map<MArr<OptionAsync<B>>, Arr<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Arr&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;OptionAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Arr&lt;OptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this Arr<OptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MArr<OptionAsync<A>>, Arr<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Arr&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;OptionAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Arr&lt;OptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this Arr<OptionAsync<A>> ma) =>
            default(TransSyncAsync<MArr<OptionAsync<A>>, Arr<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<OptionAsync<B>> BindT< A, B>(this Arr<OptionAsync<A>> ma, Func<A, OptionAsync<B>> f) =>
            default(TransSyncAsync<MArr<OptionAsync<A>>, Arr<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Bind<MArr<OptionAsync<B>>, Arr<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Arr&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;Arr&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Arr&lt;B&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<Arr<B>> Traverse< A, B>(this Arr<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MArr<OptionAsync<A>>, Arr<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Traverse<MOptionAsync<Arr<B>>, OptionAsync<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Arr&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;Arr&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Arr&lt;B&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<Arr<B>> Traverse< A, B>(this Arr<OptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MArr<OptionAsync<A>>, Arr<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .TraverseAsync<MOptionAsync<Arr<B>>, OptionAsync<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Arr&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;Arr&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<Arr<A>> Sequence< A>(this Arr<OptionAsync<A>> ma) =>
            default(TransSyncAsync<MArr<OptionAsync<A>>, Arr<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Sequence<MOptionAsync<Arr<A>>, OptionAsync<Arr<A>>, MArr<A>, Arr<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<OptionAsync<B>> MapT< A, B>(this Arr<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MArr<OptionAsync<A>>, Arr<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Map<MArr<OptionAsync<B>>, Arr<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<OptionAsync<B>> MapT< A, B>(this Arr<OptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MArr<OptionAsync<A>>, Arr<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .MapAsync<MArr<OptionAsync<B>>, Arr<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Arr<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MArr<OptionAsync<A>>, Arr<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Arr<OptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MArr<OptionAsync<A>>, Arr<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Arr<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MArr<OptionAsync<A>>, Arr<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Arr<OptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MArr<OptionAsync<A>>, Arr<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this Arr<OptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MArr<OptionAsync<A>>, Arr<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this Arr<OptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MArr<OptionAsync<A>>, Arr<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Arr&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this Arr<OptionAsync<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MArr<OptionAsync<A>>, Arr<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<OptionAsync<A>> FilterT< A>(this Arr<OptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MArr<OptionAsync<A>>, Arr<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Bind<MArr<OptionAsync<A>>, Arr<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<OptionAsync<A>> FilterT< A>(this Arr<OptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MArr<OptionAsync<A>>, Arr<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .BindAsync<MArr<OptionAsync<A>>, Arr<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Arr<OptionAsync<A>> PlusT<NUM,  A>(this Arr<OptionAsync<A>> x, Arr<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Arr<OptionAsync<A>> SubtractT<NUM,  A>(this Arr<OptionAsync<A>> x, Arr<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Arr<OptionAsync<A>> ProductT<NUM,  A>(this Arr<OptionAsync<A>> x, Arr<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Arr<OptionAsync<A>> DivideT<NUM,  A>(this Arr<OptionAsync<A>> x, Arr<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Arr<OptionAsync<A>> AppendT<SEMI,  A>(this Arr<OptionAsync<A>> x, Arr<OptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this Arr<OptionAsync<A>> x, Arr<OptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this Arr<OptionAsync<A>> x, Arr<OptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Arr&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Arr&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Arr<OptionAsync<B>> ApplyT< A, B>(this Func<A, B> fab, Arr<OptionAsync<A>> fa) =>
            default(ApplArr< OptionAsync<A>, OptionAsync<B>>).Apply(
                default(MArr< Func<OptionAsync<A>, OptionAsync<B>>>).Return(
                    (OptionAsync<A> a) => 
                        default(ApplOptionAsync< A, B>).Apply(
                            default(MOptionAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Arr&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Arr&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Arr&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Arr<OptionAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Arr<OptionAsync<A>> fa, Arr<OptionAsync<B>> fb) =>
            default(ApplArr< OptionAsync<A>, OptionAsync<B>, OptionAsync<C>>).Apply(
                default(MArr< Func<OptionAsync<A>, Func<OptionAsync<B>, OptionAsync<C>>>>).Return(
                    (OptionAsync<A> a) =>
                        (OptionAsync<B> b) =>
                            default(ApplOptionAsync< A, B, C>).Apply(
                                default(MOptionAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`HashSet&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<OptionAsync<C>> SelectMany< A, B, C>(
            this HashSet<OptionAsync<A>> ma,
            Func<A, OptionAsync<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MHashSet<OptionAsync<A>>, HashSet<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MHashSet<OptionAsync<B>>, HashSet<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MHashSet<OptionAsync<C>>, HashSet<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`HashSet&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<OptionAsync<C>> SelectMany< A, B, C>(
            this HashSet<OptionAsync<A>> ma,
            Func<A, Task<OptionAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MHashSet<OptionAsync<A>>, HashSet<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MHashSet<OptionAsync<B>>, HashSet<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MHashSet<OptionAsync<C>>, HashSet<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`HashSet&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<OptionAsync<C>> SelectMany< A, B, C>(
            this HashSet<OptionAsync<A>> ma,
            Func<A, OptionAsync<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MHashSet<OptionAsync<A>>, HashSet<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MHashSet<OptionAsync<B>>, HashSet<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MHashSet<OptionAsync<C>>, HashSet<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`HashSet&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<OptionAsync<C>> SelectMany< A, B, C>(
            this HashSet<OptionAsync<A>> ma,
            Func<A, Task<OptionAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MHashSet<OptionAsync<A>>, HashSet<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MHashSet<OptionAsync<B>>, HashSet<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MHashSet<OptionAsync<C>>, HashSet<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<OptionAsync<A>> Where< A>(this HashSet<OptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MHashSet<OptionAsync<A>>, HashSet<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).Bind<MHashSet<OptionAsync<A>>, HashSet<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<OptionAsync<A>> Where< A>(this HashSet<OptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MHashSet<OptionAsync<A>>, HashSet<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).BindAsync<MHashSet<OptionAsync<A>>, HashSet<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<OptionAsync<B>> Select< A, B>(this HashSet<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MHashSet<OptionAsync<A>>, HashSet<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Map<MHashSet<OptionAsync<B>>, HashSet<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `HashSet&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;OptionAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `HashSet&lt;OptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this HashSet<OptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MHashSet<OptionAsync<A>>, HashSet<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `HashSet&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;OptionAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `HashSet&lt;OptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this HashSet<OptionAsync<A>> ma) =>
            default(TransSyncAsync<MHashSet<OptionAsync<A>>, HashSet<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<OptionAsync<B>> BindT< A, B>(this HashSet<OptionAsync<A>> ma, Func<A, OptionAsync<B>> f) =>
            default(TransSyncAsync<MHashSet<OptionAsync<A>>, HashSet<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Bind<MHashSet<OptionAsync<B>>, HashSet<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `HashSet&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;HashSet&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;HashSet&lt;B&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<HashSet<B>> Traverse< A, B>(this HashSet<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MHashSet<OptionAsync<A>>, HashSet<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Traverse<MOptionAsync<HashSet<B>>, OptionAsync<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `HashSet&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;HashSet&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;HashSet&lt;B&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<HashSet<B>> Traverse< A, B>(this HashSet<OptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MHashSet<OptionAsync<A>>, HashSet<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .TraverseAsync<MOptionAsync<HashSet<B>>, OptionAsync<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `HashSet&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;HashSet&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<HashSet<A>> Sequence< A>(this HashSet<OptionAsync<A>> ma) =>
            default(TransSyncAsync<MHashSet<OptionAsync<A>>, HashSet<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Sequence<MOptionAsync<HashSet<A>>, OptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<OptionAsync<B>> MapT< A, B>(this HashSet<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MHashSet<OptionAsync<A>>, HashSet<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Map<MHashSet<OptionAsync<B>>, HashSet<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<OptionAsync<B>> MapT< A, B>(this HashSet<OptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MHashSet<OptionAsync<A>>, HashSet<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .MapAsync<MHashSet<OptionAsync<B>>, HashSet<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this HashSet<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MHashSet<OptionAsync<A>>, HashSet<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this HashSet<OptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MHashSet<OptionAsync<A>>, HashSet<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this HashSet<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MHashSet<OptionAsync<A>>, HashSet<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this HashSet<OptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MHashSet<OptionAsync<A>>, HashSet<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this HashSet<OptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MHashSet<OptionAsync<A>>, HashSet<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this HashSet<OptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MHashSet<OptionAsync<A>>, HashSet<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `HashSet&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this HashSet<OptionAsync<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MHashSet<OptionAsync<A>>, HashSet<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<OptionAsync<A>> FilterT< A>(this HashSet<OptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MHashSet<OptionAsync<A>>, HashSet<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Bind<MHashSet<OptionAsync<A>>, HashSet<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<OptionAsync<A>> FilterT< A>(this HashSet<OptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MHashSet<OptionAsync<A>>, HashSet<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .BindAsync<MHashSet<OptionAsync<A>>, HashSet<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<OptionAsync<A>> PlusT<NUM,  A>(this HashSet<OptionAsync<A>> x, HashSet<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<OptionAsync<A>> SubtractT<NUM,  A>(this HashSet<OptionAsync<A>> x, HashSet<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static HashSet<OptionAsync<A>> ProductT<NUM,  A>(this HashSet<OptionAsync<A>> x, HashSet<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static HashSet<OptionAsync<A>> DivideT<NUM,  A>(this HashSet<OptionAsync<A>> x, HashSet<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static HashSet<OptionAsync<A>> AppendT<SEMI,  A>(this HashSet<OptionAsync<A>> x, HashSet<OptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this HashSet<OptionAsync<A>> x, HashSet<OptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this HashSet<OptionAsync<A>> x, HashSet<OptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `HashSet&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`HashSet&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static HashSet<OptionAsync<B>> ApplyT< A, B>(this Func<A, B> fab, HashSet<OptionAsync<A>> fa) =>
            default(ApplHashSet< OptionAsync<A>, OptionAsync<B>>).Apply(
                default(MHashSet< Func<OptionAsync<A>, OptionAsync<B>>>).Return(
                    (OptionAsync<A> a) => 
                        default(ApplOptionAsync< A, B>).Apply(
                            default(MOptionAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `HashSet&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `HashSet&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`HashSet&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static HashSet<OptionAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, HashSet<OptionAsync<A>> fa, HashSet<OptionAsync<B>> fb) =>
            default(ApplHashSet< OptionAsync<A>, OptionAsync<B>, OptionAsync<C>>).Apply(
                default(MHashSet< Func<OptionAsync<A>, Func<OptionAsync<B>, OptionAsync<C>>>>).Return(
                    (OptionAsync<A> a) =>
                        (OptionAsync<B> b) =>
                            default(ApplOptionAsync< A, B, C>).Apply(
                                default(MOptionAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Lst&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<OptionAsync<C>> SelectMany< A, B, C>(
            this Lst<OptionAsync<A>> ma,
            Func<A, OptionAsync<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MLst<OptionAsync<A>>, Lst<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MLst<OptionAsync<B>>, Lst<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MLst<OptionAsync<C>>, Lst<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Lst&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<OptionAsync<C>> SelectMany< A, B, C>(
            this Lst<OptionAsync<A>> ma,
            Func<A, Task<OptionAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MLst<OptionAsync<A>>, Lst<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MLst<OptionAsync<B>>, Lst<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MLst<OptionAsync<C>>, Lst<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Lst&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<OptionAsync<C>> SelectMany< A, B, C>(
            this Lst<OptionAsync<A>> ma,
            Func<A, OptionAsync<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MLst<OptionAsync<A>>, Lst<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MLst<OptionAsync<B>>, Lst<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MLst<OptionAsync<C>>, Lst<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Lst&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<OptionAsync<C>> SelectMany< A, B, C>(
            this Lst<OptionAsync<A>> ma,
            Func<A, Task<OptionAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MLst<OptionAsync<A>>, Lst<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MLst<OptionAsync<B>>, Lst<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MLst<OptionAsync<C>>, Lst<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<OptionAsync<A>> Where< A>(this Lst<OptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MLst<OptionAsync<A>>, Lst<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).Bind<MLst<OptionAsync<A>>, Lst<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<OptionAsync<A>> Where< A>(this Lst<OptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MLst<OptionAsync<A>>, Lst<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).BindAsync<MLst<OptionAsync<A>>, Lst<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<OptionAsync<B>> Select< A, B>(this Lst<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MLst<OptionAsync<A>>, Lst<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Map<MLst<OptionAsync<B>>, Lst<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Lst&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;OptionAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Lst&lt;OptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this Lst<OptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MLst<OptionAsync<A>>, Lst<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Lst&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;OptionAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Lst&lt;OptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this Lst<OptionAsync<A>> ma) =>
            default(TransSyncAsync<MLst<OptionAsync<A>>, Lst<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<OptionAsync<B>> BindT< A, B>(this Lst<OptionAsync<A>> ma, Func<A, OptionAsync<B>> f) =>
            default(TransSyncAsync<MLst<OptionAsync<A>>, Lst<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Bind<MLst<OptionAsync<B>>, Lst<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Lst&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;Lst&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Lst&lt;B&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<Lst<B>> Traverse< A, B>(this Lst<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MLst<OptionAsync<A>>, Lst<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Traverse<MOptionAsync<Lst<B>>, OptionAsync<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Lst&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;Lst&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Lst&lt;B&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<Lst<B>> Traverse< A, B>(this Lst<OptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MLst<OptionAsync<A>>, Lst<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .TraverseAsync<MOptionAsync<Lst<B>>, OptionAsync<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Lst&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;Lst&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<Lst<A>> Sequence< A>(this Lst<OptionAsync<A>> ma) =>
            default(TransSyncAsync<MLst<OptionAsync<A>>, Lst<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Sequence<MOptionAsync<Lst<A>>, OptionAsync<Lst<A>>, MLst<A>, Lst<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<OptionAsync<B>> MapT< A, B>(this Lst<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MLst<OptionAsync<A>>, Lst<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Map<MLst<OptionAsync<B>>, Lst<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<OptionAsync<B>> MapT< A, B>(this Lst<OptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MLst<OptionAsync<A>>, Lst<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .MapAsync<MLst<OptionAsync<B>>, Lst<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Lst<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MLst<OptionAsync<A>>, Lst<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Lst<OptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MLst<OptionAsync<A>>, Lst<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Lst<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MLst<OptionAsync<A>>, Lst<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Lst<OptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MLst<OptionAsync<A>>, Lst<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this Lst<OptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MLst<OptionAsync<A>>, Lst<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this Lst<OptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MLst<OptionAsync<A>>, Lst<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Lst&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this Lst<OptionAsync<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MLst<OptionAsync<A>>, Lst<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<OptionAsync<A>> FilterT< A>(this Lst<OptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MLst<OptionAsync<A>>, Lst<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Bind<MLst<OptionAsync<A>>, Lst<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<OptionAsync<A>> FilterT< A>(this Lst<OptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MLst<OptionAsync<A>>, Lst<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .BindAsync<MLst<OptionAsync<A>>, Lst<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Lst<OptionAsync<A>> PlusT<NUM,  A>(this Lst<OptionAsync<A>> x, Lst<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Lst<OptionAsync<A>> SubtractT<NUM,  A>(this Lst<OptionAsync<A>> x, Lst<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Lst<OptionAsync<A>> ProductT<NUM,  A>(this Lst<OptionAsync<A>> x, Lst<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Lst<OptionAsync<A>> DivideT<NUM,  A>(this Lst<OptionAsync<A>> x, Lst<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Lst<OptionAsync<A>> AppendT<SEMI,  A>(this Lst<OptionAsync<A>> x, Lst<OptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this Lst<OptionAsync<A>> x, Lst<OptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this Lst<OptionAsync<A>> x, Lst<OptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Lst&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Lst&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Lst<OptionAsync<B>> ApplyT< A, B>(this Func<A, B> fab, Lst<OptionAsync<A>> fa) =>
            default(ApplLst< OptionAsync<A>, OptionAsync<B>>).Apply(
                default(MLst< Func<OptionAsync<A>, OptionAsync<B>>>).Return(
                    (OptionAsync<A> a) => 
                        default(ApplOptionAsync< A, B>).Apply(
                            default(MOptionAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Lst&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Lst&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Lst&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Lst<OptionAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Lst<OptionAsync<A>> fa, Lst<OptionAsync<B>> fb) =>
            default(ApplLst< OptionAsync<A>, OptionAsync<B>, OptionAsync<C>>).Apply(
                default(MLst< Func<OptionAsync<A>, Func<OptionAsync<B>, OptionAsync<C>>>>).Return(
                    (OptionAsync<A> a) =>
                        (OptionAsync<B> b) =>
                            default(ApplOptionAsync< A, B, C>).Apply(
                                default(MOptionAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Option&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Option<OptionAsync<C>> SelectMany< A, B, C>(
            this Option<OptionAsync<A>> ma,
            Func<A, OptionAsync<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MOption<OptionAsync<A>>, Option<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MOption<OptionAsync<B>>, Option<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MOption<OptionAsync<C>>, Option<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Option&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Option<OptionAsync<C>> SelectMany< A, B, C>(
            this Option<OptionAsync<A>> ma,
            Func<A, Task<OptionAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MOption<OptionAsync<A>>, Option<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MOption<OptionAsync<B>>, Option<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MOption<OptionAsync<C>>, Option<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Option&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Option<OptionAsync<C>> SelectMany< A, B, C>(
            this Option<OptionAsync<A>> ma,
            Func<A, OptionAsync<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MOption<OptionAsync<A>>, Option<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MOption<OptionAsync<B>>, Option<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MOption<OptionAsync<C>>, Option<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Option&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Option<OptionAsync<C>> SelectMany< A, B, C>(
            this Option<OptionAsync<A>> ma,
            Func<A, Task<OptionAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MOption<OptionAsync<A>>, Option<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MOption<OptionAsync<B>>, Option<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MOption<OptionAsync<C>>, Option<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<OptionAsync<A>> Where< A>(this Option<OptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MOption<OptionAsync<A>>, Option<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).Bind<MOption<OptionAsync<A>>, Option<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<OptionAsync<A>> Where< A>(this Option<OptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MOption<OptionAsync<A>>, Option<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).BindAsync<MOption<OptionAsync<A>>, Option<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<OptionAsync<B>> Select< A, B>(this Option<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MOption<OptionAsync<A>>, Option<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Map<MOption<OptionAsync<B>>, Option<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Option&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;OptionAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Option&lt;OptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this Option<OptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MOption<OptionAsync<A>>, Option<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Option&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;OptionAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Option&lt;OptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this Option<OptionAsync<A>> ma) =>
            default(TransSyncAsync<MOption<OptionAsync<A>>, Option<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<OptionAsync<B>> BindT< A, B>(this Option<OptionAsync<A>> ma, Func<A, OptionAsync<B>> f) =>
            default(TransSyncAsync<MOption<OptionAsync<A>>, Option<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Bind<MOption<OptionAsync<B>>, Option<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Option&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;Option&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Option&lt;B&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<Option<B>> Traverse< A, B>(this Option<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MOption<OptionAsync<A>>, Option<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Traverse<MOptionAsync<Option<B>>, OptionAsync<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Option&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;Option&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Option&lt;B&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<Option<B>> Traverse< A, B>(this Option<OptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MOption<OptionAsync<A>>, Option<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .TraverseAsync<MOptionAsync<Option<B>>, OptionAsync<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Option&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;Option&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<Option<A>> Sequence< A>(this Option<OptionAsync<A>> ma) =>
            default(TransSyncAsync<MOption<OptionAsync<A>>, Option<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Sequence<MOptionAsync<Option<A>>, OptionAsync<Option<A>>, MOption<A>, Option<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<OptionAsync<B>> MapT< A, B>(this Option<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MOption<OptionAsync<A>>, Option<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Map<MOption<OptionAsync<B>>, Option<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<OptionAsync<B>> MapT< A, B>(this Option<OptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MOption<OptionAsync<A>>, Option<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .MapAsync<MOption<OptionAsync<B>>, Option<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Option<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MOption<OptionAsync<A>>, Option<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Option<OptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MOption<OptionAsync<A>>, Option<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Option<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MOption<OptionAsync<A>>, Option<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Option<OptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MOption<OptionAsync<A>>, Option<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this Option<OptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MOption<OptionAsync<A>>, Option<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this Option<OptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MOption<OptionAsync<A>>, Option<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Option&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this Option<OptionAsync<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MOption<OptionAsync<A>>, Option<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<OptionAsync<A>> FilterT< A>(this Option<OptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MOption<OptionAsync<A>>, Option<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Bind<MOption<OptionAsync<A>>, Option<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<OptionAsync<A>> FilterT< A>(this Option<OptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MOption<OptionAsync<A>>, Option<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .BindAsync<MOption<OptionAsync<A>>, Option<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Option<OptionAsync<A>> PlusT<NUM,  A>(this Option<OptionAsync<A>> x, Option<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Option<OptionAsync<A>> SubtractT<NUM,  A>(this Option<OptionAsync<A>> x, Option<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Option<OptionAsync<A>> ProductT<NUM,  A>(this Option<OptionAsync<A>> x, Option<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Option<OptionAsync<A>> DivideT<NUM,  A>(this Option<OptionAsync<A>> x, Option<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Option<OptionAsync<A>> AppendT<SEMI,  A>(this Option<OptionAsync<A>> x, Option<OptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this Option<OptionAsync<A>> x, Option<OptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this Option<OptionAsync<A>> x, Option<OptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Option&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Option&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Option<OptionAsync<B>> ApplyT< A, B>(this Func<A, B> fab, Option<OptionAsync<A>> fa) =>
            default(ApplOption< OptionAsync<A>, OptionAsync<B>>).Apply(
                default(MOption< Func<OptionAsync<A>, OptionAsync<B>>>).Return(
                    (OptionAsync<A> a) => 
                        default(ApplOptionAsync< A, B>).Apply(
                            default(MOptionAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Option&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Option&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Option&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Option<OptionAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Option<OptionAsync<A>> fa, Option<OptionAsync<B>> fb) =>
            default(ApplOption< OptionAsync<A>, OptionAsync<B>, OptionAsync<C>>).Apply(
                default(MOption< Func<OptionAsync<A>, Func<OptionAsync<B>, OptionAsync<C>>>>).Return(
                    (OptionAsync<A> a) =>
                        (OptionAsync<B> b) =>
                            default(ApplOptionAsync< A, B, C>).Apply(
                                default(MOptionAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionUnsafe&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<OptionAsync<C>> SelectMany< A, B, C>(
            this OptionUnsafe<OptionAsync<A>> ma,
            Func<A, OptionAsync<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MOptionUnsafe<OptionAsync<A>>, OptionUnsafe<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MOptionUnsafe<OptionAsync<B>>, OptionUnsafe<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MOptionUnsafe<OptionAsync<C>>, OptionUnsafe<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionUnsafe&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<OptionAsync<C>> SelectMany< A, B, C>(
            this OptionUnsafe<OptionAsync<A>> ma,
            Func<A, Task<OptionAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MOptionUnsafe<OptionAsync<A>>, OptionUnsafe<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MOptionUnsafe<OptionAsync<B>>, OptionUnsafe<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MOptionUnsafe<OptionAsync<C>>, OptionUnsafe<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionUnsafe&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<OptionAsync<C>> SelectMany< A, B, C>(
            this OptionUnsafe<OptionAsync<A>> ma,
            Func<A, OptionAsync<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MOptionUnsafe<OptionAsync<A>>, OptionUnsafe<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MOptionUnsafe<OptionAsync<B>>, OptionUnsafe<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MOptionUnsafe<OptionAsync<C>>, OptionUnsafe<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionUnsafe&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<OptionAsync<C>> SelectMany< A, B, C>(
            this OptionUnsafe<OptionAsync<A>> ma,
            Func<A, Task<OptionAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MOptionUnsafe<OptionAsync<A>>, OptionUnsafe<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MOptionUnsafe<OptionAsync<B>>, OptionUnsafe<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MOptionUnsafe<OptionAsync<C>>, OptionUnsafe<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<OptionAsync<A>> Where< A>(this OptionUnsafe<OptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MOptionUnsafe<OptionAsync<A>>, OptionUnsafe<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).Bind<MOptionUnsafe<OptionAsync<A>>, OptionUnsafe<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<OptionAsync<A>> Where< A>(this OptionUnsafe<OptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MOptionUnsafe<OptionAsync<A>>, OptionUnsafe<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).BindAsync<MOptionUnsafe<OptionAsync<A>>, OptionUnsafe<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<OptionAsync<B>> Select< A, B>(this OptionUnsafe<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MOptionUnsafe<OptionAsync<A>>, OptionUnsafe<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Map<MOptionUnsafe<OptionAsync<B>>, OptionUnsafe<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this OptionUnsafe<OptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MOptionUnsafe<OptionAsync<A>>, OptionUnsafe<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this OptionUnsafe<OptionAsync<A>> ma) =>
            default(TransSyncAsync<MOptionUnsafe<OptionAsync<A>>, OptionUnsafe<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<OptionAsync<B>> BindT< A, B>(this OptionUnsafe<OptionAsync<A>> ma, Func<A, OptionAsync<B>> f) =>
            default(TransSyncAsync<MOptionUnsafe<OptionAsync<A>>, OptionUnsafe<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Bind<MOptionUnsafe<OptionAsync<B>>, OptionUnsafe<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;OptionUnsafe&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;OptionUnsafe&lt;B&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<OptionUnsafe<B>> Traverse< A, B>(this OptionUnsafe<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MOptionUnsafe<OptionAsync<A>>, OptionUnsafe<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Traverse<MOptionAsync<OptionUnsafe<B>>, OptionAsync<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;OptionUnsafe&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;OptionUnsafe&lt;B&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<OptionUnsafe<B>> Traverse< A, B>(this OptionUnsafe<OptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MOptionUnsafe<OptionAsync<A>>, OptionUnsafe<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .TraverseAsync<MOptionAsync<OptionUnsafe<B>>, OptionAsync<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<OptionUnsafe<A>> Sequence< A>(this OptionUnsafe<OptionAsync<A>> ma) =>
            default(TransSyncAsync<MOptionUnsafe<OptionAsync<A>>, OptionUnsafe<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Sequence<MOptionAsync<OptionUnsafe<A>>, OptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<OptionAsync<B>> MapT< A, B>(this OptionUnsafe<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MOptionUnsafe<OptionAsync<A>>, OptionUnsafe<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Map<MOptionUnsafe<OptionAsync<B>>, OptionUnsafe<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<OptionAsync<B>> MapT< A, B>(this OptionUnsafe<OptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MOptionUnsafe<OptionAsync<A>>, OptionUnsafe<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .MapAsync<MOptionUnsafe<OptionAsync<B>>, OptionUnsafe<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this OptionUnsafe<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MOptionUnsafe<OptionAsync<A>>, OptionUnsafe<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this OptionUnsafe<OptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MOptionUnsafe<OptionAsync<A>>, OptionUnsafe<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this OptionUnsafe<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MOptionUnsafe<OptionAsync<A>>, OptionUnsafe<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this OptionUnsafe<OptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MOptionUnsafe<OptionAsync<A>>, OptionUnsafe<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this OptionUnsafe<OptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MOptionUnsafe<OptionAsync<A>>, OptionUnsafe<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this OptionUnsafe<OptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MOptionUnsafe<OptionAsync<A>>, OptionUnsafe<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this OptionUnsafe<OptionAsync<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MOptionUnsafe<OptionAsync<A>>, OptionUnsafe<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<OptionAsync<A>> FilterT< A>(this OptionUnsafe<OptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MOptionUnsafe<OptionAsync<A>>, OptionUnsafe<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Bind<MOptionUnsafe<OptionAsync<A>>, OptionUnsafe<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<OptionAsync<A>> FilterT< A>(this OptionUnsafe<OptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MOptionUnsafe<OptionAsync<A>>, OptionUnsafe<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .BindAsync<MOptionUnsafe<OptionAsync<A>>, OptionUnsafe<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<OptionAsync<A>> PlusT<NUM,  A>(this OptionUnsafe<OptionAsync<A>> x, OptionUnsafe<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<OptionAsync<A>> SubtractT<NUM,  A>(this OptionUnsafe<OptionAsync<A>> x, OptionUnsafe<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionUnsafe<OptionAsync<A>> ProductT<NUM,  A>(this OptionUnsafe<OptionAsync<A>> x, OptionUnsafe<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionUnsafe<OptionAsync<A>> DivideT<NUM,  A>(this OptionUnsafe<OptionAsync<A>> x, OptionUnsafe<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionUnsafe<OptionAsync<A>> AppendT<SEMI,  A>(this OptionUnsafe<OptionAsync<A>> x, OptionUnsafe<OptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this OptionUnsafe<OptionAsync<A>> x, OptionUnsafe<OptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this OptionUnsafe<OptionAsync<A>> x, OptionUnsafe<OptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`OptionUnsafe&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionUnsafe<OptionAsync<B>> ApplyT< A, B>(this Func<A, B> fab, OptionUnsafe<OptionAsync<A>> fa) =>
            default(ApplOptionUnsafe< OptionAsync<A>, OptionAsync<B>>).Apply(
                default(MOptionUnsafe< Func<OptionAsync<A>, OptionAsync<B>>>).Return(
                    (OptionAsync<A> a) => 
                        default(ApplOptionAsync< A, B>).Apply(
                            default(MOptionAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `OptionUnsafe&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`OptionUnsafe&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionUnsafe<OptionAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, OptionUnsafe<OptionAsync<A>> fa, OptionUnsafe<OptionAsync<B>> fb) =>
            default(ApplOptionUnsafe< OptionAsync<A>, OptionAsync<B>, OptionAsync<C>>).Apply(
                default(MOptionUnsafe< Func<OptionAsync<A>, Func<OptionAsync<B>, OptionAsync<C>>>>).Return(
                    (OptionAsync<A> a) =>
                        (OptionAsync<B> b) =>
                            default(ApplOptionAsync< A, B, C>).Apply(
                                default(MOptionAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Either&lt;L, OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, OptionAsync<C>> SelectMany<L, A, B, C>(
            this Either<L, OptionAsync<A>> ma,
            Func<A, OptionAsync<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MEither<L, OptionAsync<A>>, Either<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MEither<L, OptionAsync<B>>, Either<L, OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MEither<L, OptionAsync<C>>, Either<L, OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Either&lt;L, OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, OptionAsync<C>> SelectMany<L, A, B, C>(
            this Either<L, OptionAsync<A>> ma,
            Func<A, Task<OptionAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MEither<L, OptionAsync<A>>, Either<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MEither<L, OptionAsync<B>>, Either<L, OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MEither<L, OptionAsync<C>>, Either<L, OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Either&lt;L, OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, OptionAsync<C>> SelectMany<L, A, B, C>(
            this Either<L, OptionAsync<A>> ma,
            Func<A, OptionAsync<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MEither<L, OptionAsync<A>>, Either<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MEither<L, OptionAsync<B>>, Either<L, OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MEither<L, OptionAsync<C>>, Either<L, OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Either&lt;L, OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, OptionAsync<C>> SelectMany<L, A, B, C>(
            this Either<L, OptionAsync<A>> ma,
            Func<A, Task<OptionAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MEither<L, OptionAsync<A>>, Either<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MEither<L, OptionAsync<B>>, Either<L, OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MEither<L, OptionAsync<C>>, Either<L, OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, OptionAsync<A>> Where<L, A>(this Either<L, OptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MEither<L, OptionAsync<A>>, Either<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).Bind<MEither<L, OptionAsync<A>>, Either<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, OptionAsync<A>> Where<L, A>(this Either<L, OptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MEither<L, OptionAsync<A>>, Either<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).BindAsync<MEither<L, OptionAsync<A>>, Either<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, OptionAsync<B>> Select<L, A, B>(this Either<L, OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MEither<L, OptionAsync<A>>, Either<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Map<MEither<L, OptionAsync<B>>, Either<L, OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Either&lt;L, OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Either&lt;L, OptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA, L, A>(this Either<L, OptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MEither<L, OptionAsync<A>>, Either<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Either&lt;L, OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Either&lt;L, OptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT<L, A>(this Either<L, OptionAsync<A>> ma) =>
            default(TransSyncAsync<MEither<L, OptionAsync<A>>, Either<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either&lt;L, OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, OptionAsync<B>> BindT<L, A, B>(this Either<L, OptionAsync<A>> ma, Func<A, OptionAsync<B>> f) =>
            default(TransSyncAsync<MEither<L, OptionAsync<A>>, Either<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Bind<MEither<L, OptionAsync<B>>, Either<L, OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Either&lt;L, OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;Either&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Either&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<Either<L, B>> Traverse<L, A, B>(this Either<L, OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MEither<L, OptionAsync<A>>, Either<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Traverse<MOptionAsync<Either<L, B>>, OptionAsync<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Either&lt;L, OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;Either&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Either&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<Either<L, B>> Traverse<L, A, B>(this Either<L, OptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MEither<L, OptionAsync<A>>, Either<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .TraverseAsync<MOptionAsync<Either<L, B>>, OptionAsync<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Either&lt;L, OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;Either&lt;L, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<Either<L, A>> Sequence<L, A>(this Either<L, OptionAsync<A>> ma) =>
            default(TransSyncAsync<MEither<L, OptionAsync<A>>, Either<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Sequence<MOptionAsync<Either<L, A>>, OptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, OptionAsync<B>> MapT<L, A, B>(this Either<L, OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MEither<L, OptionAsync<A>>, Either<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Map<MEither<L, OptionAsync<B>>, Either<L, OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, OptionAsync<B>> MapT<L, A, B>(this Either<L, OptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MEither<L, OptionAsync<A>>, Either<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .MapAsync<MEither<L, OptionAsync<B>>, Either<L, OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, L, A>(this Either<L, OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MEither<L, OptionAsync<A>>, Either<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, L, A>(this Either<L, OptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MEither<L, OptionAsync<A>>, Either<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, L, A>(this Either<L, OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MEither<L, OptionAsync<A>>, Either<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, L, A>(this Either<L, OptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MEither<L, OptionAsync<A>>, Either<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT<L, A>(this Either<L, OptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MEither<L, OptionAsync<A>>, Either<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT<L, A>(this Either<L, OptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MEither<L, OptionAsync<A>>, Either<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Either&lt;L, OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT<L, A>(this Either<L, OptionAsync<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MEither<L, OptionAsync<A>>, Either<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, OptionAsync<A>> FilterT<L, A>(this Either<L, OptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MEither<L, OptionAsync<A>>, Either<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Bind<MEither<L, OptionAsync<A>>, Either<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, OptionAsync<A>> FilterT<L, A>(this Either<L, OptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MEither<L, OptionAsync<A>>, Either<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .BindAsync<MEither<L, OptionAsync<A>>, Either<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, OptionAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, OptionAsync<A>> PlusT<NUM, L, A>(this Either<L, OptionAsync<A>> x, Either<L, OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, OptionAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, OptionAsync<A>> SubtractT<NUM, L, A>(this Either<L, OptionAsync<A>> x, Either<L, OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, OptionAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Either<L, OptionAsync<A>> ProductT<NUM, L, A>(this Either<L, OptionAsync<A>> x, Either<L, OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, OptionAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Either<L, OptionAsync<A>> DivideT<NUM, L, A>(this Either<L, OptionAsync<A>> x, Either<L, OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, OptionAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Either<L, OptionAsync<A>> AppendT<SEMI, L, A>(this Either<L, OptionAsync<A>> x, Either<L, OptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD, L, A>(this Either<L, OptionAsync<A>> x, Either<L, OptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, OptionAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ, L, A>(this Either<L, OptionAsync<A>> x, Either<L, OptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Either&lt;L, OptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Either&lt;L, OptionAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Either<L, OptionAsync<B>> ApplyT<L, A, B>(this Func<A, B> fab, Either<L, OptionAsync<A>> fa) =>
            default(ApplEither<L, OptionAsync<A>, OptionAsync<B>>).Apply(
                default(MEither<L, Func<OptionAsync<A>, OptionAsync<B>>>).Return(
                    (OptionAsync<A> a) => 
                        default(ApplOptionAsync< A, B>).Apply(
                            default(MOptionAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Either&lt;L, OptionAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Either&lt;L, OptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Either&lt;L, OptionAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Either<L, OptionAsync<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Either<L, OptionAsync<A>> fa, Either<L, OptionAsync<B>> fb) =>
            default(ApplEither<L, OptionAsync<A>, OptionAsync<B>, OptionAsync<C>>).Apply(
                default(MEither<L, Func<OptionAsync<A>, Func<OptionAsync<B>, OptionAsync<C>>>>).Return(
                    (OptionAsync<A> a) =>
                        (OptionAsync<B> b) =>
                            default(ApplOptionAsync< A, B, C>).Apply(
                                default(MOptionAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`EitherUnsafe&lt;L, OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, OptionAsync<C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, OptionAsync<A>> ma,
            Func<A, OptionAsync<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MEitherUnsafe<L, OptionAsync<A>>, EitherUnsafe<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MEitherUnsafe<L, OptionAsync<B>>, EitherUnsafe<L, OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MEitherUnsafe<L, OptionAsync<C>>, EitherUnsafe<L, OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`EitherUnsafe&lt;L, OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, OptionAsync<C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, OptionAsync<A>> ma,
            Func<A, Task<OptionAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MEitherUnsafe<L, OptionAsync<A>>, EitherUnsafe<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MEitherUnsafe<L, OptionAsync<B>>, EitherUnsafe<L, OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MEitherUnsafe<L, OptionAsync<C>>, EitherUnsafe<L, OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`EitherUnsafe&lt;L, OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, OptionAsync<C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, OptionAsync<A>> ma,
            Func<A, OptionAsync<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MEitherUnsafe<L, OptionAsync<A>>, EitherUnsafe<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MEitherUnsafe<L, OptionAsync<B>>, EitherUnsafe<L, OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MEitherUnsafe<L, OptionAsync<C>>, EitherUnsafe<L, OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`EitherUnsafe&lt;L, OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, OptionAsync<C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, OptionAsync<A>> ma,
            Func<A, Task<OptionAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MEitherUnsafe<L, OptionAsync<A>>, EitherUnsafe<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MEitherUnsafe<L, OptionAsync<B>>, EitherUnsafe<L, OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MEitherUnsafe<L, OptionAsync<C>>, EitherUnsafe<L, OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, OptionAsync<A>> Where<L, A>(this EitherUnsafe<L, OptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MEitherUnsafe<L, OptionAsync<A>>, EitherUnsafe<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).Bind<MEitherUnsafe<L, OptionAsync<A>>, EitherUnsafe<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, OptionAsync<A>> Where<L, A>(this EitherUnsafe<L, OptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MEitherUnsafe<L, OptionAsync<A>>, EitherUnsafe<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).BindAsync<MEitherUnsafe<L, OptionAsync<A>>, EitherUnsafe<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, OptionAsync<B>> Select<L, A, B>(this EitherUnsafe<L, OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, OptionAsync<A>>, EitherUnsafe<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Map<MEitherUnsafe<L, OptionAsync<B>>, EitherUnsafe<L, OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA, L, A>(this EitherUnsafe<L, OptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MEitherUnsafe<L, OptionAsync<A>>, EitherUnsafe<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT<L, A>(this EitherUnsafe<L, OptionAsync<A>> ma) =>
            default(TransSyncAsync<MEitherUnsafe<L, OptionAsync<A>>, EitherUnsafe<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, OptionAsync<B>> BindT<L, A, B>(this EitherUnsafe<L, OptionAsync<A>> ma, Func<A, OptionAsync<B>> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, OptionAsync<A>>, EitherUnsafe<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Bind<MEitherUnsafe<L, OptionAsync<B>>, EitherUnsafe<L, OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;EitherUnsafe&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;EitherUnsafe&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<EitherUnsafe<L, B>> Traverse<L, A, B>(this EitherUnsafe<L, OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, OptionAsync<A>>, EitherUnsafe<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Traverse<MOptionAsync<EitherUnsafe<L, B>>, OptionAsync<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;EitherUnsafe&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;EitherUnsafe&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<EitherUnsafe<L, B>> Traverse<L, A, B>(this EitherUnsafe<L, OptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, OptionAsync<A>>, EitherUnsafe<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .TraverseAsync<MOptionAsync<EitherUnsafe<L, B>>, OptionAsync<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<EitherUnsafe<L, A>> Sequence<L, A>(this EitherUnsafe<L, OptionAsync<A>> ma) =>
            default(TransSyncAsync<MEitherUnsafe<L, OptionAsync<A>>, EitherUnsafe<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Sequence<MOptionAsync<EitherUnsafe<L, A>>, OptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, OptionAsync<B>> MapT<L, A, B>(this EitherUnsafe<L, OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, OptionAsync<A>>, EitherUnsafe<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Map<MEitherUnsafe<L, OptionAsync<B>>, EitherUnsafe<L, OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, OptionAsync<B>> MapT<L, A, B>(this EitherUnsafe<L, OptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, OptionAsync<A>>, EitherUnsafe<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .MapAsync<MEitherUnsafe<L, OptionAsync<B>>, EitherUnsafe<L, OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, L, A>(this EitherUnsafe<L, OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, OptionAsync<A>>, EitherUnsafe<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, L, A>(this EitherUnsafe<L, OptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, OptionAsync<A>>, EitherUnsafe<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, L, A>(this EitherUnsafe<L, OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, OptionAsync<A>>, EitherUnsafe<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, L, A>(this EitherUnsafe<L, OptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, OptionAsync<A>>, EitherUnsafe<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT<L, A>(this EitherUnsafe<L, OptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, OptionAsync<A>>, EitherUnsafe<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT<L, A>(this EitherUnsafe<L, OptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, OptionAsync<A>>, EitherUnsafe<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT<L, A>(this EitherUnsafe<L, OptionAsync<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, OptionAsync<A>>, EitherUnsafe<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, OptionAsync<A>> FilterT<L, A>(this EitherUnsafe<L, OptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MEitherUnsafe<L, OptionAsync<A>>, EitherUnsafe<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Bind<MEitherUnsafe<L, OptionAsync<A>>, EitherUnsafe<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, OptionAsync<A>> FilterT<L, A>(this EitherUnsafe<L, OptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MEitherUnsafe<L, OptionAsync<A>>, EitherUnsafe<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .BindAsync<MEitherUnsafe<L, OptionAsync<A>>, EitherUnsafe<L, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, OptionAsync<A>> PlusT<NUM, L, A>(this EitherUnsafe<L, OptionAsync<A>> x, EitherUnsafe<L, OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, OptionAsync<A>> SubtractT<NUM, L, A>(this EitherUnsafe<L, OptionAsync<A>> x, EitherUnsafe<L, OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherUnsafe<L, OptionAsync<A>> ProductT<NUM, L, A>(this EitherUnsafe<L, OptionAsync<A>> x, EitherUnsafe<L, OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherUnsafe<L, OptionAsync<A>> DivideT<NUM, L, A>(this EitherUnsafe<L, OptionAsync<A>> x, EitherUnsafe<L, OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherUnsafe<L, OptionAsync<A>> AppendT<SEMI, L, A>(this EitherUnsafe<L, OptionAsync<A>> x, EitherUnsafe<L, OptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD, L, A>(this EitherUnsafe<L, OptionAsync<A>> x, EitherUnsafe<L, OptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ, L, A>(this EitherUnsafe<L, OptionAsync<A>> x, EitherUnsafe<L, OptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`EitherUnsafe&lt;L, OptionAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherUnsafe<L, OptionAsync<B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherUnsafe<L, OptionAsync<A>> fa) =>
            default(ApplEitherUnsafe<L, OptionAsync<A>, OptionAsync<B>>).Apply(
                default(MEitherUnsafe<L, Func<OptionAsync<A>, OptionAsync<B>>>).Return(
                    (OptionAsync<A> a) => 
                        default(ApplOptionAsync< A, B>).Apply(
                            default(MOptionAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `EitherUnsafe&lt;L, OptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`EitherUnsafe&lt;L, OptionAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherUnsafe<L, OptionAsync<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherUnsafe<L, OptionAsync<A>> fa, EitherUnsafe<L, OptionAsync<B>> fb) =>
            default(ApplEitherUnsafe<L, OptionAsync<A>, OptionAsync<B>, OptionAsync<C>>).Apply(
                default(MEitherUnsafe<L, Func<OptionAsync<A>, Func<OptionAsync<B>, OptionAsync<C>>>>).Return(
                    (OptionAsync<A> a) =>
                        (OptionAsync<B> b) =>
                            default(ApplOptionAsync< A, B, C>).Apply(
                                default(MOptionAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Try&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Try<OptionAsync<C>> SelectMany< A, B, C>(
            this Try<OptionAsync<A>> ma,
            Func<A, OptionAsync<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MTry<OptionAsync<A>>, Try<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MTry<OptionAsync<B>>, Try<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MTry<OptionAsync<C>>, Try<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Try&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Try<OptionAsync<C>> SelectMany< A, B, C>(
            this Try<OptionAsync<A>> ma,
            Func<A, Task<OptionAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MTry<OptionAsync<A>>, Try<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MTry<OptionAsync<B>>, Try<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MTry<OptionAsync<C>>, Try<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Try&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Try<OptionAsync<C>> SelectMany< A, B, C>(
            this Try<OptionAsync<A>> ma,
            Func<A, OptionAsync<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MTry<OptionAsync<A>>, Try<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MTry<OptionAsync<B>>, Try<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MTry<OptionAsync<C>>, Try<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Try&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Try<OptionAsync<C>> SelectMany< A, B, C>(
            this Try<OptionAsync<A>> ma,
            Func<A, Task<OptionAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MTry<OptionAsync<A>>, Try<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MTry<OptionAsync<B>>, Try<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MTry<OptionAsync<C>>, Try<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<OptionAsync<A>> Where< A>(this Try<OptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MTry<OptionAsync<A>>, Try<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).Bind<MTry<OptionAsync<A>>, Try<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<OptionAsync<A>> Where< A>(this Try<OptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MTry<OptionAsync<A>>, Try<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).BindAsync<MTry<OptionAsync<A>>, Try<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<OptionAsync<B>> Select< A, B>(this Try<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MTry<OptionAsync<A>>, Try<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Map<MTry<OptionAsync<B>>, Try<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Try&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;OptionAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Try&lt;OptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this Try<OptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MTry<OptionAsync<A>>, Try<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Try&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;OptionAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Try&lt;OptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this Try<OptionAsync<A>> ma) =>
            default(TransSyncAsync<MTry<OptionAsync<A>>, Try<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<OptionAsync<B>> BindT< A, B>(this Try<OptionAsync<A>> ma, Func<A, OptionAsync<B>> f) =>
            default(TransSyncAsync<MTry<OptionAsync<A>>, Try<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Bind<MTry<OptionAsync<B>>, Try<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Try&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;Try&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Try&lt;B&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<Try<B>> Traverse< A, B>(this Try<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MTry<OptionAsync<A>>, Try<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Traverse<MOptionAsync<Try<B>>, OptionAsync<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Try&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;Try&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Try&lt;B&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<Try<B>> Traverse< A, B>(this Try<OptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MTry<OptionAsync<A>>, Try<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .TraverseAsync<MOptionAsync<Try<B>>, OptionAsync<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Try&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;Try&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<Try<A>> Sequence< A>(this Try<OptionAsync<A>> ma) =>
            default(TransSyncAsync<MTry<OptionAsync<A>>, Try<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Sequence<MOptionAsync<Try<A>>, OptionAsync<Try<A>>, MTry<A>, Try<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<OptionAsync<B>> MapT< A, B>(this Try<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MTry<OptionAsync<A>>, Try<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Map<MTry<OptionAsync<B>>, Try<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<OptionAsync<B>> MapT< A, B>(this Try<OptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MTry<OptionAsync<A>>, Try<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .MapAsync<MTry<OptionAsync<B>>, Try<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Try<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MTry<OptionAsync<A>>, Try<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Try<OptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MTry<OptionAsync<A>>, Try<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Try<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MTry<OptionAsync<A>>, Try<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Try<OptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MTry<OptionAsync<A>>, Try<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this Try<OptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MTry<OptionAsync<A>>, Try<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this Try<OptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MTry<OptionAsync<A>>, Try<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Try&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this Try<OptionAsync<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MTry<OptionAsync<A>>, Try<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<OptionAsync<A>> FilterT< A>(this Try<OptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MTry<OptionAsync<A>>, Try<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Bind<MTry<OptionAsync<A>>, Try<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<OptionAsync<A>> FilterT< A>(this Try<OptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MTry<OptionAsync<A>>, Try<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .BindAsync<MTry<OptionAsync<A>>, Try<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Try<OptionAsync<A>> PlusT<NUM,  A>(this Try<OptionAsync<A>> x, Try<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Try<OptionAsync<A>> SubtractT<NUM,  A>(this Try<OptionAsync<A>> x, Try<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Try<OptionAsync<A>> ProductT<NUM,  A>(this Try<OptionAsync<A>> x, Try<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Try<OptionAsync<A>> DivideT<NUM,  A>(this Try<OptionAsync<A>> x, Try<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Try<OptionAsync<A>> AppendT<SEMI,  A>(this Try<OptionAsync<A>> x, Try<OptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this Try<OptionAsync<A>> x, Try<OptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this Try<OptionAsync<A>> x, Try<OptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Try&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Try&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Try<OptionAsync<B>> ApplyT< A, B>(this Func<A, B> fab, Try<OptionAsync<A>> fa) =>
            default(ApplTry< OptionAsync<A>, OptionAsync<B>>).Apply(
                default(MTry< Func<OptionAsync<A>, OptionAsync<B>>>).Return(
                    (OptionAsync<A> a) => 
                        default(ApplOptionAsync< A, B>).Apply(
                            default(MOptionAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Try&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Try&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Try&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Try<OptionAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Try<OptionAsync<A>> fa, Try<OptionAsync<B>> fb) =>
            default(ApplTry< OptionAsync<A>, OptionAsync<B>, OptionAsync<C>>).Apply(
                default(MTry< Func<OptionAsync<A>, Func<OptionAsync<B>, OptionAsync<C>>>>).Return(
                    (OptionAsync<A> a) =>
                        (OptionAsync<B> b) =>
                            default(ApplOptionAsync< A, B, C>).Apply(
                                default(MOptionAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOption&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<OptionAsync<C>> SelectMany< A, B, C>(
            this TryOption<OptionAsync<A>> ma,
            Func<A, OptionAsync<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MTryOption<OptionAsync<A>>, TryOption<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MTryOption<OptionAsync<B>>, TryOption<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MTryOption<OptionAsync<C>>, TryOption<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOption&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<OptionAsync<C>> SelectMany< A, B, C>(
            this TryOption<OptionAsync<A>> ma,
            Func<A, Task<OptionAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MTryOption<OptionAsync<A>>, TryOption<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MTryOption<OptionAsync<B>>, TryOption<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MTryOption<OptionAsync<C>>, TryOption<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOption&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<OptionAsync<C>> SelectMany< A, B, C>(
            this TryOption<OptionAsync<A>> ma,
            Func<A, OptionAsync<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MTryOption<OptionAsync<A>>, TryOption<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MTryOption<OptionAsync<B>>, TryOption<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MTryOption<OptionAsync<C>>, TryOption<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOption&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<OptionAsync<C>> SelectMany< A, B, C>(
            this TryOption<OptionAsync<A>> ma,
            Func<A, Task<OptionAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MTryOption<OptionAsync<A>>, TryOption<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MTryOption<OptionAsync<B>>, TryOption<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MTryOption<OptionAsync<C>>, TryOption<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<OptionAsync<A>> Where< A>(this TryOption<OptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MTryOption<OptionAsync<A>>, TryOption<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).Bind<MTryOption<OptionAsync<A>>, TryOption<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<OptionAsync<A>> Where< A>(this TryOption<OptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MTryOption<OptionAsync<A>>, TryOption<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).BindAsync<MTryOption<OptionAsync<A>>, TryOption<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<OptionAsync<B>> Select< A, B>(this TryOption<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MTryOption<OptionAsync<A>>, TryOption<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Map<MTryOption<OptionAsync<B>>, TryOption<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOption&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;OptionAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOption&lt;OptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this TryOption<OptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MTryOption<OptionAsync<A>>, TryOption<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOption&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;OptionAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOption&lt;OptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this TryOption<OptionAsync<A>> ma) =>
            default(TransSyncAsync<MTryOption<OptionAsync<A>>, TryOption<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<OptionAsync<B>> BindT< A, B>(this TryOption<OptionAsync<A>> ma, Func<A, OptionAsync<B>> f) =>
            default(TransSyncAsync<MTryOption<OptionAsync<A>>, TryOption<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Bind<MTryOption<OptionAsync<B>>, TryOption<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOption&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;TryOption&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;TryOption&lt;B&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<TryOption<B>> Traverse< A, B>(this TryOption<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MTryOption<OptionAsync<A>>, TryOption<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Traverse<MOptionAsync<TryOption<B>>, OptionAsync<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOption&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;TryOption&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;TryOption&lt;B&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<TryOption<B>> Traverse< A, B>(this TryOption<OptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MTryOption<OptionAsync<A>>, TryOption<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .TraverseAsync<MOptionAsync<TryOption<B>>, OptionAsync<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOption&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;TryOption&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<TryOption<A>> Sequence< A>(this TryOption<OptionAsync<A>> ma) =>
            default(TransSyncAsync<MTryOption<OptionAsync<A>>, TryOption<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Sequence<MOptionAsync<TryOption<A>>, OptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<OptionAsync<B>> MapT< A, B>(this TryOption<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MTryOption<OptionAsync<A>>, TryOption<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Map<MTryOption<OptionAsync<B>>, TryOption<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<OptionAsync<B>> MapT< A, B>(this TryOption<OptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MTryOption<OptionAsync<A>>, TryOption<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .MapAsync<MTryOption<OptionAsync<B>>, TryOption<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryOption<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MTryOption<OptionAsync<A>>, TryOption<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryOption<OptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MTryOption<OptionAsync<A>>, TryOption<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryOption<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MTryOption<OptionAsync<A>>, TryOption<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryOption<OptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MTryOption<OptionAsync<A>>, TryOption<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this TryOption<OptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MTryOption<OptionAsync<A>>, TryOption<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this TryOption<OptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MTryOption<OptionAsync<A>>, TryOption<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOption&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this TryOption<OptionAsync<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MTryOption<OptionAsync<A>>, TryOption<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<OptionAsync<A>> FilterT< A>(this TryOption<OptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MTryOption<OptionAsync<A>>, TryOption<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Bind<MTryOption<OptionAsync<A>>, TryOption<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<OptionAsync<A>> FilterT< A>(this TryOption<OptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MTryOption<OptionAsync<A>>, TryOption<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .BindAsync<MTryOption<OptionAsync<A>>, TryOption<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<OptionAsync<A>> PlusT<NUM,  A>(this TryOption<OptionAsync<A>> x, TryOption<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<OptionAsync<A>> SubtractT<NUM,  A>(this TryOption<OptionAsync<A>> x, TryOption<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOption<OptionAsync<A>> ProductT<NUM,  A>(this TryOption<OptionAsync<A>> x, TryOption<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOption<OptionAsync<A>> DivideT<NUM,  A>(this TryOption<OptionAsync<A>> x, TryOption<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOption<OptionAsync<A>> AppendT<SEMI,  A>(this TryOption<OptionAsync<A>> x, TryOption<OptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this TryOption<OptionAsync<A>> x, TryOption<OptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this TryOption<OptionAsync<A>> x, TryOption<OptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOption&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`TryOption&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOption<OptionAsync<B>> ApplyT< A, B>(this Func<A, B> fab, TryOption<OptionAsync<A>> fa) =>
            default(ApplTryOption< OptionAsync<A>, OptionAsync<B>>).Apply(
                default(MTryOption< Func<OptionAsync<A>, OptionAsync<B>>>).Return(
                    (OptionAsync<A> a) => 
                        default(ApplOptionAsync< A, B>).Apply(
                            default(MOptionAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOption&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryOption&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`TryOption&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOption<OptionAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOption<OptionAsync<A>> fa, TryOption<OptionAsync<B>> fb) =>
            default(ApplTryOption< OptionAsync<A>, OptionAsync<B>, OptionAsync<C>>).Apply(
                default(MTryOption< Func<OptionAsync<A>, Func<OptionAsync<B>, OptionAsync<C>>>>).Return(
                    (OptionAsync<A> a) =>
                        (OptionAsync<B> b) =>
                            default(ApplOptionAsync< A, B, C>).Apply(
                                default(MOptionAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`IEnumerable&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<OptionAsync<C>> SelectMany< A, B, C>(
            this IEnumerable<OptionAsync<A>> ma,
            Func<A, OptionAsync<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MEnumerable<OptionAsync<A>>, IEnumerable<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MEnumerable<OptionAsync<B>>, IEnumerable<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MEnumerable<OptionAsync<C>>, IEnumerable<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`IEnumerable&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<OptionAsync<C>> SelectMany< A, B, C>(
            this IEnumerable<OptionAsync<A>> ma,
            Func<A, Task<OptionAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MEnumerable<OptionAsync<A>>, IEnumerable<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MEnumerable<OptionAsync<B>>, IEnumerable<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MEnumerable<OptionAsync<C>>, IEnumerable<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`IEnumerable&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<OptionAsync<C>> SelectMany< A, B, C>(
            this IEnumerable<OptionAsync<A>> ma,
            Func<A, OptionAsync<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MEnumerable<OptionAsync<A>>, IEnumerable<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MEnumerable<OptionAsync<B>>, IEnumerable<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MEnumerable<OptionAsync<C>>, IEnumerable<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`IEnumerable&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<OptionAsync<C>> SelectMany< A, B, C>(
            this IEnumerable<OptionAsync<A>> ma,
            Func<A, Task<OptionAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MEnumerable<OptionAsync<A>>, IEnumerable<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MEnumerable<OptionAsync<B>>, IEnumerable<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MEnumerable<OptionAsync<C>>, IEnumerable<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<OptionAsync<A>> Where< A>(this IEnumerable<OptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MEnumerable<OptionAsync<A>>, IEnumerable<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).Bind<MEnumerable<OptionAsync<A>>, IEnumerable<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<OptionAsync<A>> Where< A>(this IEnumerable<OptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MEnumerable<OptionAsync<A>>, IEnumerable<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).BindAsync<MEnumerable<OptionAsync<A>>, IEnumerable<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<OptionAsync<B>> Select< A, B>(this IEnumerable<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MEnumerable<OptionAsync<A>>, IEnumerable<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Map<MEnumerable<OptionAsync<B>>, IEnumerable<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `IEnumerable&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;OptionAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `IEnumerable&lt;OptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this IEnumerable<OptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MEnumerable<OptionAsync<A>>, IEnumerable<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `IEnumerable&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;OptionAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `IEnumerable&lt;OptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this IEnumerable<OptionAsync<A>> ma) =>
            default(TransSyncAsync<MEnumerable<OptionAsync<A>>, IEnumerable<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<OptionAsync<B>> BindT< A, B>(this IEnumerable<OptionAsync<A>> ma, Func<A, OptionAsync<B>> f) =>
            default(TransSyncAsync<MEnumerable<OptionAsync<A>>, IEnumerable<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Bind<MEnumerable<OptionAsync<B>>, IEnumerable<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `IEnumerable&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;IEnumerable&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;IEnumerable&lt;B&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<IEnumerable<B>> Traverse< A, B>(this IEnumerable<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MEnumerable<OptionAsync<A>>, IEnumerable<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Traverse<MOptionAsync<IEnumerable<B>>, OptionAsync<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `IEnumerable&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;IEnumerable&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;IEnumerable&lt;B&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<IEnumerable<B>> Traverse< A, B>(this IEnumerable<OptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MEnumerable<OptionAsync<A>>, IEnumerable<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .TraverseAsync<MOptionAsync<IEnumerable<B>>, OptionAsync<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `IEnumerable&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;IEnumerable&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<IEnumerable<A>> Sequence< A>(this IEnumerable<OptionAsync<A>> ma) =>
            default(TransSyncAsync<MEnumerable<OptionAsync<A>>, IEnumerable<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Sequence<MOptionAsync<IEnumerable<A>>, OptionAsync<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<OptionAsync<B>> MapT< A, B>(this IEnumerable<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MEnumerable<OptionAsync<A>>, IEnumerable<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Map<MEnumerable<OptionAsync<B>>, IEnumerable<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<OptionAsync<B>> MapT< A, B>(this IEnumerable<OptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MEnumerable<OptionAsync<A>>, IEnumerable<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .MapAsync<MEnumerable<OptionAsync<B>>, IEnumerable<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this IEnumerable<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MEnumerable<OptionAsync<A>>, IEnumerable<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this IEnumerable<OptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MEnumerable<OptionAsync<A>>, IEnumerable<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this IEnumerable<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MEnumerable<OptionAsync<A>>, IEnumerable<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this IEnumerable<OptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MEnumerable<OptionAsync<A>>, IEnumerable<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this IEnumerable<OptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MEnumerable<OptionAsync<A>>, IEnumerable<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this IEnumerable<OptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MEnumerable<OptionAsync<A>>, IEnumerable<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `IEnumerable&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this IEnumerable<OptionAsync<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MEnumerable<OptionAsync<A>>, IEnumerable<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<OptionAsync<A>> FilterT< A>(this IEnumerable<OptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MEnumerable<OptionAsync<A>>, IEnumerable<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Bind<MEnumerable<OptionAsync<A>>, IEnumerable<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<OptionAsync<A>> FilterT< A>(this IEnumerable<OptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MEnumerable<OptionAsync<A>>, IEnumerable<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .BindAsync<MEnumerable<OptionAsync<A>>, IEnumerable<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<OptionAsync<A>> PlusT<NUM,  A>(this IEnumerable<OptionAsync<A>> x, IEnumerable<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<OptionAsync<A>> SubtractT<NUM,  A>(this IEnumerable<OptionAsync<A>> x, IEnumerable<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static IEnumerable<OptionAsync<A>> ProductT<NUM,  A>(this IEnumerable<OptionAsync<A>> x, IEnumerable<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static IEnumerable<OptionAsync<A>> DivideT<NUM,  A>(this IEnumerable<OptionAsync<A>> x, IEnumerable<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static IEnumerable<OptionAsync<A>> AppendT<SEMI,  A>(this IEnumerable<OptionAsync<A>> x, IEnumerable<OptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this IEnumerable<OptionAsync<A>> x, IEnumerable<OptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this IEnumerable<OptionAsync<A>> x, IEnumerable<OptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `IEnumerable&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`IEnumerable&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static IEnumerable<OptionAsync<B>> ApplyT< A, B>(this Func<A, B> fab, IEnumerable<OptionAsync<A>> fa) =>
            default(ApplEnumerable< OptionAsync<A>, OptionAsync<B>>).Apply(
                default(MEnumerable< Func<OptionAsync<A>, OptionAsync<B>>>).Return(
                    (OptionAsync<A> a) => 
                        default(ApplOptionAsync< A, B>).Apply(
                            default(MOptionAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `IEnumerable&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `IEnumerable&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`IEnumerable&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static IEnumerable<OptionAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, IEnumerable<OptionAsync<A>> fa, IEnumerable<OptionAsync<B>> fb) =>
            default(ApplEnumerable< OptionAsync<A>, OptionAsync<B>, OptionAsync<C>>).Apply(
                default(MEnumerable< Func<OptionAsync<A>, Func<OptionAsync<B>, OptionAsync<C>>>>).Return(
                    (OptionAsync<A> a) =>
                        (OptionAsync<B> b) =>
                            default(ApplOptionAsync< A, B, C>).Apply(
                                default(MOptionAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Seq&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Seq<OptionAsync<C>> SelectMany< A, B, C>(
            this Seq<OptionAsync<A>> ma,
            Func<A, OptionAsync<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MSeq<OptionAsync<A>>, Seq<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MSeq<OptionAsync<B>>, Seq<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MSeq<OptionAsync<C>>, Seq<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Seq&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Seq<OptionAsync<C>> SelectMany< A, B, C>(
            this Seq<OptionAsync<A>> ma,
            Func<A, Task<OptionAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MSeq<OptionAsync<A>>, Seq<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MSeq<OptionAsync<B>>, Seq<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MSeq<OptionAsync<C>>, Seq<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Seq&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Seq<OptionAsync<C>> SelectMany< A, B, C>(
            this Seq<OptionAsync<A>> ma,
            Func<A, OptionAsync<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MSeq<OptionAsync<A>>, Seq<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MSeq<OptionAsync<B>>, Seq<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MSeq<OptionAsync<C>>, Seq<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Seq&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Seq<OptionAsync<C>> SelectMany< A, B, C>(
            this Seq<OptionAsync<A>> ma,
            Func<A, Task<OptionAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MSeq<OptionAsync<A>>, Seq<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MSeq<OptionAsync<B>>, Seq<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MSeq<OptionAsync<C>>, Seq<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<OptionAsync<A>> Where< A>(this Seq<OptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MSeq<OptionAsync<A>>, Seq<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).Bind<MSeq<OptionAsync<A>>, Seq<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<OptionAsync<A>> Where< A>(this Seq<OptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MSeq<OptionAsync<A>>, Seq<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).BindAsync<MSeq<OptionAsync<A>>, Seq<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<OptionAsync<B>> Select< A, B>(this Seq<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MSeq<OptionAsync<A>>, Seq<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Map<MSeq<OptionAsync<B>>, Seq<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Seq&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;OptionAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Seq&lt;OptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this Seq<OptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MSeq<OptionAsync<A>>, Seq<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Seq&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;OptionAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Seq&lt;OptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this Seq<OptionAsync<A>> ma) =>
            default(TransSyncAsync<MSeq<OptionAsync<A>>, Seq<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Seq&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<OptionAsync<B>> BindT< A, B>(this Seq<OptionAsync<A>> ma, Func<A, OptionAsync<B>> f) =>
            default(TransSyncAsync<MSeq<OptionAsync<A>>, Seq<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Bind<MSeq<OptionAsync<B>>, Seq<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Seq&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;Seq&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Seq&lt;B&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<Seq<B>> Traverse< A, B>(this Seq<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MSeq<OptionAsync<A>>, Seq<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Traverse<MOptionAsync<Seq<B>>, OptionAsync<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Seq&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;Seq&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Seq&lt;B&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<Seq<B>> Traverse< A, B>(this Seq<OptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MSeq<OptionAsync<A>>, Seq<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .TraverseAsync<MOptionAsync<Seq<B>>, OptionAsync<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Seq&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;Seq&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<Seq<A>> Sequence< A>(this Seq<OptionAsync<A>> ma) =>
            default(TransSyncAsync<MSeq<OptionAsync<A>>, Seq<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Sequence<MOptionAsync<Seq<A>>, OptionAsync<Seq<A>>, MSeq<A>, Seq<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<OptionAsync<B>> MapT< A, B>(this Seq<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MSeq<OptionAsync<A>>, Seq<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Map<MSeq<OptionAsync<B>>, Seq<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<OptionAsync<B>> MapT< A, B>(this Seq<OptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MSeq<OptionAsync<A>>, Seq<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .MapAsync<MSeq<OptionAsync<B>>, Seq<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Seq<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MSeq<OptionAsync<A>>, Seq<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Seq<OptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MSeq<OptionAsync<A>>, Seq<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Seq<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MSeq<OptionAsync<A>>, Seq<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Seq<OptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MSeq<OptionAsync<A>>, Seq<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this Seq<OptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MSeq<OptionAsync<A>>, Seq<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this Seq<OptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MSeq<OptionAsync<A>>, Seq<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Seq&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this Seq<OptionAsync<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MSeq<OptionAsync<A>>, Seq<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<OptionAsync<A>> FilterT< A>(this Seq<OptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MSeq<OptionAsync<A>>, Seq<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Bind<MSeq<OptionAsync<A>>, Seq<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<OptionAsync<A>> FilterT< A>(this Seq<OptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MSeq<OptionAsync<A>>, Seq<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .BindAsync<MSeq<OptionAsync<A>>, Seq<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Seq<OptionAsync<A>> PlusT<NUM,  A>(this Seq<OptionAsync<A>> x, Seq<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Seq<OptionAsync<A>> SubtractT<NUM,  A>(this Seq<OptionAsync<A>> x, Seq<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Seq<OptionAsync<A>> ProductT<NUM,  A>(this Seq<OptionAsync<A>> x, Seq<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Seq<OptionAsync<A>> DivideT<NUM,  A>(this Seq<OptionAsync<A>> x, Seq<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Seq<OptionAsync<A>> AppendT<SEMI,  A>(this Seq<OptionAsync<A>> x, Seq<OptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this Seq<OptionAsync<A>> x, Seq<OptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this Seq<OptionAsync<A>> x, Seq<OptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Seq&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Seq&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Seq<OptionAsync<B>> ApplyT< A, B>(this Func<A, B> fab, Seq<OptionAsync<A>> fa) =>
            default(ApplSeq< OptionAsync<A>, OptionAsync<B>>).Apply(
                default(MSeq< Func<OptionAsync<A>, OptionAsync<B>>>).Return(
                    (OptionAsync<A> a) => 
                        default(ApplOptionAsync< A, B>).Apply(
                            default(MOptionAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Seq&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Seq&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Seq&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Seq<OptionAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Seq<OptionAsync<A>> fa, Seq<OptionAsync<B>> fb) =>
            default(ApplSeq< OptionAsync<A>, OptionAsync<B>, OptionAsync<C>>).Apply(
                default(MSeq< Func<OptionAsync<A>, Func<OptionAsync<B>, OptionAsync<C>>>>).Return(
                    (OptionAsync<A> a) =>
                        (OptionAsync<B> b) =>
                            default(ApplOptionAsync< A, B, C>).Apply(
                                default(MOptionAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Set&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Set<OptionAsync<C>> SelectMany< A, B, C>(
            this Set<OptionAsync<A>> ma,
            Func<A, OptionAsync<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MSet<OptionAsync<A>>, Set<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MSet<OptionAsync<B>>, Set<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MSet<OptionAsync<C>>, Set<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Set&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Set<OptionAsync<C>> SelectMany< A, B, C>(
            this Set<OptionAsync<A>> ma,
            Func<A, Task<OptionAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MSet<OptionAsync<A>>, Set<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MSet<OptionAsync<B>>, Set<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MSet<OptionAsync<C>>, Set<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Set&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Set<OptionAsync<C>> SelectMany< A, B, C>(
            this Set<OptionAsync<A>> ma,
            Func<A, OptionAsync<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MSet<OptionAsync<A>>, Set<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MSet<OptionAsync<B>>, Set<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MSet<OptionAsync<C>>, Set<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Set&lt;OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Set<OptionAsync<C>> SelectMany< A, B, C>(
            this Set<OptionAsync<A>> ma,
            Func<A, Task<OptionAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MSet<OptionAsync<A>>, Set<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MSet<OptionAsync<B>>, Set<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MSet<OptionAsync<C>>, Set<OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<OptionAsync<A>> Where< A>(this Set<OptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MSet<OptionAsync<A>>, Set<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).Bind<MSet<OptionAsync<A>>, Set<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<OptionAsync<A>> Where< A>(this Set<OptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MSet<OptionAsync<A>>, Set<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).BindAsync<MSet<OptionAsync<A>>, Set<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<OptionAsync<B>> Select< A, B>(this Set<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MSet<OptionAsync<A>>, Set<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Map<MSet<OptionAsync<B>>, Set<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Set&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;OptionAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Set&lt;OptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this Set<OptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MSet<OptionAsync<A>>, Set<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Set&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;OptionAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Set&lt;OptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this Set<OptionAsync<A>> ma) =>
            default(TransSyncAsync<MSet<OptionAsync<A>>, Set<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<OptionAsync<B>> BindT< A, B>(this Set<OptionAsync<A>> ma, Func<A, OptionAsync<B>> f) =>
            default(TransSyncAsync<MSet<OptionAsync<A>>, Set<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Bind<MSet<OptionAsync<B>>, Set<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Set&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;Set&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Set&lt;B&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<Set<B>> Traverse< A, B>(this Set<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MSet<OptionAsync<A>>, Set<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Traverse<MOptionAsync<Set<B>>, OptionAsync<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Set&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;Set&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Set&lt;B&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<Set<B>> Traverse< A, B>(this Set<OptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MSet<OptionAsync<A>>, Set<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .TraverseAsync<MOptionAsync<Set<B>>, OptionAsync<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Set&lt;OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;Set&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<Set<A>> Sequence< A>(this Set<OptionAsync<A>> ma) =>
            default(TransSyncAsync<MSet<OptionAsync<A>>, Set<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Sequence<MOptionAsync<Set<A>>, OptionAsync<Set<A>>, MSet<A>, Set<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<OptionAsync<B>> MapT< A, B>(this Set<OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MSet<OptionAsync<A>>, Set<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Map<MSet<OptionAsync<B>>, Set<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<OptionAsync<B>> MapT< A, B>(this Set<OptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MSet<OptionAsync<A>>, Set<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .MapAsync<MSet<OptionAsync<B>>, Set<OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Set<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MSet<OptionAsync<A>>, Set<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Set<OptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MSet<OptionAsync<A>>, Set<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Set<OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MSet<OptionAsync<A>>, Set<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Set<OptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MSet<OptionAsync<A>>, Set<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this Set<OptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MSet<OptionAsync<A>>, Set<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this Set<OptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MSet<OptionAsync<A>>, Set<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Set&lt;OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this Set<OptionAsync<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MSet<OptionAsync<A>>, Set<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<OptionAsync<A>> FilterT< A>(this Set<OptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MSet<OptionAsync<A>>, Set<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Bind<MSet<OptionAsync<A>>, Set<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<OptionAsync<A>> FilterT< A>(this Set<OptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MSet<OptionAsync<A>>, Set<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .BindAsync<MSet<OptionAsync<A>>, Set<OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Set<OptionAsync<A>> PlusT<NUM,  A>(this Set<OptionAsync<A>> x, Set<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Set<OptionAsync<A>> SubtractT<NUM,  A>(this Set<OptionAsync<A>> x, Set<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Set<OptionAsync<A>> ProductT<NUM,  A>(this Set<OptionAsync<A>> x, Set<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Set<OptionAsync<A>> DivideT<NUM,  A>(this Set<OptionAsync<A>> x, Set<OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Set<OptionAsync<A>> AppendT<SEMI,  A>(this Set<OptionAsync<A>> x, Set<OptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this Set<OptionAsync<A>> x, Set<OptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;OptionAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this Set<OptionAsync<A>> x, Set<OptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Set&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Set&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Set<OptionAsync<B>> ApplyT< A, B>(this Func<A, B> fab, Set<OptionAsync<A>> fa) =>
            default(ApplSet< OptionAsync<A>, OptionAsync<B>>).Apply(
                default(MSet< Func<OptionAsync<A>, OptionAsync<B>>>).Return(
                    (OptionAsync<A> a) => 
                        default(ApplOptionAsync< A, B>).Apply(
                            default(MOptionAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Set&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Set&lt;OptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Set&lt;OptionAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Set<OptionAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Set<OptionAsync<A>> fa, Set<OptionAsync<B>> fb) =>
            default(ApplSet< OptionAsync<A>, OptionAsync<B>, OptionAsync<C>>).Apply(
                default(MSet< Func<OptionAsync<A>, Func<OptionAsync<B>, OptionAsync<C>>>>).Return(
                    (OptionAsync<A> a) =>
                        (OptionAsync<B> b) =>
                            default(ApplOptionAsync< A, B, C>).Apply(
                                default(MOptionAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Validation&lt;FAIL, OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Validation<FAIL, OptionAsync<C>> SelectMany<FAIL, A, B, C>(
            this Validation<FAIL, OptionAsync<A>> ma,
            Func<A, OptionAsync<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MValidation<FAIL, OptionAsync<A>>, Validation<FAIL, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MValidation<FAIL, OptionAsync<B>>, Validation<FAIL, OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MValidation<FAIL, OptionAsync<C>>, Validation<FAIL, OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Validation&lt;FAIL, OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Validation<FAIL, OptionAsync<C>> SelectMany<FAIL, A, B, C>(
            this Validation<FAIL, OptionAsync<A>> ma,
            Func<A, Task<OptionAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MValidation<FAIL, OptionAsync<A>>, Validation<FAIL, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MValidation<FAIL, OptionAsync<B>>, Validation<FAIL, OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MValidation<FAIL, OptionAsync<C>>, Validation<FAIL, OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Validation&lt;FAIL, OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Validation<FAIL, OptionAsync<C>> SelectMany<FAIL, A, B, C>(
            this Validation<FAIL, OptionAsync<A>> ma,
            Func<A, OptionAsync<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MValidation<FAIL, OptionAsync<A>>, Validation<FAIL, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MValidation<FAIL, OptionAsync<B>>, Validation<FAIL, OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MValidation<FAIL, OptionAsync<C>>, Validation<FAIL, OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Validation&lt;FAIL, OptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Validation<FAIL, OptionAsync<C>> SelectMany<FAIL, A, B, C>(
            this Validation<FAIL, OptionAsync<A>> ma,
            Func<A, Task<OptionAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MValidation<FAIL, OptionAsync<A>>, Validation<FAIL, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .SelectManyAsync<MValidation<FAIL, OptionAsync<B>>, Validation<FAIL, OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B, MValidation<FAIL, OptionAsync<C>>, Validation<FAIL, OptionAsync<C>>, MOptionAsync<C>, OptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, OptionAsync<A>> Where<FAIL, A>(this Validation<FAIL, OptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MValidation<FAIL, OptionAsync<A>>, Validation<FAIL, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).Bind<MValidation<FAIL, OptionAsync<A>>, Validation<FAIL, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, OptionAsync<A>> Where<FAIL, A>(this Validation<FAIL, OptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MValidation<FAIL, OptionAsync<A>>, Validation<FAIL, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).BindAsync<MValidation<FAIL, OptionAsync<A>>, Validation<FAIL, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, OptionAsync<B>> Select<FAIL, A, B>(this Validation<FAIL, OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MValidation<FAIL, OptionAsync<A>>, Validation<FAIL, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Map<MValidation<FAIL, OptionAsync<B>>, Validation<FAIL, OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA, FAIL, A>(this Validation<FAIL, OptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MValidation<FAIL, OptionAsync<A>>, Validation<FAIL, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT<FAIL, A>(this Validation<FAIL, OptionAsync<A>> ma) =>
            default(TransSyncAsync<MValidation<FAIL, OptionAsync<A>>, Validation<FAIL, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Validation&lt;FAIL, OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, OptionAsync<B>> BindT<FAIL, A, B>(this Validation<FAIL, OptionAsync<A>> ma, Func<A, OptionAsync<B>> f) =>
            default(TransSyncAsync<MValidation<FAIL, OptionAsync<A>>, Validation<FAIL, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Bind<MValidation<FAIL, OptionAsync<B>>, Validation<FAIL, OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;Validation&lt;FAIL, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Validation&lt;FAIL, B&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<Validation<FAIL, B>> Traverse<FAIL, A, B>(this Validation<FAIL, OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MValidation<FAIL, OptionAsync<A>>, Validation<FAIL, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Traverse<MOptionAsync<Validation<FAIL, B>>, OptionAsync<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;Validation&lt;FAIL, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Validation&lt;FAIL, B&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<Validation<FAIL, B>> Traverse<FAIL, A, B>(this Validation<FAIL, OptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MValidation<FAIL, OptionAsync<A>>, Validation<FAIL, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .TraverseAsync<MOptionAsync<Validation<FAIL, B>>, OptionAsync<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<FAIL, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static OptionAsync<Validation<FAIL, A>> Sequence<FAIL, A>(this Validation<FAIL, OptionAsync<A>> ma) =>
            default(TransSyncAsync<MValidation<FAIL, OptionAsync<A>>, Validation<FAIL, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Sequence<MOptionAsync<Validation<FAIL, A>>, OptionAsync<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, OptionAsync<B>> MapT<FAIL, A, B>(this Validation<FAIL, OptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MValidation<FAIL, OptionAsync<A>>, Validation<FAIL, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Map<MValidation<FAIL, OptionAsync<B>>, Validation<FAIL, OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, OptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, OptionAsync<B>> MapT<FAIL, A, B>(this Validation<FAIL, OptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MValidation<FAIL, OptionAsync<A>>, Validation<FAIL, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .MapAsync<MValidation<FAIL, OptionAsync<B>>, Validation<FAIL, OptionAsync<B>>, MOptionAsync<B>, OptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, FAIL, A>(this Validation<FAIL, OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MValidation<FAIL, OptionAsync<A>>, Validation<FAIL, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, FAIL, A>(this Validation<FAIL, OptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MValidation<FAIL, OptionAsync<A>>, Validation<FAIL, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, FAIL, A>(this Validation<FAIL, OptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MValidation<FAIL, OptionAsync<A>>, Validation<FAIL, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, FAIL, A>(this Validation<FAIL, OptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MValidation<FAIL, OptionAsync<A>>, Validation<FAIL, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT<FAIL, A>(this Validation<FAIL, OptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MValidation<FAIL, OptionAsync<A>>, Validation<FAIL, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT<FAIL, A>(this Validation<FAIL, OptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MValidation<FAIL, OptionAsync<A>>, Validation<FAIL, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT<FAIL, A>(this Validation<FAIL, OptionAsync<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MValidation<FAIL, OptionAsync<A>>, Validation<FAIL, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, OptionAsync<A>> FilterT<FAIL, A>(this Validation<FAIL, OptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MValidation<FAIL, OptionAsync<A>>, Validation<FAIL, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .Bind<MValidation<FAIL, OptionAsync<A>>, Validation<FAIL, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, OptionAsync<A>> FilterT<FAIL, A>(this Validation<FAIL, OptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MValidation<FAIL, OptionAsync<A>>, Validation<FAIL, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>)
                .BindAsync<MValidation<FAIL, OptionAsync<A>>, Validation<FAIL, OptionAsync<A>>, MOptionAsync<A>, OptionAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Validation<FAIL, OptionAsync<A>> PlusT<NUM, FAIL, A>(this Validation<FAIL, OptionAsync<A>> x, Validation<FAIL, OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Validation<FAIL, OptionAsync<A>> SubtractT<NUM, FAIL, A>(this Validation<FAIL, OptionAsync<A>> x, Validation<FAIL, OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Validation<FAIL, OptionAsync<A>> ProductT<NUM, FAIL, A>(this Validation<FAIL, OptionAsync<A>> x, Validation<FAIL, OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Validation<FAIL, OptionAsync<A>> DivideT<NUM, FAIL, A>(this Validation<FAIL, OptionAsync<A>> x, Validation<FAIL, OptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Validation<FAIL, OptionAsync<A>> AppendT<SEMI, FAIL, A>(this Validation<FAIL, OptionAsync<A>> x, Validation<FAIL, OptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD, FAIL, A>(this Validation<FAIL, OptionAsync<A>> x, Validation<FAIL, OptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ, FAIL, A>(this Validation<FAIL, OptionAsync<A>> x, Validation<FAIL, OptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Validation&lt;FAIL, OptionAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Validation<FAIL, OptionAsync<B>> ApplyT<FAIL, A, B>(this Func<A, B> fab, Validation<FAIL, OptionAsync<A>> fa) =>
            default(ApplValidation<FAIL, OptionAsync<A>, OptionAsync<B>>).Apply(
                default(MValidation<FAIL, Func<OptionAsync<A>, OptionAsync<B>>>).Return(
                    (OptionAsync<A> a) => 
                        default(ApplOptionAsync< A, B>).Apply(
                            default(MOptionAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Validation&lt;FAIL, OptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Validation&lt;FAIL, OptionAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Validation<FAIL, OptionAsync<C>> ApplyT<FAIL, A, B, C>(this Func<A, B, C> fabc, Validation<FAIL, OptionAsync<A>> fa, Validation<FAIL, OptionAsync<B>> fb) =>
            default(ApplValidation<FAIL, OptionAsync<A>, OptionAsync<B>, OptionAsync<C>>).Apply(
                default(MValidation<FAIL, Func<OptionAsync<A>, Func<OptionAsync<B>, OptionAsync<C>>>>).Return(
                    (OptionAsync<A> a) =>
                        (OptionAsync<B> b) =>
                            default(ApplOptionAsync< A, B, C>).Apply(
                                default(MOptionAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

    }
    /// <summary>
    /// Async monad transformer for Task, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class TaskT_SyncAsync_Extensions
    {
        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Arr&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<Task<C>> SelectMany< A, B, C>(
            this Arr<Task<A>> ma,
            Func<A, Task<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MArr<Task<B>>, Arr<Task<B>>, MTask<B>, Task<B>, B, MArr<Task<C>>, Arr<Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Arr&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<Task<C>> SelectMany< A, B, C>(
            this Arr<Task<A>> ma,
            Func<A, Task<Task<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MArr<Task<B>>, Arr<Task<B>>, MTask<B>, Task<B>, B, MArr<Task<C>>, Arr<Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Arr&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<Task<C>> SelectMany< A, B, C>(
            this Arr<Task<A>> ma,
            Func<A, Task<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MArr<Task<B>>, Arr<Task<B>>, MTask<B>, Task<B>, B, MArr<Task<C>>, Arr<Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Arr&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<Task<C>> SelectMany< A, B, C>(
            this Arr<Task<A>> ma,
            Func<A, Task<Task<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MArr<Task<B>>, Arr<Task<B>>, MTask<B>, Task<B>, B, MArr<Task<C>>, Arr<Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<Task<A>> Where< A>(this Arr<Task<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>).Bind<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                a => pred(a)
                    ? default(MTask<A>).ReturnAsync(a.AsTask())
                    : default(MTask<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<Task<A>> Where< A>(this Arr<Task<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>).BindAsync<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTask<A>).ReturnAsync(a.AsTask())
                    : default(MTask<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Task<B>> Select< A, B>(this Arr<Task<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>)
                .Map<MArr<Task<B>>, Arr<Task<B>>, MTask<B>, Task<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Arr&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Task&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Arr&lt;Task&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this Arr<Task<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Arr&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Task&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Arr&lt;Task&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this Arr<Task<A>> ma) =>
            default(TransSyncAsync<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Task<B>> BindT< A, B>(this Arr<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>)
                .Bind<MArr<Task<B>>, Arr<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Arr&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;Arr&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Arr&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Task<Arr<B>> Traverse< A, B>(this Arr<Task<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>)
                .Traverse<MTask<Arr<B>>, Task<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Arr&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;Arr&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Arr&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Task<Arr<B>> Traverse< A, B>(this Arr<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>)
                .TraverseAsync<MTask<Arr<B>>, Task<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Arr&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;Arr&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<Arr<A>> Sequence< A>(this Arr<Task<A>> ma) =>
            default(TransSyncAsync<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>)
                .Sequence<MTask<Arr<A>>, Task<Arr<A>>, MArr<A>, Arr<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Task<B>> MapT< A, B>(this Arr<Task<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>)
                .Map<MArr<Task<B>>, Arr<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Task<B>> MapT< A, B>(this Arr<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>)
                .MapAsync<MArr<Task<B>>, Arr<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Arr<Task<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Arr<Task<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Arr<Task<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Arr<Task<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this Arr<Task<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this Arr<Task<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Arr&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this Arr<Task<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<Task<A>> FilterT< A>(this Arr<Task<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>)
                .Bind<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).ReturnAsync(a.AsTask())
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<Task<A>> FilterT< A>(this Arr<Task<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>)
                .BindAsync<MArr<Task<A>>, Arr<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTask<A>).ReturnAsync(a.AsTask())
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Task&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Arr<Task<A>> PlusT<NUM,  A>(this Arr<Task<A>> x, Arr<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Task&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Arr<Task<A>> SubtractT<NUM,  A>(this Arr<Task<A>> x, Arr<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Task&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Arr<Task<A>> ProductT<NUM,  A>(this Arr<Task<A>> x, Arr<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Task&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Arr<Task<A>> DivideT<NUM,  A>(this Arr<Task<A>> x, Arr<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Task&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Arr<Task<A>> AppendT<SEMI,  A>(this Arr<Task<A>> x, Arr<Task<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this Arr<Task<A>> x, Arr<Task<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Task&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this Arr<Task<A>> x, Arr<Task<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Arr&lt;Task&lt;A&gt;&gt;`</param>
        /// <returns>`Arr&lt;Task&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Arr<Task<B>> ApplyT< A, B>(this Func<A, B> fab, Arr<Task<A>> fa) =>
            default(ApplArr< Task<A>, Task<B>>).Apply(
                default(MArr< Func<Task<A>, Task<B>>>).Return(
                    (Task<A> a) => 
                        default(ApplTask< A, B>).Apply(
                            default(MTask< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Arr&lt;Task&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Arr&lt;Task&lt;A&gt;&gt;`</param>
        /// <returns>`Arr&lt;Task&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Arr<Task<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Arr<Task<A>> fa, Arr<Task<B>> fb) =>
            default(ApplArr< Task<A>, Task<B>, Task<C>>).Apply(
                default(MArr< Func<Task<A>, Func<Task<B>, Task<C>>>>).Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            default(ApplTask< A, B, C>).Apply(
                                default(MTask< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`HashSet&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<Task<C>> SelectMany< A, B, C>(
            this HashSet<Task<A>> ma,
            Func<A, Task<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MHashSet<Task<B>>, HashSet<Task<B>>, MTask<B>, Task<B>, B, MHashSet<Task<C>>, HashSet<Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`HashSet&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<Task<C>> SelectMany< A, B, C>(
            this HashSet<Task<A>> ma,
            Func<A, Task<Task<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MHashSet<Task<B>>, HashSet<Task<B>>, MTask<B>, Task<B>, B, MHashSet<Task<C>>, HashSet<Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`HashSet&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<Task<C>> SelectMany< A, B, C>(
            this HashSet<Task<A>> ma,
            Func<A, Task<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MHashSet<Task<B>>, HashSet<Task<B>>, MTask<B>, Task<B>, B, MHashSet<Task<C>>, HashSet<Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`HashSet&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<Task<C>> SelectMany< A, B, C>(
            this HashSet<Task<A>> ma,
            Func<A, Task<Task<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MHashSet<Task<B>>, HashSet<Task<B>>, MTask<B>, Task<B>, B, MHashSet<Task<C>>, HashSet<Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<Task<A>> Where< A>(this HashSet<Task<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>).Bind<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                a => pred(a)
                    ? default(MTask<A>).ReturnAsync(a.AsTask())
                    : default(MTask<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<Task<A>> Where< A>(this HashSet<Task<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>).BindAsync<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTask<A>).ReturnAsync(a.AsTask())
                    : default(MTask<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Task<B>> Select< A, B>(this HashSet<Task<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>)
                .Map<MHashSet<Task<B>>, HashSet<Task<B>>, MTask<B>, Task<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `HashSet&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Task&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `HashSet&lt;Task&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this HashSet<Task<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `HashSet&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Task&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `HashSet&lt;Task&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this HashSet<Task<A>> ma) =>
            default(TransSyncAsync<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Task<B>> BindT< A, B>(this HashSet<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>)
                .Bind<MHashSet<Task<B>>, HashSet<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `HashSet&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;HashSet&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;HashSet&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Task<HashSet<B>> Traverse< A, B>(this HashSet<Task<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>)
                .Traverse<MTask<HashSet<B>>, Task<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `HashSet&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;HashSet&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;HashSet&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Task<HashSet<B>> Traverse< A, B>(this HashSet<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>)
                .TraverseAsync<MTask<HashSet<B>>, Task<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `HashSet&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;HashSet&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<HashSet<A>> Sequence< A>(this HashSet<Task<A>> ma) =>
            default(TransSyncAsync<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>)
                .Sequence<MTask<HashSet<A>>, Task<HashSet<A>>, MHashSet<A>, HashSet<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Task<B>> MapT< A, B>(this HashSet<Task<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>)
                .Map<MHashSet<Task<B>>, HashSet<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Task<B>> MapT< A, B>(this HashSet<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>)
                .MapAsync<MHashSet<Task<B>>, HashSet<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this HashSet<Task<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this HashSet<Task<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this HashSet<Task<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this HashSet<Task<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this HashSet<Task<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this HashSet<Task<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `HashSet&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this HashSet<Task<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<Task<A>> FilterT< A>(this HashSet<Task<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>)
                .Bind<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).ReturnAsync(a.AsTask())
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<Task<A>> FilterT< A>(this HashSet<Task<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>)
                .BindAsync<MHashSet<Task<A>>, HashSet<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTask<A>).ReturnAsync(a.AsTask())
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Task&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<Task<A>> PlusT<NUM,  A>(this HashSet<Task<A>> x, HashSet<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Task&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<Task<A>> SubtractT<NUM,  A>(this HashSet<Task<A>> x, HashSet<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Task&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static HashSet<Task<A>> ProductT<NUM,  A>(this HashSet<Task<A>> x, HashSet<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Task&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static HashSet<Task<A>> DivideT<NUM,  A>(this HashSet<Task<A>> x, HashSet<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Task&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static HashSet<Task<A>> AppendT<SEMI,  A>(this HashSet<Task<A>> x, HashSet<Task<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this HashSet<Task<A>> x, HashSet<Task<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Task&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this HashSet<Task<A>> x, HashSet<Task<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `HashSet&lt;Task&lt;A&gt;&gt;`</param>
        /// <returns>`HashSet&lt;Task&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static HashSet<Task<B>> ApplyT< A, B>(this Func<A, B> fab, HashSet<Task<A>> fa) =>
            default(ApplHashSet< Task<A>, Task<B>>).Apply(
                default(MHashSet< Func<Task<A>, Task<B>>>).Return(
                    (Task<A> a) => 
                        default(ApplTask< A, B>).Apply(
                            default(MTask< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `HashSet&lt;Task&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `HashSet&lt;Task&lt;A&gt;&gt;`</param>
        /// <returns>`HashSet&lt;Task&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static HashSet<Task<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, HashSet<Task<A>> fa, HashSet<Task<B>> fb) =>
            default(ApplHashSet< Task<A>, Task<B>, Task<C>>).Apply(
                default(MHashSet< Func<Task<A>, Func<Task<B>, Task<C>>>>).Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            default(ApplTask< A, B, C>).Apply(
                                default(MTask< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Lst&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<Task<C>> SelectMany< A, B, C>(
            this Lst<Task<A>> ma,
            Func<A, Task<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MLst<Task<B>>, Lst<Task<B>>, MTask<B>, Task<B>, B, MLst<Task<C>>, Lst<Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Lst&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<Task<C>> SelectMany< A, B, C>(
            this Lst<Task<A>> ma,
            Func<A, Task<Task<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MLst<Task<B>>, Lst<Task<B>>, MTask<B>, Task<B>, B, MLst<Task<C>>, Lst<Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Lst&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<Task<C>> SelectMany< A, B, C>(
            this Lst<Task<A>> ma,
            Func<A, Task<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MLst<Task<B>>, Lst<Task<B>>, MTask<B>, Task<B>, B, MLst<Task<C>>, Lst<Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Lst&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<Task<C>> SelectMany< A, B, C>(
            this Lst<Task<A>> ma,
            Func<A, Task<Task<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MLst<Task<B>>, Lst<Task<B>>, MTask<B>, Task<B>, B, MLst<Task<C>>, Lst<Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<Task<A>> Where< A>(this Lst<Task<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>).Bind<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                a => pred(a)
                    ? default(MTask<A>).ReturnAsync(a.AsTask())
                    : default(MTask<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<Task<A>> Where< A>(this Lst<Task<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>).BindAsync<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTask<A>).ReturnAsync(a.AsTask())
                    : default(MTask<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Task<B>> Select< A, B>(this Lst<Task<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>)
                .Map<MLst<Task<B>>, Lst<Task<B>>, MTask<B>, Task<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Lst&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Task&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Lst&lt;Task&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this Lst<Task<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Lst&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Task&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Lst&lt;Task&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this Lst<Task<A>> ma) =>
            default(TransSyncAsync<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Task<B>> BindT< A, B>(this Lst<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>)
                .Bind<MLst<Task<B>>, Lst<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Lst&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;Lst&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Lst&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Task<Lst<B>> Traverse< A, B>(this Lst<Task<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>)
                .Traverse<MTask<Lst<B>>, Task<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Lst&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;Lst&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Lst&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Task<Lst<B>> Traverse< A, B>(this Lst<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>)
                .TraverseAsync<MTask<Lst<B>>, Task<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Lst&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;Lst&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<Lst<A>> Sequence< A>(this Lst<Task<A>> ma) =>
            default(TransSyncAsync<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>)
                .Sequence<MTask<Lst<A>>, Task<Lst<A>>, MLst<A>, Lst<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Task<B>> MapT< A, B>(this Lst<Task<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>)
                .Map<MLst<Task<B>>, Lst<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Task<B>> MapT< A, B>(this Lst<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>)
                .MapAsync<MLst<Task<B>>, Lst<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Lst<Task<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Lst<Task<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Lst<Task<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Lst<Task<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this Lst<Task<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this Lst<Task<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Lst&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this Lst<Task<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<Task<A>> FilterT< A>(this Lst<Task<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>)
                .Bind<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).ReturnAsync(a.AsTask())
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<Task<A>> FilterT< A>(this Lst<Task<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>)
                .BindAsync<MLst<Task<A>>, Lst<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTask<A>).ReturnAsync(a.AsTask())
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Task&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Lst<Task<A>> PlusT<NUM,  A>(this Lst<Task<A>> x, Lst<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Task&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Lst<Task<A>> SubtractT<NUM,  A>(this Lst<Task<A>> x, Lst<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Task&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Lst<Task<A>> ProductT<NUM,  A>(this Lst<Task<A>> x, Lst<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Task&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Lst<Task<A>> DivideT<NUM,  A>(this Lst<Task<A>> x, Lst<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Task&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Lst<Task<A>> AppendT<SEMI,  A>(this Lst<Task<A>> x, Lst<Task<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this Lst<Task<A>> x, Lst<Task<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Task&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this Lst<Task<A>> x, Lst<Task<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Lst&lt;Task&lt;A&gt;&gt;`</param>
        /// <returns>`Lst&lt;Task&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Lst<Task<B>> ApplyT< A, B>(this Func<A, B> fab, Lst<Task<A>> fa) =>
            default(ApplLst< Task<A>, Task<B>>).Apply(
                default(MLst< Func<Task<A>, Task<B>>>).Return(
                    (Task<A> a) => 
                        default(ApplTask< A, B>).Apply(
                            default(MTask< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Lst&lt;Task&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Lst&lt;Task&lt;A&gt;&gt;`</param>
        /// <returns>`Lst&lt;Task&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Lst<Task<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Lst<Task<A>> fa, Lst<Task<B>> fb) =>
            default(ApplLst< Task<A>, Task<B>, Task<C>>).Apply(
                default(MLst< Func<Task<A>, Func<Task<B>, Task<C>>>>).Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            default(ApplTask< A, B, C>).Apply(
                                default(MTask< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Option&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Option<Task<C>> SelectMany< A, B, C>(
            this Option<Task<A>> ma,
            Func<A, Task<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MOption<Task<B>>, Option<Task<B>>, MTask<B>, Task<B>, B, MOption<Task<C>>, Option<Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Option&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Option<Task<C>> SelectMany< A, B, C>(
            this Option<Task<A>> ma,
            Func<A, Task<Task<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MOption<Task<B>>, Option<Task<B>>, MTask<B>, Task<B>, B, MOption<Task<C>>, Option<Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Option&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Option<Task<C>> SelectMany< A, B, C>(
            this Option<Task<A>> ma,
            Func<A, Task<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MOption<Task<B>>, Option<Task<B>>, MTask<B>, Task<B>, B, MOption<Task<C>>, Option<Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Option&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Option<Task<C>> SelectMany< A, B, C>(
            this Option<Task<A>> ma,
            Func<A, Task<Task<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MOption<Task<B>>, Option<Task<B>>, MTask<B>, Task<B>, B, MOption<Task<C>>, Option<Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<Task<A>> Where< A>(this Option<Task<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>).Bind<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                a => pred(a)
                    ? default(MTask<A>).ReturnAsync(a.AsTask())
                    : default(MTask<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<Task<A>> Where< A>(this Option<Task<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>).BindAsync<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTask<A>).ReturnAsync(a.AsTask())
                    : default(MTask<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Task<B>> Select< A, B>(this Option<Task<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>)
                .Map<MOption<Task<B>>, Option<Task<B>>, MTask<B>, Task<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Option&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Task&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Option&lt;Task&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this Option<Task<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Option&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Task&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Option&lt;Task&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this Option<Task<A>> ma) =>
            default(TransSyncAsync<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Task<B>> BindT< A, B>(this Option<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>)
                .Bind<MOption<Task<B>>, Option<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Option&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;Option&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Option&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Task<Option<B>> Traverse< A, B>(this Option<Task<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>)
                .Traverse<MTask<Option<B>>, Task<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Option&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;Option&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Option&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Task<Option<B>> Traverse< A, B>(this Option<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>)
                .TraverseAsync<MTask<Option<B>>, Task<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Option&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;Option&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<Option<A>> Sequence< A>(this Option<Task<A>> ma) =>
            default(TransSyncAsync<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>)
                .Sequence<MTask<Option<A>>, Task<Option<A>>, MOption<A>, Option<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Task<B>> MapT< A, B>(this Option<Task<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>)
                .Map<MOption<Task<B>>, Option<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Task<B>> MapT< A, B>(this Option<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>)
                .MapAsync<MOption<Task<B>>, Option<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Option<Task<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Option<Task<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Option<Task<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Option<Task<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this Option<Task<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this Option<Task<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Option&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this Option<Task<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<Task<A>> FilterT< A>(this Option<Task<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>)
                .Bind<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).ReturnAsync(a.AsTask())
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<Task<A>> FilterT< A>(this Option<Task<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>)
                .BindAsync<MOption<Task<A>>, Option<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTask<A>).ReturnAsync(a.AsTask())
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Task&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Option<Task<A>> PlusT<NUM,  A>(this Option<Task<A>> x, Option<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Task&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Option<Task<A>> SubtractT<NUM,  A>(this Option<Task<A>> x, Option<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Task&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Option<Task<A>> ProductT<NUM,  A>(this Option<Task<A>> x, Option<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Task&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Option<Task<A>> DivideT<NUM,  A>(this Option<Task<A>> x, Option<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Task&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Option<Task<A>> AppendT<SEMI,  A>(this Option<Task<A>> x, Option<Task<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this Option<Task<A>> x, Option<Task<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Task&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this Option<Task<A>> x, Option<Task<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Option&lt;Task&lt;A&gt;&gt;`</param>
        /// <returns>`Option&lt;Task&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Option<Task<B>> ApplyT< A, B>(this Func<A, B> fab, Option<Task<A>> fa) =>
            default(ApplOption< Task<A>, Task<B>>).Apply(
                default(MOption< Func<Task<A>, Task<B>>>).Return(
                    (Task<A> a) => 
                        default(ApplTask< A, B>).Apply(
                            default(MTask< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Option&lt;Task&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Option&lt;Task&lt;A&gt;&gt;`</param>
        /// <returns>`Option&lt;Task&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Option<Task<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Option<Task<A>> fa, Option<Task<B>> fb) =>
            default(ApplOption< Task<A>, Task<B>, Task<C>>).Apply(
                default(MOption< Func<Task<A>, Func<Task<B>, Task<C>>>>).Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            default(ApplTask< A, B, C>).Apply(
                                default(MTask< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionUnsafe&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<Task<C>> SelectMany< A, B, C>(
            this OptionUnsafe<Task<A>> ma,
            Func<A, Task<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MOptionUnsafe<Task<B>>, OptionUnsafe<Task<B>>, MTask<B>, Task<B>, B, MOptionUnsafe<Task<C>>, OptionUnsafe<Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionUnsafe&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<Task<C>> SelectMany< A, B, C>(
            this OptionUnsafe<Task<A>> ma,
            Func<A, Task<Task<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MOptionUnsafe<Task<B>>, OptionUnsafe<Task<B>>, MTask<B>, Task<B>, B, MOptionUnsafe<Task<C>>, OptionUnsafe<Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionUnsafe&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<Task<C>> SelectMany< A, B, C>(
            this OptionUnsafe<Task<A>> ma,
            Func<A, Task<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MOptionUnsafe<Task<B>>, OptionUnsafe<Task<B>>, MTask<B>, Task<B>, B, MOptionUnsafe<Task<C>>, OptionUnsafe<Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionUnsafe&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<Task<C>> SelectMany< A, B, C>(
            this OptionUnsafe<Task<A>> ma,
            Func<A, Task<Task<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MOptionUnsafe<Task<B>>, OptionUnsafe<Task<B>>, MTask<B>, Task<B>, B, MOptionUnsafe<Task<C>>, OptionUnsafe<Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<Task<A>> Where< A>(this OptionUnsafe<Task<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>).Bind<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                a => pred(a)
                    ? default(MTask<A>).ReturnAsync(a.AsTask())
                    : default(MTask<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<Task<A>> Where< A>(this OptionUnsafe<Task<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>).BindAsync<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTask<A>).ReturnAsync(a.AsTask())
                    : default(MTask<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Task<B>> Select< A, B>(this OptionUnsafe<Task<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>)
                .Map<MOptionUnsafe<Task<B>>, OptionUnsafe<Task<B>>, MTask<B>, Task<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionUnsafe&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Task&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionUnsafe&lt;Task&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this OptionUnsafe<Task<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionUnsafe&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Task&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionUnsafe&lt;Task&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this OptionUnsafe<Task<A>> ma) =>
            default(TransSyncAsync<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Task<B>> BindT< A, B>(this OptionUnsafe<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>)
                .Bind<MOptionUnsafe<Task<B>>, OptionUnsafe<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionUnsafe&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;OptionUnsafe&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;OptionUnsafe&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Task<OptionUnsafe<B>> Traverse< A, B>(this OptionUnsafe<Task<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>)
                .Traverse<MTask<OptionUnsafe<B>>, Task<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionUnsafe&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;OptionUnsafe&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;OptionUnsafe&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Task<OptionUnsafe<B>> Traverse< A, B>(this OptionUnsafe<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>)
                .TraverseAsync<MTask<OptionUnsafe<B>>, Task<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionUnsafe&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;OptionUnsafe&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<OptionUnsafe<A>> Sequence< A>(this OptionUnsafe<Task<A>> ma) =>
            default(TransSyncAsync<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>)
                .Sequence<MTask<OptionUnsafe<A>>, Task<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Task<B>> MapT< A, B>(this OptionUnsafe<Task<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>)
                .Map<MOptionUnsafe<Task<B>>, OptionUnsafe<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Task<B>> MapT< A, B>(this OptionUnsafe<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>)
                .MapAsync<MOptionUnsafe<Task<B>>, OptionUnsafe<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this OptionUnsafe<Task<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this OptionUnsafe<Task<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this OptionUnsafe<Task<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this OptionUnsafe<Task<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this OptionUnsafe<Task<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this OptionUnsafe<Task<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionUnsafe&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this OptionUnsafe<Task<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<Task<A>> FilterT< A>(this OptionUnsafe<Task<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>)
                .Bind<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).ReturnAsync(a.AsTask())
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<Task<A>> FilterT< A>(this OptionUnsafe<Task<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>)
                .BindAsync<MOptionUnsafe<Task<A>>, OptionUnsafe<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTask<A>).ReturnAsync(a.AsTask())
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Task&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<Task<A>> PlusT<NUM,  A>(this OptionUnsafe<Task<A>> x, OptionUnsafe<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Task&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<Task<A>> SubtractT<NUM,  A>(this OptionUnsafe<Task<A>> x, OptionUnsafe<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Task&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionUnsafe<Task<A>> ProductT<NUM,  A>(this OptionUnsafe<Task<A>> x, OptionUnsafe<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Task&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionUnsafe<Task<A>> DivideT<NUM,  A>(this OptionUnsafe<Task<A>> x, OptionUnsafe<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Task&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionUnsafe<Task<A>> AppendT<SEMI,  A>(this OptionUnsafe<Task<A>> x, OptionUnsafe<Task<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this OptionUnsafe<Task<A>> x, OptionUnsafe<Task<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Task&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this OptionUnsafe<Task<A>> x, OptionUnsafe<Task<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe&lt;Task&lt;A&gt;&gt;`</param>
        /// <returns>`OptionUnsafe&lt;Task&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionUnsafe<Task<B>> ApplyT< A, B>(this Func<A, B> fab, OptionUnsafe<Task<A>> fa) =>
            default(ApplOptionUnsafe< Task<A>, Task<B>>).Apply(
                default(MOptionUnsafe< Func<Task<A>, Task<B>>>).Return(
                    (Task<A> a) => 
                        default(ApplTask< A, B>).Apply(
                            default(MTask< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe&lt;Task&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `OptionUnsafe&lt;Task&lt;A&gt;&gt;`</param>
        /// <returns>`OptionUnsafe&lt;Task&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionUnsafe<Task<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, OptionUnsafe<Task<A>> fa, OptionUnsafe<Task<B>> fb) =>
            default(ApplOptionUnsafe< Task<A>, Task<B>, Task<C>>).Apply(
                default(MOptionUnsafe< Func<Task<A>, Func<Task<B>, Task<C>>>>).Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            default(ApplTask< A, B, C>).Apply(
                                default(MTask< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Either&lt;L, Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, Task<C>> SelectMany<L, A, B, C>(
            this Either<L, Task<A>> ma,
            Func<A, Task<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MEither<L, Task<B>>, Either<L, Task<B>>, MTask<B>, Task<B>, B, MEither<L, Task<C>>, Either<L, Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Either&lt;L, Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, Task<C>> SelectMany<L, A, B, C>(
            this Either<L, Task<A>> ma,
            Func<A, Task<Task<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MEither<L, Task<B>>, Either<L, Task<B>>, MTask<B>, Task<B>, B, MEither<L, Task<C>>, Either<L, Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Either&lt;L, Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, Task<C>> SelectMany<L, A, B, C>(
            this Either<L, Task<A>> ma,
            Func<A, Task<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MEither<L, Task<B>>, Either<L, Task<B>>, MTask<B>, Task<B>, B, MEither<L, Task<C>>, Either<L, Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Either&lt;L, Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, Task<C>> SelectMany<L, A, B, C>(
            this Either<L, Task<A>> ma,
            Func<A, Task<Task<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MEither<L, Task<B>>, Either<L, Task<B>>, MTask<B>, Task<B>, B, MEither<L, Task<C>>, Either<L, Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, Task<A>> Where<L, A>(this Either<L, Task<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>).Bind<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>(ma, 
                a => pred(a)
                    ? default(MTask<A>).ReturnAsync(a.AsTask())
                    : default(MTask<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, Task<A>> Where<L, A>(this Either<L, Task<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>).BindAsync<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTask<A>).ReturnAsync(a.AsTask())
                    : default(MTask<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Task<B>> Select<L, A, B>(this Either<L, Task<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>)
                .Map<MEither<L, Task<B>>, Either<L, Task<B>>, MTask<B>, Task<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Either&lt;L, Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Task&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Either&lt;L, Task&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA, L, A>(this Either<L, Task<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Either&lt;L, Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Task&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Either&lt;L, Task&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT<L, A>(this Either<L, Task<A>> ma) =>
            default(TransSyncAsync<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either&lt;L, Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Task<B>> BindT<L, A, B>(this Either<L, Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>)
                .Bind<MEither<L, Task<B>>, Either<L, Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Either&lt;L, Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;Either&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Either&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static Task<Either<L, B>> Traverse<L, A, B>(this Either<L, Task<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>)
                .Traverse<MTask<Either<L, B>>, Task<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Either&lt;L, Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;Either&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Either&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static Task<Either<L, B>> Traverse<L, A, B>(this Either<L, Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>)
                .TraverseAsync<MTask<Either<L, B>>, Task<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Either&lt;L, Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;Either&lt;L, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static Task<Either<L, A>> Sequence<L, A>(this Either<L, Task<A>> ma) =>
            default(TransSyncAsync<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>)
                .Sequence<MTask<Either<L, A>>, Task<Either<L, A>>, MEither<L, A>, Either<L, A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Task<B>> MapT<L, A, B>(this Either<L, Task<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>)
                .Map<MEither<L, Task<B>>, Either<L, Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Task<B>> MapT<L, A, B>(this Either<L, Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>)
                .MapAsync<MEither<L, Task<B>>, Either<L, Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, L, A>(this Either<L, Task<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, L, A>(this Either<L, Task<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, L, A>(this Either<L, Task<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, L, A>(this Either<L, Task<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT<L, A>(this Either<L, Task<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT<L, A>(this Either<L, Task<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Either&lt;L, Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT<L, A>(this Either<L, Task<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, Task<A>> FilterT<L, A>(this Either<L, Task<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>)
                .Bind<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).ReturnAsync(a.AsTask())
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, Task<A>> FilterT<L, A>(this Either<L, Task<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>)
                .BindAsync<MEither<L, Task<A>>, Either<L, Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTask<A>).ReturnAsync(a.AsTask())
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Task&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, Task<A>> PlusT<NUM, L, A>(this Either<L, Task<A>> x, Either<L, Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Task&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, Task<A>> SubtractT<NUM, L, A>(this Either<L, Task<A>> x, Either<L, Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Task&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Either<L, Task<A>> ProductT<NUM, L, A>(this Either<L, Task<A>> x, Either<L, Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Task&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Either<L, Task<A>> DivideT<NUM, L, A>(this Either<L, Task<A>> x, Either<L, Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Task&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Either<L, Task<A>> AppendT<SEMI, L, A>(this Either<L, Task<A>> x, Either<L, Task<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD, L, A>(this Either<L, Task<A>> x, Either<L, Task<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Task&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ, L, A>(this Either<L, Task<A>> x, Either<L, Task<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Either&lt;L, Task&lt;A&gt;&gt;`</param>
        /// <returns>`Either&lt;L, Task&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Either<L, Task<B>> ApplyT<L, A, B>(this Func<A, B> fab, Either<L, Task<A>> fa) =>
            default(ApplEither<L, Task<A>, Task<B>>).Apply(
                default(MEither<L, Func<Task<A>, Task<B>>>).Return(
                    (Task<A> a) => 
                        default(ApplTask< A, B>).Apply(
                            default(MTask< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Either&lt;L, Task&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Either&lt;L, Task&lt;A&gt;&gt;`</param>
        /// <returns>`Either&lt;L, Task&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Either<L, Task<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Either<L, Task<A>> fa, Either<L, Task<B>> fb) =>
            default(ApplEither<L, Task<A>, Task<B>, Task<C>>).Apply(
                default(MEither<L, Func<Task<A>, Func<Task<B>, Task<C>>>>).Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            default(ApplTask< A, B, C>).Apply(
                                default(MTask< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`EitherUnsafe&lt;L, Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, Task<C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, Task<A>> ma,
            Func<A, Task<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MEitherUnsafe<L, Task<B>>, EitherUnsafe<L, Task<B>>, MTask<B>, Task<B>, B, MEitherUnsafe<L, Task<C>>, EitherUnsafe<L, Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`EitherUnsafe&lt;L, Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, Task<C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, Task<A>> ma,
            Func<A, Task<Task<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MEitherUnsafe<L, Task<B>>, EitherUnsafe<L, Task<B>>, MTask<B>, Task<B>, B, MEitherUnsafe<L, Task<C>>, EitherUnsafe<L, Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`EitherUnsafe&lt;L, Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, Task<C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, Task<A>> ma,
            Func<A, Task<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MEitherUnsafe<L, Task<B>>, EitherUnsafe<L, Task<B>>, MTask<B>, Task<B>, B, MEitherUnsafe<L, Task<C>>, EitherUnsafe<L, Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`EitherUnsafe&lt;L, Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, Task<C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, Task<A>> ma,
            Func<A, Task<Task<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MEitherUnsafe<L, Task<B>>, EitherUnsafe<L, Task<B>>, MTask<B>, Task<B>, B, MEitherUnsafe<L, Task<C>>, EitherUnsafe<L, Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, Task<A>> Where<L, A>(this EitherUnsafe<L, Task<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>).Bind<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>(ma, 
                a => pred(a)
                    ? default(MTask<A>).ReturnAsync(a.AsTask())
                    : default(MTask<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, Task<A>> Where<L, A>(this EitherUnsafe<L, Task<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>).BindAsync<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTask<A>).ReturnAsync(a.AsTask())
                    : default(MTask<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Task<B>> Select<L, A, B>(this EitherUnsafe<L, Task<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>)
                .Map<MEitherUnsafe<L, Task<B>>, EitherUnsafe<L, Task<B>>, MTask<B>, Task<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherUnsafe&lt;L, Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Task&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherUnsafe&lt;L, Task&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA, L, A>(this EitherUnsafe<L, Task<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherUnsafe&lt;L, Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Task&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherUnsafe&lt;L, Task&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT<L, A>(this EitherUnsafe<L, Task<A>> ma) =>
            default(TransSyncAsync<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Task<B>> BindT<L, A, B>(this EitherUnsafe<L, Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>)
                .Bind<MEitherUnsafe<L, Task<B>>, EitherUnsafe<L, Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `EitherUnsafe&lt;L, Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;EitherUnsafe&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;EitherUnsafe&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static Task<EitherUnsafe<L, B>> Traverse<L, A, B>(this EitherUnsafe<L, Task<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>)
                .Traverse<MTask<EitherUnsafe<L, B>>, Task<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `EitherUnsafe&lt;L, Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;EitherUnsafe&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;EitherUnsafe&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static Task<EitherUnsafe<L, B>> Traverse<L, A, B>(this EitherUnsafe<L, Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>)
                .TraverseAsync<MTask<EitherUnsafe<L, B>>, Task<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `EitherUnsafe&lt;L, Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;EitherUnsafe&lt;L, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static Task<EitherUnsafe<L, A>> Sequence<L, A>(this EitherUnsafe<L, Task<A>> ma) =>
            default(TransSyncAsync<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>)
                .Sequence<MTask<EitherUnsafe<L, A>>, Task<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Task<B>> MapT<L, A, B>(this EitherUnsafe<L, Task<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>)
                .Map<MEitherUnsafe<L, Task<B>>, EitherUnsafe<L, Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Task<B>> MapT<L, A, B>(this EitherUnsafe<L, Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>)
                .MapAsync<MEitherUnsafe<L, Task<B>>, EitherUnsafe<L, Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, L, A>(this EitherUnsafe<L, Task<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, L, A>(this EitherUnsafe<L, Task<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, L, A>(this EitherUnsafe<L, Task<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, L, A>(this EitherUnsafe<L, Task<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT<L, A>(this EitherUnsafe<L, Task<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT<L, A>(this EitherUnsafe<L, Task<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherUnsafe&lt;L, Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT<L, A>(this EitherUnsafe<L, Task<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, Task<A>> FilterT<L, A>(this EitherUnsafe<L, Task<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>)
                .Bind<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).ReturnAsync(a.AsTask())
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, Task<A>> FilterT<L, A>(this EitherUnsafe<L, Task<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>)
                .BindAsync<MEitherUnsafe<L, Task<A>>, EitherUnsafe<L, Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTask<A>).ReturnAsync(a.AsTask())
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Task&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, Task<A>> PlusT<NUM, L, A>(this EitherUnsafe<L, Task<A>> x, EitherUnsafe<L, Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Task&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, Task<A>> SubtractT<NUM, L, A>(this EitherUnsafe<L, Task<A>> x, EitherUnsafe<L, Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Task&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherUnsafe<L, Task<A>> ProductT<NUM, L, A>(this EitherUnsafe<L, Task<A>> x, EitherUnsafe<L, Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Task&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherUnsafe<L, Task<A>> DivideT<NUM, L, A>(this EitherUnsafe<L, Task<A>> x, EitherUnsafe<L, Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Task&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherUnsafe<L, Task<A>> AppendT<SEMI, L, A>(this EitherUnsafe<L, Task<A>> x, EitherUnsafe<L, Task<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD, L, A>(this EitherUnsafe<L, Task<A>> x, EitherUnsafe<L, Task<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Task&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ, L, A>(this EitherUnsafe<L, Task<A>> x, EitherUnsafe<L, Task<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe&lt;L, Task&lt;A&gt;&gt;`</param>
        /// <returns>`EitherUnsafe&lt;L, Task&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherUnsafe<L, Task<B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherUnsafe<L, Task<A>> fa) =>
            default(ApplEitherUnsafe<L, Task<A>, Task<B>>).Apply(
                default(MEitherUnsafe<L, Func<Task<A>, Task<B>>>).Return(
                    (Task<A> a) => 
                        default(ApplTask< A, B>).Apply(
                            default(MTask< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe&lt;L, Task&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `EitherUnsafe&lt;L, Task&lt;A&gt;&gt;`</param>
        /// <returns>`EitherUnsafe&lt;L, Task&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherUnsafe<L, Task<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherUnsafe<L, Task<A>> fa, EitherUnsafe<L, Task<B>> fb) =>
            default(ApplEitherUnsafe<L, Task<A>, Task<B>, Task<C>>).Apply(
                default(MEitherUnsafe<L, Func<Task<A>, Func<Task<B>, Task<C>>>>).Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            default(ApplTask< A, B, C>).Apply(
                                default(MTask< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Try&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Try<Task<C>> SelectMany< A, B, C>(
            this Try<Task<A>> ma,
            Func<A, Task<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MTry<Task<B>>, Try<Task<B>>, MTask<B>, Task<B>, B, MTry<Task<C>>, Try<Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Try&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Try<Task<C>> SelectMany< A, B, C>(
            this Try<Task<A>> ma,
            Func<A, Task<Task<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MTry<Task<B>>, Try<Task<B>>, MTask<B>, Task<B>, B, MTry<Task<C>>, Try<Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Try&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Try<Task<C>> SelectMany< A, B, C>(
            this Try<Task<A>> ma,
            Func<A, Task<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MTry<Task<B>>, Try<Task<B>>, MTask<B>, Task<B>, B, MTry<Task<C>>, Try<Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Try&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Try<Task<C>> SelectMany< A, B, C>(
            this Try<Task<A>> ma,
            Func<A, Task<Task<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MTry<Task<B>>, Try<Task<B>>, MTask<B>, Task<B>, B, MTry<Task<C>>, Try<Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<Task<A>> Where< A>(this Try<Task<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>).Bind<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                a => pred(a)
                    ? default(MTask<A>).ReturnAsync(a.AsTask())
                    : default(MTask<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<Task<A>> Where< A>(this Try<Task<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>).BindAsync<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTask<A>).ReturnAsync(a.AsTask())
                    : default(MTask<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Task<B>> Select< A, B>(this Try<Task<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>)
                .Map<MTry<Task<B>>, Try<Task<B>>, MTask<B>, Task<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Try&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Task&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Try&lt;Task&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this Try<Task<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Try&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Task&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Try&lt;Task&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this Try<Task<A>> ma) =>
            default(TransSyncAsync<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Task<B>> BindT< A, B>(this Try<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>)
                .Bind<MTry<Task<B>>, Try<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Try&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;Try&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Try&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Task<Try<B>> Traverse< A, B>(this Try<Task<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>)
                .Traverse<MTask<Try<B>>, Task<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Try&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;Try&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Try&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Task<Try<B>> Traverse< A, B>(this Try<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>)
                .TraverseAsync<MTask<Try<B>>, Task<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Try&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;Try&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<Try<A>> Sequence< A>(this Try<Task<A>> ma) =>
            default(TransSyncAsync<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>)
                .Sequence<MTask<Try<A>>, Task<Try<A>>, MTry<A>, Try<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Task<B>> MapT< A, B>(this Try<Task<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>)
                .Map<MTry<Task<B>>, Try<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Task<B>> MapT< A, B>(this Try<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>)
                .MapAsync<MTry<Task<B>>, Try<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Try<Task<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Try<Task<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Try<Task<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Try<Task<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this Try<Task<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this Try<Task<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Try&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this Try<Task<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<Task<A>> FilterT< A>(this Try<Task<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>)
                .Bind<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).ReturnAsync(a.AsTask())
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<Task<A>> FilterT< A>(this Try<Task<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>)
                .BindAsync<MTry<Task<A>>, Try<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTask<A>).ReturnAsync(a.AsTask())
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Task&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Try<Task<A>> PlusT<NUM,  A>(this Try<Task<A>> x, Try<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Task&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Try<Task<A>> SubtractT<NUM,  A>(this Try<Task<A>> x, Try<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Task&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Try<Task<A>> ProductT<NUM,  A>(this Try<Task<A>> x, Try<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Task&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Try<Task<A>> DivideT<NUM,  A>(this Try<Task<A>> x, Try<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Task&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Try<Task<A>> AppendT<SEMI,  A>(this Try<Task<A>> x, Try<Task<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this Try<Task<A>> x, Try<Task<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Task&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this Try<Task<A>> x, Try<Task<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Try&lt;Task&lt;A&gt;&gt;`</param>
        /// <returns>`Try&lt;Task&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Try<Task<B>> ApplyT< A, B>(this Func<A, B> fab, Try<Task<A>> fa) =>
            default(ApplTry< Task<A>, Task<B>>).Apply(
                default(MTry< Func<Task<A>, Task<B>>>).Return(
                    (Task<A> a) => 
                        default(ApplTask< A, B>).Apply(
                            default(MTask< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Try&lt;Task&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Try&lt;Task&lt;A&gt;&gt;`</param>
        /// <returns>`Try&lt;Task&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Try<Task<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Try<Task<A>> fa, Try<Task<B>> fb) =>
            default(ApplTry< Task<A>, Task<B>, Task<C>>).Apply(
                default(MTry< Func<Task<A>, Func<Task<B>, Task<C>>>>).Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            default(ApplTask< A, B, C>).Apply(
                                default(MTask< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOption&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<Task<C>> SelectMany< A, B, C>(
            this TryOption<Task<A>> ma,
            Func<A, Task<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MTryOption<Task<B>>, TryOption<Task<B>>, MTask<B>, Task<B>, B, MTryOption<Task<C>>, TryOption<Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOption&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<Task<C>> SelectMany< A, B, C>(
            this TryOption<Task<A>> ma,
            Func<A, Task<Task<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MTryOption<Task<B>>, TryOption<Task<B>>, MTask<B>, Task<B>, B, MTryOption<Task<C>>, TryOption<Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOption&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<Task<C>> SelectMany< A, B, C>(
            this TryOption<Task<A>> ma,
            Func<A, Task<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MTryOption<Task<B>>, TryOption<Task<B>>, MTask<B>, Task<B>, B, MTryOption<Task<C>>, TryOption<Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOption&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<Task<C>> SelectMany< A, B, C>(
            this TryOption<Task<A>> ma,
            Func<A, Task<Task<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MTryOption<Task<B>>, TryOption<Task<B>>, MTask<B>, Task<B>, B, MTryOption<Task<C>>, TryOption<Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<Task<A>> Where< A>(this TryOption<Task<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>).Bind<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                a => pred(a)
                    ? default(MTask<A>).ReturnAsync(a.AsTask())
                    : default(MTask<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<Task<A>> Where< A>(this TryOption<Task<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>).BindAsync<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTask<A>).ReturnAsync(a.AsTask())
                    : default(MTask<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Task<B>> Select< A, B>(this TryOption<Task<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>)
                .Map<MTryOption<Task<B>>, TryOption<Task<B>>, MTask<B>, Task<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOption&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Task&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOption&lt;Task&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this TryOption<Task<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOption&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Task&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOption&lt;Task&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this TryOption<Task<A>> ma) =>
            default(TransSyncAsync<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Task<B>> BindT< A, B>(this TryOption<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>)
                .Bind<MTryOption<Task<B>>, TryOption<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOption&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;TryOption&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;TryOption&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Task<TryOption<B>> Traverse< A, B>(this TryOption<Task<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>)
                .Traverse<MTask<TryOption<B>>, Task<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOption&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;TryOption&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;TryOption&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Task<TryOption<B>> Traverse< A, B>(this TryOption<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>)
                .TraverseAsync<MTask<TryOption<B>>, Task<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOption&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;TryOption&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<TryOption<A>> Sequence< A>(this TryOption<Task<A>> ma) =>
            default(TransSyncAsync<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>)
                .Sequence<MTask<TryOption<A>>, Task<TryOption<A>>, MTryOption<A>, TryOption<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Task<B>> MapT< A, B>(this TryOption<Task<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>)
                .Map<MTryOption<Task<B>>, TryOption<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Task<B>> MapT< A, B>(this TryOption<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>)
                .MapAsync<MTryOption<Task<B>>, TryOption<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryOption<Task<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryOption<Task<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryOption<Task<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryOption<Task<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this TryOption<Task<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this TryOption<Task<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOption&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this TryOption<Task<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<Task<A>> FilterT< A>(this TryOption<Task<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>)
                .Bind<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).ReturnAsync(a.AsTask())
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<Task<A>> FilterT< A>(this TryOption<Task<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>)
                .BindAsync<MTryOption<Task<A>>, TryOption<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTask<A>).ReturnAsync(a.AsTask())
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Task&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<Task<A>> PlusT<NUM,  A>(this TryOption<Task<A>> x, TryOption<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Task&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<Task<A>> SubtractT<NUM,  A>(this TryOption<Task<A>> x, TryOption<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Task&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOption<Task<A>> ProductT<NUM,  A>(this TryOption<Task<A>> x, TryOption<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Task&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOption<Task<A>> DivideT<NUM,  A>(this TryOption<Task<A>> x, TryOption<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Task&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOption<Task<A>> AppendT<SEMI,  A>(this TryOption<Task<A>> x, TryOption<Task<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this TryOption<Task<A>> x, TryOption<Task<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Task&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this TryOption<Task<A>> x, TryOption<Task<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOption&lt;Task&lt;A&gt;&gt;`</param>
        /// <returns>`TryOption&lt;Task&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOption<Task<B>> ApplyT< A, B>(this Func<A, B> fab, TryOption<Task<A>> fa) =>
            default(ApplTryOption< Task<A>, Task<B>>).Apply(
                default(MTryOption< Func<Task<A>, Task<B>>>).Return(
                    (Task<A> a) => 
                        default(ApplTask< A, B>).Apply(
                            default(MTask< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOption&lt;Task&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryOption&lt;Task&lt;A&gt;&gt;`</param>
        /// <returns>`TryOption&lt;Task&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOption<Task<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOption<Task<A>> fa, TryOption<Task<B>> fb) =>
            default(ApplTryOption< Task<A>, Task<B>, Task<C>>).Apply(
                default(MTryOption< Func<Task<A>, Func<Task<B>, Task<C>>>>).Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            default(ApplTask< A, B, C>).Apply(
                                default(MTask< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`IEnumerable&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<Task<C>> SelectMany< A, B, C>(
            this IEnumerable<Task<A>> ma,
            Func<A, Task<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MEnumerable<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MEnumerable<Task<B>>, IEnumerable<Task<B>>, MTask<B>, Task<B>, B, MEnumerable<Task<C>>, IEnumerable<Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`IEnumerable&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<Task<C>> SelectMany< A, B, C>(
            this IEnumerable<Task<A>> ma,
            Func<A, Task<Task<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MEnumerable<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MEnumerable<Task<B>>, IEnumerable<Task<B>>, MTask<B>, Task<B>, B, MEnumerable<Task<C>>, IEnumerable<Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`IEnumerable&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<Task<C>> SelectMany< A, B, C>(
            this IEnumerable<Task<A>> ma,
            Func<A, Task<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MEnumerable<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MEnumerable<Task<B>>, IEnumerable<Task<B>>, MTask<B>, Task<B>, B, MEnumerable<Task<C>>, IEnumerable<Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`IEnumerable&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<Task<C>> SelectMany< A, B, C>(
            this IEnumerable<Task<A>> ma,
            Func<A, Task<Task<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MEnumerable<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MEnumerable<Task<B>>, IEnumerable<Task<B>>, MTask<B>, Task<B>, B, MEnumerable<Task<C>>, IEnumerable<Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<Task<A>> Where< A>(this IEnumerable<Task<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MEnumerable<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>).Bind<MEnumerable<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                a => pred(a)
                    ? default(MTask<A>).ReturnAsync(a.AsTask())
                    : default(MTask<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<Task<A>> Where< A>(this IEnumerable<Task<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MEnumerable<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>).BindAsync<MEnumerable<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTask<A>).ReturnAsync(a.AsTask())
                    : default(MTask<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Task<B>> Select< A, B>(this IEnumerable<Task<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MEnumerable<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>)
                .Map<MEnumerable<Task<B>>, IEnumerable<Task<B>>, MTask<B>, Task<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `IEnumerable&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Task&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `IEnumerable&lt;Task&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this IEnumerable<Task<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MEnumerable<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `IEnumerable&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Task&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `IEnumerable&lt;Task&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this IEnumerable<Task<A>> ma) =>
            default(TransSyncAsync<MEnumerable<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Task<B>> BindT< A, B>(this IEnumerable<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MEnumerable<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>)
                .Bind<MEnumerable<Task<B>>, IEnumerable<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `IEnumerable&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;IEnumerable&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;IEnumerable&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Task<IEnumerable<B>> Traverse< A, B>(this IEnumerable<Task<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MEnumerable<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>)
                .Traverse<MTask<IEnumerable<B>>, Task<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `IEnumerable&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;IEnumerable&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;IEnumerable&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Task<IEnumerable<B>> Traverse< A, B>(this IEnumerable<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MEnumerable<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>)
                .TraverseAsync<MTask<IEnumerable<B>>, Task<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `IEnumerable&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;IEnumerable&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<IEnumerable<A>> Sequence< A>(this IEnumerable<Task<A>> ma) =>
            default(TransSyncAsync<MEnumerable<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>)
                .Sequence<MTask<IEnumerable<A>>, Task<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Task<B>> MapT< A, B>(this IEnumerable<Task<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MEnumerable<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>)
                .Map<MEnumerable<Task<B>>, IEnumerable<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Task<B>> MapT< A, B>(this IEnumerable<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MEnumerable<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>)
                .MapAsync<MEnumerable<Task<B>>, IEnumerable<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this IEnumerable<Task<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MEnumerable<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this IEnumerable<Task<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MEnumerable<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this IEnumerable<Task<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MEnumerable<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this IEnumerable<Task<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MEnumerable<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this IEnumerable<Task<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MEnumerable<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this IEnumerable<Task<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MEnumerable<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `IEnumerable&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this IEnumerable<Task<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MEnumerable<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<Task<A>> FilterT< A>(this IEnumerable<Task<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MEnumerable<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>)
                .Bind<MEnumerable<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).ReturnAsync(a.AsTask())
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<Task<A>> FilterT< A>(this IEnumerable<Task<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MEnumerable<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>)
                .BindAsync<MEnumerable<Task<A>>, IEnumerable<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTask<A>).ReturnAsync(a.AsTask())
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Task&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<Task<A>> PlusT<NUM,  A>(this IEnumerable<Task<A>> x, IEnumerable<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Task&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<Task<A>> SubtractT<NUM,  A>(this IEnumerable<Task<A>> x, IEnumerable<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Task&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static IEnumerable<Task<A>> ProductT<NUM,  A>(this IEnumerable<Task<A>> x, IEnumerable<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Task&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static IEnumerable<Task<A>> DivideT<NUM,  A>(this IEnumerable<Task<A>> x, IEnumerable<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Task&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static IEnumerable<Task<A>> AppendT<SEMI,  A>(this IEnumerable<Task<A>> x, IEnumerable<Task<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this IEnumerable<Task<A>> x, IEnumerable<Task<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Task&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this IEnumerable<Task<A>> x, IEnumerable<Task<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `IEnumerable&lt;Task&lt;A&gt;&gt;`</param>
        /// <returns>`IEnumerable&lt;Task&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static IEnumerable<Task<B>> ApplyT< A, B>(this Func<A, B> fab, IEnumerable<Task<A>> fa) =>
            default(ApplEnumerable< Task<A>, Task<B>>).Apply(
                default(MEnumerable< Func<Task<A>, Task<B>>>).Return(
                    (Task<A> a) => 
                        default(ApplTask< A, B>).Apply(
                            default(MTask< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `IEnumerable&lt;Task&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `IEnumerable&lt;Task&lt;A&gt;&gt;`</param>
        /// <returns>`IEnumerable&lt;Task&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static IEnumerable<Task<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, IEnumerable<Task<A>> fa, IEnumerable<Task<B>> fb) =>
            default(ApplEnumerable< Task<A>, Task<B>, Task<C>>).Apply(
                default(MEnumerable< Func<Task<A>, Func<Task<B>, Task<C>>>>).Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            default(ApplTask< A, B, C>).Apply(
                                default(MTask< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Seq&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Seq<Task<C>> SelectMany< A, B, C>(
            this Seq<Task<A>> ma,
            Func<A, Task<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MSeq<Task<A>>, Seq<Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MSeq<Task<B>>, Seq<Task<B>>, MTask<B>, Task<B>, B, MSeq<Task<C>>, Seq<Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Seq&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Seq<Task<C>> SelectMany< A, B, C>(
            this Seq<Task<A>> ma,
            Func<A, Task<Task<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MSeq<Task<A>>, Seq<Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MSeq<Task<B>>, Seq<Task<B>>, MTask<B>, Task<B>, B, MSeq<Task<C>>, Seq<Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Seq&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Seq<Task<C>> SelectMany< A, B, C>(
            this Seq<Task<A>> ma,
            Func<A, Task<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MSeq<Task<A>>, Seq<Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MSeq<Task<B>>, Seq<Task<B>>, MTask<B>, Task<B>, B, MSeq<Task<C>>, Seq<Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Seq&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Seq<Task<C>> SelectMany< A, B, C>(
            this Seq<Task<A>> ma,
            Func<A, Task<Task<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MSeq<Task<A>>, Seq<Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MSeq<Task<B>>, Seq<Task<B>>, MTask<B>, Task<B>, B, MSeq<Task<C>>, Seq<Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<Task<A>> Where< A>(this Seq<Task<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MSeq<Task<A>>, Seq<Task<A>>, MTask<A>, Task<A>, A>).Bind<MSeq<Task<A>>, Seq<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                a => pred(a)
                    ? default(MTask<A>).ReturnAsync(a.AsTask())
                    : default(MTask<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<Task<A>> Where< A>(this Seq<Task<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MSeq<Task<A>>, Seq<Task<A>>, MTask<A>, Task<A>, A>).BindAsync<MSeq<Task<A>>, Seq<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTask<A>).ReturnAsync(a.AsTask())
                    : default(MTask<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<Task<B>> Select< A, B>(this Seq<Task<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MSeq<Task<A>>, Seq<Task<A>>, MTask<A>, Task<A>, A>)
                .Map<MSeq<Task<B>>, Seq<Task<B>>, MTask<B>, Task<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Seq&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Task&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Seq&lt;Task&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this Seq<Task<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MSeq<Task<A>>, Seq<Task<A>>, MTask<A>, Task<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Seq&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Task&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Seq&lt;Task&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this Seq<Task<A>> ma) =>
            default(TransSyncAsync<MSeq<Task<A>>, Seq<Task<A>>, MTask<A>, Task<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Seq&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<Task<B>> BindT< A, B>(this Seq<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MSeq<Task<A>>, Seq<Task<A>>, MTask<A>, Task<A>, A>)
                .Bind<MSeq<Task<B>>, Seq<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Seq&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;Seq&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Seq&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Task<Seq<B>> Traverse< A, B>(this Seq<Task<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MSeq<Task<A>>, Seq<Task<A>>, MTask<A>, Task<A>, A>)
                .Traverse<MTask<Seq<B>>, Task<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Seq&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;Seq&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Seq&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Task<Seq<B>> Traverse< A, B>(this Seq<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MSeq<Task<A>>, Seq<Task<A>>, MTask<A>, Task<A>, A>)
                .TraverseAsync<MTask<Seq<B>>, Task<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Seq&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;Seq&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<Seq<A>> Sequence< A>(this Seq<Task<A>> ma) =>
            default(TransSyncAsync<MSeq<Task<A>>, Seq<Task<A>>, MTask<A>, Task<A>, A>)
                .Sequence<MTask<Seq<A>>, Task<Seq<A>>, MSeq<A>, Seq<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<Task<B>> MapT< A, B>(this Seq<Task<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MSeq<Task<A>>, Seq<Task<A>>, MTask<A>, Task<A>, A>)
                .Map<MSeq<Task<B>>, Seq<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<Task<B>> MapT< A, B>(this Seq<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MSeq<Task<A>>, Seq<Task<A>>, MTask<A>, Task<A>, A>)
                .MapAsync<MSeq<Task<B>>, Seq<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Seq<Task<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MSeq<Task<A>>, Seq<Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Seq<Task<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MSeq<Task<A>>, Seq<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Seq<Task<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MSeq<Task<A>>, Seq<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Seq<Task<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MSeq<Task<A>>, Seq<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this Seq<Task<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MSeq<Task<A>>, Seq<Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this Seq<Task<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MSeq<Task<A>>, Seq<Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Seq&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this Seq<Task<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MSeq<Task<A>>, Seq<Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<Task<A>> FilterT< A>(this Seq<Task<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MSeq<Task<A>>, Seq<Task<A>>, MTask<A>, Task<A>, A>)
                .Bind<MSeq<Task<A>>, Seq<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).ReturnAsync(a.AsTask())
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<Task<A>> FilterT< A>(this Seq<Task<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MSeq<Task<A>>, Seq<Task<A>>, MTask<A>, Task<A>, A>)
                .BindAsync<MSeq<Task<A>>, Seq<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTask<A>).ReturnAsync(a.AsTask())
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Task&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Seq<Task<A>> PlusT<NUM,  A>(this Seq<Task<A>> x, Seq<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Task&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Seq<Task<A>> SubtractT<NUM,  A>(this Seq<Task<A>> x, Seq<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Task&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Seq<Task<A>> ProductT<NUM,  A>(this Seq<Task<A>> x, Seq<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Task&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Seq<Task<A>> DivideT<NUM,  A>(this Seq<Task<A>> x, Seq<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Task&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Seq<Task<A>> AppendT<SEMI,  A>(this Seq<Task<A>> x, Seq<Task<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this Seq<Task<A>> x, Seq<Task<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Task&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this Seq<Task<A>> x, Seq<Task<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Seq&lt;Task&lt;A&gt;&gt;`</param>
        /// <returns>`Seq&lt;Task&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Seq<Task<B>> ApplyT< A, B>(this Func<A, B> fab, Seq<Task<A>> fa) =>
            default(ApplSeq< Task<A>, Task<B>>).Apply(
                default(MSeq< Func<Task<A>, Task<B>>>).Return(
                    (Task<A> a) => 
                        default(ApplTask< A, B>).Apply(
                            default(MTask< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Seq&lt;Task&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Seq&lt;Task&lt;A&gt;&gt;`</param>
        /// <returns>`Seq&lt;Task&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Seq<Task<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Seq<Task<A>> fa, Seq<Task<B>> fb) =>
            default(ApplSeq< Task<A>, Task<B>, Task<C>>).Apply(
                default(MSeq< Func<Task<A>, Func<Task<B>, Task<C>>>>).Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            default(ApplTask< A, B, C>).Apply(
                                default(MTask< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Set&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Set<Task<C>> SelectMany< A, B, C>(
            this Set<Task<A>> ma,
            Func<A, Task<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MSet<Task<B>>, Set<Task<B>>, MTask<B>, Task<B>, B, MSet<Task<C>>, Set<Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Set&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Set<Task<C>> SelectMany< A, B, C>(
            this Set<Task<A>> ma,
            Func<A, Task<Task<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MSet<Task<B>>, Set<Task<B>>, MTask<B>, Task<B>, B, MSet<Task<C>>, Set<Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Set&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Set<Task<C>> SelectMany< A, B, C>(
            this Set<Task<A>> ma,
            Func<A, Task<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MSet<Task<B>>, Set<Task<B>>, MTask<B>, Task<B>, B, MSet<Task<C>>, Set<Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Set&lt;Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Set<Task<C>> SelectMany< A, B, C>(
            this Set<Task<A>> ma,
            Func<A, Task<Task<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MSet<Task<B>>, Set<Task<B>>, MTask<B>, Task<B>, B, MSet<Task<C>>, Set<Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<Task<A>> Where< A>(this Set<Task<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>).Bind<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                a => pred(a)
                    ? default(MTask<A>).ReturnAsync(a.AsTask())
                    : default(MTask<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<Task<A>> Where< A>(this Set<Task<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>).BindAsync<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTask<A>).ReturnAsync(a.AsTask())
                    : default(MTask<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Task<B>> Select< A, B>(this Set<Task<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>)
                .Map<MSet<Task<B>>, Set<Task<B>>, MTask<B>, Task<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Set&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Task&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Set&lt;Task&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this Set<Task<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Set&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Task&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Set&lt;Task&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this Set<Task<A>> ma) =>
            default(TransSyncAsync<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Task<B>> BindT< A, B>(this Set<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>)
                .Bind<MSet<Task<B>>, Set<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Set&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;Set&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Set&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Task<Set<B>> Traverse< A, B>(this Set<Task<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>)
                .Traverse<MTask<Set<B>>, Task<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Set&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;Set&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Set&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Task<Set<B>> Traverse< A, B>(this Set<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>)
                .TraverseAsync<MTask<Set<B>>, Task<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Set&lt;Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;Set&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<Set<A>> Sequence< A>(this Set<Task<A>> ma) =>
            default(TransSyncAsync<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>)
                .Sequence<MTask<Set<A>>, Task<Set<A>>, MSet<A>, Set<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Task<B>> MapT< A, B>(this Set<Task<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>)
                .Map<MSet<Task<B>>, Set<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Task<B>> MapT< A, B>(this Set<Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>)
                .MapAsync<MSet<Task<B>>, Set<Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Set<Task<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Set<Task<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Set<Task<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Set<Task<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this Set<Task<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this Set<Task<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Set&lt;Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this Set<Task<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<Task<A>> FilterT< A>(this Set<Task<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>)
                .Bind<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).ReturnAsync(a.AsTask())
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<Task<A>> FilterT< A>(this Set<Task<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>)
                .BindAsync<MSet<Task<A>>, Set<Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTask<A>).ReturnAsync(a.AsTask())
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Task&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Set<Task<A>> PlusT<NUM,  A>(this Set<Task<A>> x, Set<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Task&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Set<Task<A>> SubtractT<NUM,  A>(this Set<Task<A>> x, Set<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Task&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Set<Task<A>> ProductT<NUM,  A>(this Set<Task<A>> x, Set<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Task&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Set<Task<A>> DivideT<NUM,  A>(this Set<Task<A>> x, Set<Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Task&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Set<Task<A>> AppendT<SEMI,  A>(this Set<Task<A>> x, Set<Task<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this Set<Task<A>> x, Set<Task<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Task&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this Set<Task<A>> x, Set<Task<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Set&lt;Task&lt;A&gt;&gt;`</param>
        /// <returns>`Set&lt;Task&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Set<Task<B>> ApplyT< A, B>(this Func<A, B> fab, Set<Task<A>> fa) =>
            default(ApplSet< Task<A>, Task<B>>).Apply(
                default(MSet< Func<Task<A>, Task<B>>>).Return(
                    (Task<A> a) => 
                        default(ApplTask< A, B>).Apply(
                            default(MTask< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Set&lt;Task&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Set&lt;Task&lt;A&gt;&gt;`</param>
        /// <returns>`Set&lt;Task&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Set<Task<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Set<Task<A>> fa, Set<Task<B>> fb) =>
            default(ApplSet< Task<A>, Task<B>, Task<C>>).Apply(
                default(MSet< Func<Task<A>, Func<Task<B>, Task<C>>>>).Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            default(ApplTask< A, B, C>).Apply(
                                default(MTask< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Validation&lt;FAIL, Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Validation<FAIL, Task<C>> SelectMany<FAIL, A, B, C>(
            this Validation<FAIL, Task<A>> ma,
            Func<A, Task<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MValidation<FAIL, Task<A>>, Validation<FAIL, Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MValidation<FAIL, Task<B>>, Validation<FAIL, Task<B>>, MTask<B>, Task<B>, B, MValidation<FAIL, Task<C>>, Validation<FAIL, Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Validation&lt;FAIL, Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Validation<FAIL, Task<C>> SelectMany<FAIL, A, B, C>(
            this Validation<FAIL, Task<A>> ma,
            Func<A, Task<Task<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MValidation<FAIL, Task<A>>, Validation<FAIL, Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MValidation<FAIL, Task<B>>, Validation<FAIL, Task<B>>, MTask<B>, Task<B>, B, MValidation<FAIL, Task<C>>, Validation<FAIL, Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Validation&lt;FAIL, Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Validation<FAIL, Task<C>> SelectMany<FAIL, A, B, C>(
            this Validation<FAIL, Task<A>> ma,
            Func<A, Task<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MValidation<FAIL, Task<A>>, Validation<FAIL, Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MValidation<FAIL, Task<B>>, Validation<FAIL, Task<B>>, MTask<B>, Task<B>, B, MValidation<FAIL, Task<C>>, Validation<FAIL, Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Validation&lt;FAIL, Task&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Validation<FAIL, Task<C>> SelectMany<FAIL, A, B, C>(
            this Validation<FAIL, Task<A>> ma,
            Func<A, Task<Task<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MValidation<FAIL, Task<A>>, Validation<FAIL, Task<A>>, MTask<A>, Task<A>, A>)
                .SelectManyAsync<MValidation<FAIL, Task<B>>, Validation<FAIL, Task<B>>, MTask<B>, Task<B>, B, MValidation<FAIL, Task<C>>, Validation<FAIL, Task<C>>, MTask<C>, Task<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, Task<A>> Where<FAIL, A>(this Validation<FAIL, Task<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MValidation<FAIL, Task<A>>, Validation<FAIL, Task<A>>, MTask<A>, Task<A>, A>).Bind<MValidation<FAIL, Task<A>>, Validation<FAIL, Task<A>>, MTask<A>, Task<A>, A>(ma, 
                a => pred(a)
                    ? default(MTask<A>).ReturnAsync(a.AsTask())
                    : default(MTask<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, Task<A>> Where<FAIL, A>(this Validation<FAIL, Task<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MValidation<FAIL, Task<A>>, Validation<FAIL, Task<A>>, MTask<A>, Task<A>, A>).BindAsync<MValidation<FAIL, Task<A>>, Validation<FAIL, Task<A>>, MTask<A>, Task<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTask<A>).ReturnAsync(a.AsTask())
                    : default(MTask<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, Task<B>> Select<FAIL, A, B>(this Validation<FAIL, Task<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MValidation<FAIL, Task<A>>, Validation<FAIL, Task<A>>, MTask<A>, Task<A>, A>)
                .Map<MValidation<FAIL, Task<B>>, Validation<FAIL, Task<B>>, MTask<B>, Task<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Validation&lt;FAIL, Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Task&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Validation&lt;FAIL, Task&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA, FAIL, A>(this Validation<FAIL, Task<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MValidation<FAIL, Task<A>>, Validation<FAIL, Task<A>>, MTask<A>, Task<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Validation&lt;FAIL, Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Task&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Validation&lt;FAIL, Task&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT<FAIL, A>(this Validation<FAIL, Task<A>> ma) =>
            default(TransSyncAsync<MValidation<FAIL, Task<A>>, Validation<FAIL, Task<A>>, MTask<A>, Task<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Validation&lt;FAIL, Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, Task<B>> BindT<FAIL, A, B>(this Validation<FAIL, Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MValidation<FAIL, Task<A>>, Validation<FAIL, Task<A>>, MTask<A>, Task<A>, A>)
                .Bind<MValidation<FAIL, Task<B>>, Validation<FAIL, Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Validation&lt;FAIL, Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;Validation&lt;FAIL, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Validation&lt;FAIL, B&gt;&gt;`</returns>
        [Pure]
        public static Task<Validation<FAIL, B>> Traverse<FAIL, A, B>(this Validation<FAIL, Task<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MValidation<FAIL, Task<A>>, Validation<FAIL, Task<A>>, MTask<A>, Task<A>, A>)
                .Traverse<MTask<Validation<FAIL, B>>, Task<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Validation&lt;FAIL, Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;Validation&lt;FAIL, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Validation&lt;FAIL, B&gt;&gt;`</returns>
        [Pure]
        public static Task<Validation<FAIL, B>> Traverse<FAIL, A, B>(this Validation<FAIL, Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MValidation<FAIL, Task<A>>, Validation<FAIL, Task<A>>, MTask<A>, Task<A>, A>)
                .TraverseAsync<MTask<Validation<FAIL, B>>, Task<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Validation&lt;FAIL, Task&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Task&lt;Validation&lt;FAIL, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<FAIL, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static Task<Validation<FAIL, A>> Sequence<FAIL, A>(this Validation<FAIL, Task<A>> ma) =>
            default(TransSyncAsync<MValidation<FAIL, Task<A>>, Validation<FAIL, Task<A>>, MTask<A>, Task<A>, A>)
                .Sequence<MTask<Validation<FAIL, A>>, Task<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, Task<B>> MapT<FAIL, A, B>(this Validation<FAIL, Task<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MValidation<FAIL, Task<A>>, Validation<FAIL, Task<A>>, MTask<A>, Task<A>, A>)
                .Map<MValidation<FAIL, Task<B>>, Validation<FAIL, Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, Task&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, Task<B>> MapT<FAIL, A, B>(this Validation<FAIL, Task<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MValidation<FAIL, Task<A>>, Validation<FAIL, Task<A>>, MTask<A>, Task<A>, A>)
                .MapAsync<MValidation<FAIL, Task<B>>, Validation<FAIL, Task<B>>, MTask<B>, Task<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, FAIL, A>(this Validation<FAIL, Task<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MValidation<FAIL, Task<A>>, Validation<FAIL, Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, FAIL, A>(this Validation<FAIL, Task<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MValidation<FAIL, Task<A>>, Validation<FAIL, Task<A>>, MTask<A>, Task<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, FAIL, A>(this Validation<FAIL, Task<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MValidation<FAIL, Task<A>>, Validation<FAIL, Task<A>>, MTask<A>, Task<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, FAIL, A>(this Validation<FAIL, Task<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MValidation<FAIL, Task<A>>, Validation<FAIL, Task<A>>, MTask<A>, Task<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT<FAIL, A>(this Validation<FAIL, Task<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MValidation<FAIL, Task<A>>, Validation<FAIL, Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT<FAIL, A>(this Validation<FAIL, Task<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MValidation<FAIL, Task<A>>, Validation<FAIL, Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Validation&lt;FAIL, Task&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT<FAIL, A>(this Validation<FAIL, Task<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MValidation<FAIL, Task<A>>, Validation<FAIL, Task<A>>, MTask<A>, Task<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, Task<A>> FilterT<FAIL, A>(this Validation<FAIL, Task<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MValidation<FAIL, Task<A>>, Validation<FAIL, Task<A>>, MTask<A>, Task<A>, A>)
                .Bind<MValidation<FAIL, Task<A>>, Validation<FAIL, Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTask<A>).ReturnAsync(a.AsTask())
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Task&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, Task&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, Task<A>> FilterT<FAIL, A>(this Validation<FAIL, Task<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MValidation<FAIL, Task<A>>, Validation<FAIL, Task<A>>, MTask<A>, Task<A>, A>)
                .BindAsync<MValidation<FAIL, Task<A>>, Validation<FAIL, Task<A>>, MTask<A>, Task<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTask<A>).ReturnAsync(a.AsTask())
                        : default(MTask<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Task&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Validation<FAIL, Task<A>> PlusT<NUM, FAIL, A>(this Validation<FAIL, Task<A>> x, Validation<FAIL, Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Task&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Validation<FAIL, Task<A>> SubtractT<NUM, FAIL, A>(this Validation<FAIL, Task<A>> x, Validation<FAIL, Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Task&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Validation<FAIL, Task<A>> ProductT<NUM, FAIL, A>(this Validation<FAIL, Task<A>> x, Validation<FAIL, Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Task&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Validation<FAIL, Task<A>> DivideT<NUM, FAIL, A>(this Validation<FAIL, Task<A>> x, Validation<FAIL, Task<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Task&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Validation<FAIL, Task<A>> AppendT<SEMI, FAIL, A>(this Validation<FAIL, Task<A>> x, Validation<FAIL, Task<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD, FAIL, A>(this Validation<FAIL, Task<A>> x, Validation<FAIL, Task<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Task&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ, FAIL, A>(this Validation<FAIL, Task<A>> x, Validation<FAIL, Task<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Validation&lt;FAIL, Task&lt;A&gt;&gt;`</param>
        /// <returns>`Validation&lt;FAIL, Task&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Validation<FAIL, Task<B>> ApplyT<FAIL, A, B>(this Func<A, B> fab, Validation<FAIL, Task<A>> fa) =>
            default(ApplValidation<FAIL, Task<A>, Task<B>>).Apply(
                default(MValidation<FAIL, Func<Task<A>, Task<B>>>).Return(
                    (Task<A> a) => 
                        default(ApplTask< A, B>).Apply(
                            default(MTask< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Validation&lt;FAIL, Task&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Validation&lt;FAIL, Task&lt;A&gt;&gt;`</param>
        /// <returns>`Validation&lt;FAIL, Task&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Validation<FAIL, Task<C>> ApplyT<FAIL, A, B, C>(this Func<A, B, C> fabc, Validation<FAIL, Task<A>> fa, Validation<FAIL, Task<B>> fb) =>
            default(ApplValidation<FAIL, Task<A>, Task<B>, Task<C>>).Apply(
                default(MValidation<FAIL, Func<Task<A>, Func<Task<B>, Task<C>>>>).Return(
                    (Task<A> a) =>
                        (Task<B> b) =>
                            default(ApplTask< A, B, C>).Apply(
                                default(MTask< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

    }
    /// <summary>
    /// Async monad transformer for TryAsync, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class TryAsyncT_SyncAsync_Extensions
    {
        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Arr&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<TryAsync<C>> SelectMany< A, B, C>(
            this Arr<TryAsync<A>> ma,
            Func<A, TryAsync<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MArr<TryAsync<B>>, Arr<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MArr<TryAsync<C>>, Arr<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Arr&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<TryAsync<C>> SelectMany< A, B, C>(
            this Arr<TryAsync<A>> ma,
            Func<A, Task<TryAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MArr<TryAsync<B>>, Arr<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MArr<TryAsync<C>>, Arr<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Arr&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<TryAsync<C>> SelectMany< A, B, C>(
            this Arr<TryAsync<A>> ma,
            Func<A, TryAsync<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MArr<TryAsync<B>>, Arr<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MArr<TryAsync<C>>, Arr<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Arr&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<TryAsync<C>> SelectMany< A, B, C>(
            this Arr<TryAsync<A>> ma,
            Func<A, Task<TryAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MArr<TryAsync<B>>, Arr<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MArr<TryAsync<C>>, Arr<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<TryAsync<A>> Where< A>(this Arr<TryAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).Bind<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<TryAsync<A>> Where< A>(this Arr<TryAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).BindAsync<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<TryAsync<B>> Select< A, B>(this Arr<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Map<MArr<TryAsync<B>>, Arr<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Arr&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Arr&lt;TryAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this Arr<TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Arr&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Arr&lt;TryAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this Arr<TryAsync<A>> ma) =>
            default(TransSyncAsync<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<TryAsync<B>> BindT< A, B>(this Arr<TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            default(TransSyncAsync<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Bind<MArr<TryAsync<B>>, Arr<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Arr&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;Arr&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Arr&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<Arr<B>> Traverse< A, B>(this Arr<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Traverse<MTryAsync<Arr<B>>, TryAsync<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Arr&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;Arr&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Arr&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<Arr<B>> Traverse< A, B>(this Arr<TryAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .TraverseAsync<MTryAsync<Arr<B>>, TryAsync<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Arr&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;Arr&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<Arr<A>> Sequence< A>(this Arr<TryAsync<A>> ma) =>
            default(TransSyncAsync<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Sequence<MTryAsync<Arr<A>>, TryAsync<Arr<A>>, MArr<A>, Arr<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<TryAsync<B>> MapT< A, B>(this Arr<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Map<MArr<TryAsync<B>>, Arr<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<TryAsync<B>> MapT< A, B>(this Arr<TryAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .MapAsync<MArr<TryAsync<B>>, Arr<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Arr<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Arr<TryAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Arr<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Arr<TryAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this Arr<TryAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this Arr<TryAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Arr&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this Arr<TryAsync<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<TryAsync<A>> FilterT< A>(this Arr<TryAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Bind<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<TryAsync<A>> FilterT< A>(this Arr<TryAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .BindAsync<MArr<TryAsync<A>>, Arr<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Arr<TryAsync<A>> PlusT<NUM,  A>(this Arr<TryAsync<A>> x, Arr<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Arr<TryAsync<A>> SubtractT<NUM,  A>(this Arr<TryAsync<A>> x, Arr<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Arr<TryAsync<A>> ProductT<NUM,  A>(this Arr<TryAsync<A>> x, Arr<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Arr<TryAsync<A>> DivideT<NUM,  A>(this Arr<TryAsync<A>> x, Arr<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Arr<TryAsync<A>> AppendT<SEMI,  A>(this Arr<TryAsync<A>> x, Arr<TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this Arr<TryAsync<A>> x, Arr<TryAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this Arr<TryAsync<A>> x, Arr<TryAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Arr&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Arr&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Arr<TryAsync<B>> ApplyT< A, B>(this Func<A, B> fab, Arr<TryAsync<A>> fa) =>
            default(ApplArr< TryAsync<A>, TryAsync<B>>).Apply(
                default(MArr< Func<TryAsync<A>, TryAsync<B>>>).Return(
                    (TryAsync<A> a) => 
                        default(ApplTryAsync< A, B>).Apply(
                            default(MTryAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Arr&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Arr&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Arr&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Arr<TryAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Arr<TryAsync<A>> fa, Arr<TryAsync<B>> fb) =>
            default(ApplArr< TryAsync<A>, TryAsync<B>, TryAsync<C>>).Apply(
                default(MArr< Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>).Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            default(ApplTryAsync< A, B, C>).Apply(
                                default(MTryAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`HashSet&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<TryAsync<C>> SelectMany< A, B, C>(
            this HashSet<TryAsync<A>> ma,
            Func<A, TryAsync<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MHashSet<TryAsync<B>>, HashSet<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MHashSet<TryAsync<C>>, HashSet<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`HashSet&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<TryAsync<C>> SelectMany< A, B, C>(
            this HashSet<TryAsync<A>> ma,
            Func<A, Task<TryAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MHashSet<TryAsync<B>>, HashSet<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MHashSet<TryAsync<C>>, HashSet<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`HashSet&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<TryAsync<C>> SelectMany< A, B, C>(
            this HashSet<TryAsync<A>> ma,
            Func<A, TryAsync<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MHashSet<TryAsync<B>>, HashSet<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MHashSet<TryAsync<C>>, HashSet<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`HashSet&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<TryAsync<C>> SelectMany< A, B, C>(
            this HashSet<TryAsync<A>> ma,
            Func<A, Task<TryAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MHashSet<TryAsync<B>>, HashSet<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MHashSet<TryAsync<C>>, HashSet<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<TryAsync<A>> Where< A>(this HashSet<TryAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).Bind<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<TryAsync<A>> Where< A>(this HashSet<TryAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).BindAsync<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<TryAsync<B>> Select< A, B>(this HashSet<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Map<MHashSet<TryAsync<B>>, HashSet<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `HashSet&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `HashSet&lt;TryAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this HashSet<TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `HashSet&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `HashSet&lt;TryAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this HashSet<TryAsync<A>> ma) =>
            default(TransSyncAsync<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<TryAsync<B>> BindT< A, B>(this HashSet<TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            default(TransSyncAsync<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Bind<MHashSet<TryAsync<B>>, HashSet<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `HashSet&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;HashSet&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;HashSet&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<HashSet<B>> Traverse< A, B>(this HashSet<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Traverse<MTryAsync<HashSet<B>>, TryAsync<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `HashSet&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;HashSet&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;HashSet&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<HashSet<B>> Traverse< A, B>(this HashSet<TryAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .TraverseAsync<MTryAsync<HashSet<B>>, TryAsync<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `HashSet&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;HashSet&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<HashSet<A>> Sequence< A>(this HashSet<TryAsync<A>> ma) =>
            default(TransSyncAsync<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Sequence<MTryAsync<HashSet<A>>, TryAsync<HashSet<A>>, MHashSet<A>, HashSet<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<TryAsync<B>> MapT< A, B>(this HashSet<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Map<MHashSet<TryAsync<B>>, HashSet<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<TryAsync<B>> MapT< A, B>(this HashSet<TryAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .MapAsync<MHashSet<TryAsync<B>>, HashSet<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this HashSet<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this HashSet<TryAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this HashSet<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this HashSet<TryAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this HashSet<TryAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this HashSet<TryAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `HashSet&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this HashSet<TryAsync<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<TryAsync<A>> FilterT< A>(this HashSet<TryAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Bind<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<TryAsync<A>> FilterT< A>(this HashSet<TryAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .BindAsync<MHashSet<TryAsync<A>>, HashSet<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<TryAsync<A>> PlusT<NUM,  A>(this HashSet<TryAsync<A>> x, HashSet<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<TryAsync<A>> SubtractT<NUM,  A>(this HashSet<TryAsync<A>> x, HashSet<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static HashSet<TryAsync<A>> ProductT<NUM,  A>(this HashSet<TryAsync<A>> x, HashSet<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static HashSet<TryAsync<A>> DivideT<NUM,  A>(this HashSet<TryAsync<A>> x, HashSet<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static HashSet<TryAsync<A>> AppendT<SEMI,  A>(this HashSet<TryAsync<A>> x, HashSet<TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this HashSet<TryAsync<A>> x, HashSet<TryAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this HashSet<TryAsync<A>> x, HashSet<TryAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `HashSet&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <returns>`HashSet&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static HashSet<TryAsync<B>> ApplyT< A, B>(this Func<A, B> fab, HashSet<TryAsync<A>> fa) =>
            default(ApplHashSet< TryAsync<A>, TryAsync<B>>).Apply(
                default(MHashSet< Func<TryAsync<A>, TryAsync<B>>>).Return(
                    (TryAsync<A> a) => 
                        default(ApplTryAsync< A, B>).Apply(
                            default(MTryAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `HashSet&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `HashSet&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <returns>`HashSet&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static HashSet<TryAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, HashSet<TryAsync<A>> fa, HashSet<TryAsync<B>> fb) =>
            default(ApplHashSet< TryAsync<A>, TryAsync<B>, TryAsync<C>>).Apply(
                default(MHashSet< Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>).Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            default(ApplTryAsync< A, B, C>).Apply(
                                default(MTryAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Lst&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<TryAsync<C>> SelectMany< A, B, C>(
            this Lst<TryAsync<A>> ma,
            Func<A, TryAsync<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MLst<TryAsync<B>>, Lst<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MLst<TryAsync<C>>, Lst<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Lst&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<TryAsync<C>> SelectMany< A, B, C>(
            this Lst<TryAsync<A>> ma,
            Func<A, Task<TryAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MLst<TryAsync<B>>, Lst<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MLst<TryAsync<C>>, Lst<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Lst&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<TryAsync<C>> SelectMany< A, B, C>(
            this Lst<TryAsync<A>> ma,
            Func<A, TryAsync<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MLst<TryAsync<B>>, Lst<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MLst<TryAsync<C>>, Lst<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Lst&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<TryAsync<C>> SelectMany< A, B, C>(
            this Lst<TryAsync<A>> ma,
            Func<A, Task<TryAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MLst<TryAsync<B>>, Lst<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MLst<TryAsync<C>>, Lst<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<TryAsync<A>> Where< A>(this Lst<TryAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).Bind<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<TryAsync<A>> Where< A>(this Lst<TryAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).BindAsync<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<TryAsync<B>> Select< A, B>(this Lst<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Map<MLst<TryAsync<B>>, Lst<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Lst&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Lst&lt;TryAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this Lst<TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Lst&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Lst&lt;TryAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this Lst<TryAsync<A>> ma) =>
            default(TransSyncAsync<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<TryAsync<B>> BindT< A, B>(this Lst<TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            default(TransSyncAsync<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Bind<MLst<TryAsync<B>>, Lst<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Lst&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;Lst&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Lst&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<Lst<B>> Traverse< A, B>(this Lst<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Traverse<MTryAsync<Lst<B>>, TryAsync<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Lst&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;Lst&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Lst&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<Lst<B>> Traverse< A, B>(this Lst<TryAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .TraverseAsync<MTryAsync<Lst<B>>, TryAsync<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Lst&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;Lst&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<Lst<A>> Sequence< A>(this Lst<TryAsync<A>> ma) =>
            default(TransSyncAsync<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Sequence<MTryAsync<Lst<A>>, TryAsync<Lst<A>>, MLst<A>, Lst<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<TryAsync<B>> MapT< A, B>(this Lst<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Map<MLst<TryAsync<B>>, Lst<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<TryAsync<B>> MapT< A, B>(this Lst<TryAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .MapAsync<MLst<TryAsync<B>>, Lst<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Lst<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Lst<TryAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Lst<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Lst<TryAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this Lst<TryAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this Lst<TryAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Lst&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this Lst<TryAsync<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<TryAsync<A>> FilterT< A>(this Lst<TryAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Bind<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<TryAsync<A>> FilterT< A>(this Lst<TryAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .BindAsync<MLst<TryAsync<A>>, Lst<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Lst<TryAsync<A>> PlusT<NUM,  A>(this Lst<TryAsync<A>> x, Lst<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Lst<TryAsync<A>> SubtractT<NUM,  A>(this Lst<TryAsync<A>> x, Lst<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Lst<TryAsync<A>> ProductT<NUM,  A>(this Lst<TryAsync<A>> x, Lst<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Lst<TryAsync<A>> DivideT<NUM,  A>(this Lst<TryAsync<A>> x, Lst<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Lst<TryAsync<A>> AppendT<SEMI,  A>(this Lst<TryAsync<A>> x, Lst<TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this Lst<TryAsync<A>> x, Lst<TryAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this Lst<TryAsync<A>> x, Lst<TryAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Lst&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Lst&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Lst<TryAsync<B>> ApplyT< A, B>(this Func<A, B> fab, Lst<TryAsync<A>> fa) =>
            default(ApplLst< TryAsync<A>, TryAsync<B>>).Apply(
                default(MLst< Func<TryAsync<A>, TryAsync<B>>>).Return(
                    (TryAsync<A> a) => 
                        default(ApplTryAsync< A, B>).Apply(
                            default(MTryAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Lst&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Lst&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Lst&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Lst<TryAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Lst<TryAsync<A>> fa, Lst<TryAsync<B>> fb) =>
            default(ApplLst< TryAsync<A>, TryAsync<B>, TryAsync<C>>).Apply(
                default(MLst< Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>).Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            default(ApplTryAsync< A, B, C>).Apply(
                                default(MTryAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Option&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Option<TryAsync<C>> SelectMany< A, B, C>(
            this Option<TryAsync<A>> ma,
            Func<A, TryAsync<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MOption<TryAsync<B>>, Option<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MOption<TryAsync<C>>, Option<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Option&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Option<TryAsync<C>> SelectMany< A, B, C>(
            this Option<TryAsync<A>> ma,
            Func<A, Task<TryAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MOption<TryAsync<B>>, Option<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MOption<TryAsync<C>>, Option<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Option&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Option<TryAsync<C>> SelectMany< A, B, C>(
            this Option<TryAsync<A>> ma,
            Func<A, TryAsync<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MOption<TryAsync<B>>, Option<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MOption<TryAsync<C>>, Option<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Option&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Option<TryAsync<C>> SelectMany< A, B, C>(
            this Option<TryAsync<A>> ma,
            Func<A, Task<TryAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MOption<TryAsync<B>>, Option<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MOption<TryAsync<C>>, Option<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<TryAsync<A>> Where< A>(this Option<TryAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).Bind<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<TryAsync<A>> Where< A>(this Option<TryAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).BindAsync<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<TryAsync<B>> Select< A, B>(this Option<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Map<MOption<TryAsync<B>>, Option<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Option&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Option&lt;TryAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this Option<TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Option&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Option&lt;TryAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this Option<TryAsync<A>> ma) =>
            default(TransSyncAsync<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<TryAsync<B>> BindT< A, B>(this Option<TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            default(TransSyncAsync<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Bind<MOption<TryAsync<B>>, Option<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Option&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;Option&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Option&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<Option<B>> Traverse< A, B>(this Option<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Traverse<MTryAsync<Option<B>>, TryAsync<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Option&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;Option&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Option&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<Option<B>> Traverse< A, B>(this Option<TryAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .TraverseAsync<MTryAsync<Option<B>>, TryAsync<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Option&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;Option&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<Option<A>> Sequence< A>(this Option<TryAsync<A>> ma) =>
            default(TransSyncAsync<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Sequence<MTryAsync<Option<A>>, TryAsync<Option<A>>, MOption<A>, Option<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<TryAsync<B>> MapT< A, B>(this Option<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Map<MOption<TryAsync<B>>, Option<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<TryAsync<B>> MapT< A, B>(this Option<TryAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .MapAsync<MOption<TryAsync<B>>, Option<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Option<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Option<TryAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Option<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Option<TryAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this Option<TryAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this Option<TryAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Option&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this Option<TryAsync<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<TryAsync<A>> FilterT< A>(this Option<TryAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Bind<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<TryAsync<A>> FilterT< A>(this Option<TryAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .BindAsync<MOption<TryAsync<A>>, Option<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Option<TryAsync<A>> PlusT<NUM,  A>(this Option<TryAsync<A>> x, Option<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Option<TryAsync<A>> SubtractT<NUM,  A>(this Option<TryAsync<A>> x, Option<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Option<TryAsync<A>> ProductT<NUM,  A>(this Option<TryAsync<A>> x, Option<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Option<TryAsync<A>> DivideT<NUM,  A>(this Option<TryAsync<A>> x, Option<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Option<TryAsync<A>> AppendT<SEMI,  A>(this Option<TryAsync<A>> x, Option<TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this Option<TryAsync<A>> x, Option<TryAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this Option<TryAsync<A>> x, Option<TryAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Option&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Option&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Option<TryAsync<B>> ApplyT< A, B>(this Func<A, B> fab, Option<TryAsync<A>> fa) =>
            default(ApplOption< TryAsync<A>, TryAsync<B>>).Apply(
                default(MOption< Func<TryAsync<A>, TryAsync<B>>>).Return(
                    (TryAsync<A> a) => 
                        default(ApplTryAsync< A, B>).Apply(
                            default(MTryAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Option&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Option&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Option&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Option<TryAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Option<TryAsync<A>> fa, Option<TryAsync<B>> fb) =>
            default(ApplOption< TryAsync<A>, TryAsync<B>, TryAsync<C>>).Apply(
                default(MOption< Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>).Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            default(ApplTryAsync< A, B, C>).Apply(
                                default(MTryAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionUnsafe&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<C>> SelectMany< A, B, C>(
            this OptionUnsafe<TryAsync<A>> ma,
            Func<A, TryAsync<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MOptionUnsafe<TryAsync<B>>, OptionUnsafe<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MOptionUnsafe<TryAsync<C>>, OptionUnsafe<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionUnsafe&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<C>> SelectMany< A, B, C>(
            this OptionUnsafe<TryAsync<A>> ma,
            Func<A, Task<TryAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MOptionUnsafe<TryAsync<B>>, OptionUnsafe<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MOptionUnsafe<TryAsync<C>>, OptionUnsafe<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionUnsafe&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<C>> SelectMany< A, B, C>(
            this OptionUnsafe<TryAsync<A>> ma,
            Func<A, TryAsync<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MOptionUnsafe<TryAsync<B>>, OptionUnsafe<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MOptionUnsafe<TryAsync<C>>, OptionUnsafe<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionUnsafe&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<C>> SelectMany< A, B, C>(
            this OptionUnsafe<TryAsync<A>> ma,
            Func<A, Task<TryAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MOptionUnsafe<TryAsync<B>>, OptionUnsafe<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MOptionUnsafe<TryAsync<C>>, OptionUnsafe<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<A>> Where< A>(this OptionUnsafe<TryAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).Bind<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<A>> Where< A>(this OptionUnsafe<TryAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).BindAsync<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<B>> Select< A, B>(this OptionUnsafe<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Map<MOptionUnsafe<TryAsync<B>>, OptionUnsafe<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this OptionUnsafe<TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this OptionUnsafe<TryAsync<A>> ma) =>
            default(TransSyncAsync<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<B>> BindT< A, B>(this OptionUnsafe<TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            default(TransSyncAsync<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Bind<MOptionUnsafe<TryAsync<B>>, OptionUnsafe<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;OptionUnsafe&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;OptionUnsafe&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<B>> Traverse< A, B>(this OptionUnsafe<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Traverse<MTryAsync<OptionUnsafe<B>>, TryAsync<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;OptionUnsafe&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;OptionUnsafe&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<B>> Traverse< A, B>(this OptionUnsafe<TryAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .TraverseAsync<MTryAsync<OptionUnsafe<B>>, TryAsync<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;OptionUnsafe&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<A>> Sequence< A>(this OptionUnsafe<TryAsync<A>> ma) =>
            default(TransSyncAsync<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Sequence<MTryAsync<OptionUnsafe<A>>, TryAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<B>> MapT< A, B>(this OptionUnsafe<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Map<MOptionUnsafe<TryAsync<B>>, OptionUnsafe<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<B>> MapT< A, B>(this OptionUnsafe<TryAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .MapAsync<MOptionUnsafe<TryAsync<B>>, OptionUnsafe<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this OptionUnsafe<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this OptionUnsafe<TryAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this OptionUnsafe<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this OptionUnsafe<TryAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this OptionUnsafe<TryAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this OptionUnsafe<TryAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this OptionUnsafe<TryAsync<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<A>> FilterT< A>(this OptionUnsafe<TryAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Bind<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<A>> FilterT< A>(this OptionUnsafe<TryAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .BindAsync<MOptionUnsafe<TryAsync<A>>, OptionUnsafe<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<A>> PlusT<NUM,  A>(this OptionUnsafe<TryAsync<A>> x, OptionUnsafe<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<A>> SubtractT<NUM,  A>(this OptionUnsafe<TryAsync<A>> x, OptionUnsafe<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<A>> ProductT<NUM,  A>(this OptionUnsafe<TryAsync<A>> x, OptionUnsafe<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<A>> DivideT<NUM,  A>(this OptionUnsafe<TryAsync<A>> x, OptionUnsafe<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<A>> AppendT<SEMI,  A>(this OptionUnsafe<TryAsync<A>> x, OptionUnsafe<TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this OptionUnsafe<TryAsync<A>> x, OptionUnsafe<TryAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this OptionUnsafe<TryAsync<A>> x, OptionUnsafe<TryAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <returns>`OptionUnsafe&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<B>> ApplyT< A, B>(this Func<A, B> fab, OptionUnsafe<TryAsync<A>> fa) =>
            default(ApplOptionUnsafe< TryAsync<A>, TryAsync<B>>).Apply(
                default(MOptionUnsafe< Func<TryAsync<A>, TryAsync<B>>>).Return(
                    (TryAsync<A> a) => 
                        default(ApplTryAsync< A, B>).Apply(
                            default(MTryAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `OptionUnsafe&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <returns>`OptionUnsafe&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionUnsafe<TryAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, OptionUnsafe<TryAsync<A>> fa, OptionUnsafe<TryAsync<B>> fb) =>
            default(ApplOptionUnsafe< TryAsync<A>, TryAsync<B>, TryAsync<C>>).Apply(
                default(MOptionUnsafe< Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>).Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            default(ApplTryAsync< A, B, C>).Apply(
                                default(MTryAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Either&lt;L, TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, TryAsync<C>> SelectMany<L, A, B, C>(
            this Either<L, TryAsync<A>> ma,
            Func<A, TryAsync<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MEither<L, TryAsync<B>>, Either<L, TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MEither<L, TryAsync<C>>, Either<L, TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Either&lt;L, TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, TryAsync<C>> SelectMany<L, A, B, C>(
            this Either<L, TryAsync<A>> ma,
            Func<A, Task<TryAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MEither<L, TryAsync<B>>, Either<L, TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MEither<L, TryAsync<C>>, Either<L, TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Either&lt;L, TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, TryAsync<C>> SelectMany<L, A, B, C>(
            this Either<L, TryAsync<A>> ma,
            Func<A, TryAsync<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MEither<L, TryAsync<B>>, Either<L, TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MEither<L, TryAsync<C>>, Either<L, TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Either&lt;L, TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, TryAsync<C>> SelectMany<L, A, B, C>(
            this Either<L, TryAsync<A>> ma,
            Func<A, Task<TryAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MEither<L, TryAsync<B>>, Either<L, TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MEither<L, TryAsync<C>>, Either<L, TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, TryAsync<A>> Where<L, A>(this Either<L, TryAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).Bind<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, TryAsync<A>> Where<L, A>(this Either<L, TryAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).BindAsync<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, TryAsync<B>> Select<L, A, B>(this Either<L, TryAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Map<MEither<L, TryAsync<B>>, Either<L, TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Either&lt;L, TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Either&lt;L, TryAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA, L, A>(this Either<L, TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Either&lt;L, TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Either&lt;L, TryAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT<L, A>(this Either<L, TryAsync<A>> ma) =>
            default(TransSyncAsync<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either&lt;L, TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, TryAsync<B>> BindT<L, A, B>(this Either<L, TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            default(TransSyncAsync<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Bind<MEither<L, TryAsync<B>>, Either<L, TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Either&lt;L, TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;Either&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Either&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<Either<L, B>> Traverse<L, A, B>(this Either<L, TryAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Traverse<MTryAsync<Either<L, B>>, TryAsync<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Either&lt;L, TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;Either&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Either&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<Either<L, B>> Traverse<L, A, B>(this Either<L, TryAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .TraverseAsync<MTryAsync<Either<L, B>>, TryAsync<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Either&lt;L, TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;Either&lt;L, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<Either<L, A>> Sequence<L, A>(this Either<L, TryAsync<A>> ma) =>
            default(TransSyncAsync<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Sequence<MTryAsync<Either<L, A>>, TryAsync<Either<L, A>>, MEither<L, A>, Either<L, A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, TryAsync<B>> MapT<L, A, B>(this Either<L, TryAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Map<MEither<L, TryAsync<B>>, Either<L, TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, TryAsync<B>> MapT<L, A, B>(this Either<L, TryAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .MapAsync<MEither<L, TryAsync<B>>, Either<L, TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, L, A>(this Either<L, TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, L, A>(this Either<L, TryAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, L, A>(this Either<L, TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, L, A>(this Either<L, TryAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT<L, A>(this Either<L, TryAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT<L, A>(this Either<L, TryAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Either&lt;L, TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT<L, A>(this Either<L, TryAsync<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, TryAsync<A>> FilterT<L, A>(this Either<L, TryAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Bind<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, TryAsync<A>> FilterT<L, A>(this Either<L, TryAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .BindAsync<MEither<L, TryAsync<A>>, Either<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, TryAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, TryAsync<A>> PlusT<NUM, L, A>(this Either<L, TryAsync<A>> x, Either<L, TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, TryAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, TryAsync<A>> SubtractT<NUM, L, A>(this Either<L, TryAsync<A>> x, Either<L, TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, TryAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Either<L, TryAsync<A>> ProductT<NUM, L, A>(this Either<L, TryAsync<A>> x, Either<L, TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, TryAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Either<L, TryAsync<A>> DivideT<NUM, L, A>(this Either<L, TryAsync<A>> x, Either<L, TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, TryAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Either<L, TryAsync<A>> AppendT<SEMI, L, A>(this Either<L, TryAsync<A>> x, Either<L, TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD, L, A>(this Either<L, TryAsync<A>> x, Either<L, TryAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, TryAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ, L, A>(this Either<L, TryAsync<A>> x, Either<L, TryAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Either&lt;L, TryAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Either&lt;L, TryAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Either<L, TryAsync<B>> ApplyT<L, A, B>(this Func<A, B> fab, Either<L, TryAsync<A>> fa) =>
            default(ApplEither<L, TryAsync<A>, TryAsync<B>>).Apply(
                default(MEither<L, Func<TryAsync<A>, TryAsync<B>>>).Return(
                    (TryAsync<A> a) => 
                        default(ApplTryAsync< A, B>).Apply(
                            default(MTryAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Either&lt;L, TryAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Either&lt;L, TryAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Either&lt;L, TryAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Either<L, TryAsync<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Either<L, TryAsync<A>> fa, Either<L, TryAsync<B>> fb) =>
            default(ApplEither<L, TryAsync<A>, TryAsync<B>, TryAsync<C>>).Apply(
                default(MEither<L, Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>).Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            default(ApplTryAsync< A, B, C>).Apply(
                                default(MTryAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`EitherUnsafe&lt;L, TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, TryAsync<A>> ma,
            Func<A, TryAsync<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MEitherUnsafe<L, TryAsync<B>>, EitherUnsafe<L, TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MEitherUnsafe<L, TryAsync<C>>, EitherUnsafe<L, TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`EitherUnsafe&lt;L, TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, TryAsync<A>> ma,
            Func<A, Task<TryAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MEitherUnsafe<L, TryAsync<B>>, EitherUnsafe<L, TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MEitherUnsafe<L, TryAsync<C>>, EitherUnsafe<L, TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`EitherUnsafe&lt;L, TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, TryAsync<A>> ma,
            Func<A, TryAsync<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MEitherUnsafe<L, TryAsync<B>>, EitherUnsafe<L, TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MEitherUnsafe<L, TryAsync<C>>, EitherUnsafe<L, TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`EitherUnsafe&lt;L, TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, TryAsync<A>> ma,
            Func<A, Task<TryAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MEitherUnsafe<L, TryAsync<B>>, EitherUnsafe<L, TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MEitherUnsafe<L, TryAsync<C>>, EitherUnsafe<L, TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<A>> Where<L, A>(this EitherUnsafe<L, TryAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).Bind<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<A>> Where<L, A>(this EitherUnsafe<L, TryAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).BindAsync<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<B>> Select<L, A, B>(this EitherUnsafe<L, TryAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Map<MEitherUnsafe<L, TryAsync<B>>, EitherUnsafe<L, TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA, L, A>(this EitherUnsafe<L, TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT<L, A>(this EitherUnsafe<L, TryAsync<A>> ma) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<B>> BindT<L, A, B>(this EitherUnsafe<L, TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Bind<MEitherUnsafe<L, TryAsync<B>>, EitherUnsafe<L, TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;EitherUnsafe&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;EitherUnsafe&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, B>> Traverse<L, A, B>(this EitherUnsafe<L, TryAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Traverse<MTryAsync<EitherUnsafe<L, B>>, TryAsync<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;EitherUnsafe&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;EitherUnsafe&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, B>> Traverse<L, A, B>(this EitherUnsafe<L, TryAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .TraverseAsync<MTryAsync<EitherUnsafe<L, B>>, TryAsync<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, A>> Sequence<L, A>(this EitherUnsafe<L, TryAsync<A>> ma) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Sequence<MTryAsync<EitherUnsafe<L, A>>, TryAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<B>> MapT<L, A, B>(this EitherUnsafe<L, TryAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Map<MEitherUnsafe<L, TryAsync<B>>, EitherUnsafe<L, TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<B>> MapT<L, A, B>(this EitherUnsafe<L, TryAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .MapAsync<MEitherUnsafe<L, TryAsync<B>>, EitherUnsafe<L, TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, L, A>(this EitherUnsafe<L, TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, L, A>(this EitherUnsafe<L, TryAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, L, A>(this EitherUnsafe<L, TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, L, A>(this EitherUnsafe<L, TryAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT<L, A>(this EitherUnsafe<L, TryAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT<L, A>(this EitherUnsafe<L, TryAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT<L, A>(this EitherUnsafe<L, TryAsync<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<A>> FilterT<L, A>(this EitherUnsafe<L, TryAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Bind<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<A>> FilterT<L, A>(this EitherUnsafe<L, TryAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .BindAsync<MEitherUnsafe<L, TryAsync<A>>, EitherUnsafe<L, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<A>> PlusT<NUM, L, A>(this EitherUnsafe<L, TryAsync<A>> x, EitherUnsafe<L, TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<A>> SubtractT<NUM, L, A>(this EitherUnsafe<L, TryAsync<A>> x, EitherUnsafe<L, TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<A>> ProductT<NUM, L, A>(this EitherUnsafe<L, TryAsync<A>> x, EitherUnsafe<L, TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<A>> DivideT<NUM, L, A>(this EitherUnsafe<L, TryAsync<A>> x, EitherUnsafe<L, TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<A>> AppendT<SEMI, L, A>(this EitherUnsafe<L, TryAsync<A>> x, EitherUnsafe<L, TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD, L, A>(this EitherUnsafe<L, TryAsync<A>> x, EitherUnsafe<L, TryAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ, L, A>(this EitherUnsafe<L, TryAsync<A>> x, EitherUnsafe<L, TryAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;`</param>
        /// <returns>`EitherUnsafe&lt;L, TryAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherUnsafe<L, TryAsync<A>> fa) =>
            default(ApplEitherUnsafe<L, TryAsync<A>, TryAsync<B>>).Apply(
                default(MEitherUnsafe<L, Func<TryAsync<A>, TryAsync<B>>>).Return(
                    (TryAsync<A> a) => 
                        default(ApplTryAsync< A, B>).Apply(
                            default(MTryAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `EitherUnsafe&lt;L, TryAsync&lt;A&gt;&gt;`</param>
        /// <returns>`EitherUnsafe&lt;L, TryAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherUnsafe<L, TryAsync<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherUnsafe<L, TryAsync<A>> fa, EitherUnsafe<L, TryAsync<B>> fb) =>
            default(ApplEitherUnsafe<L, TryAsync<A>, TryAsync<B>, TryAsync<C>>).Apply(
                default(MEitherUnsafe<L, Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>).Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            default(ApplTryAsync< A, B, C>).Apply(
                                default(MTryAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Try&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Try<TryAsync<C>> SelectMany< A, B, C>(
            this Try<TryAsync<A>> ma,
            Func<A, TryAsync<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MTry<TryAsync<B>>, Try<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MTry<TryAsync<C>>, Try<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Try&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Try<TryAsync<C>> SelectMany< A, B, C>(
            this Try<TryAsync<A>> ma,
            Func<A, Task<TryAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MTry<TryAsync<B>>, Try<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MTry<TryAsync<C>>, Try<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Try&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Try<TryAsync<C>> SelectMany< A, B, C>(
            this Try<TryAsync<A>> ma,
            Func<A, TryAsync<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MTry<TryAsync<B>>, Try<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MTry<TryAsync<C>>, Try<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Try&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Try<TryAsync<C>> SelectMany< A, B, C>(
            this Try<TryAsync<A>> ma,
            Func<A, Task<TryAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MTry<TryAsync<B>>, Try<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MTry<TryAsync<C>>, Try<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<TryAsync<A>> Where< A>(this Try<TryAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).Bind<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<TryAsync<A>> Where< A>(this Try<TryAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).BindAsync<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<TryAsync<B>> Select< A, B>(this Try<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Map<MTry<TryAsync<B>>, Try<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Try&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Try&lt;TryAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this Try<TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Try&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Try&lt;TryAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this Try<TryAsync<A>> ma) =>
            default(TransSyncAsync<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<TryAsync<B>> BindT< A, B>(this Try<TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            default(TransSyncAsync<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Bind<MTry<TryAsync<B>>, Try<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Try&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;Try&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Try&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<Try<B>> Traverse< A, B>(this Try<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Traverse<MTryAsync<Try<B>>, TryAsync<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Try&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;Try&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Try&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<Try<B>> Traverse< A, B>(this Try<TryAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .TraverseAsync<MTryAsync<Try<B>>, TryAsync<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Try&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;Try&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<Try<A>> Sequence< A>(this Try<TryAsync<A>> ma) =>
            default(TransSyncAsync<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Sequence<MTryAsync<Try<A>>, TryAsync<Try<A>>, MTry<A>, Try<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<TryAsync<B>> MapT< A, B>(this Try<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Map<MTry<TryAsync<B>>, Try<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<TryAsync<B>> MapT< A, B>(this Try<TryAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .MapAsync<MTry<TryAsync<B>>, Try<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Try<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Try<TryAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Try<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Try<TryAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this Try<TryAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this Try<TryAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Try&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this Try<TryAsync<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<TryAsync<A>> FilterT< A>(this Try<TryAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Bind<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<TryAsync<A>> FilterT< A>(this Try<TryAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .BindAsync<MTry<TryAsync<A>>, Try<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Try<TryAsync<A>> PlusT<NUM,  A>(this Try<TryAsync<A>> x, Try<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Try<TryAsync<A>> SubtractT<NUM,  A>(this Try<TryAsync<A>> x, Try<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Try<TryAsync<A>> ProductT<NUM,  A>(this Try<TryAsync<A>> x, Try<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Try<TryAsync<A>> DivideT<NUM,  A>(this Try<TryAsync<A>> x, Try<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Try<TryAsync<A>> AppendT<SEMI,  A>(this Try<TryAsync<A>> x, Try<TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this Try<TryAsync<A>> x, Try<TryAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this Try<TryAsync<A>> x, Try<TryAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Try&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Try&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Try<TryAsync<B>> ApplyT< A, B>(this Func<A, B> fab, Try<TryAsync<A>> fa) =>
            default(ApplTry< TryAsync<A>, TryAsync<B>>).Apply(
                default(MTry< Func<TryAsync<A>, TryAsync<B>>>).Return(
                    (TryAsync<A> a) => 
                        default(ApplTryAsync< A, B>).Apply(
                            default(MTryAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Try&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Try&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Try&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Try<TryAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Try<TryAsync<A>> fa, Try<TryAsync<B>> fb) =>
            default(ApplTry< TryAsync<A>, TryAsync<B>, TryAsync<C>>).Apply(
                default(MTry< Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>).Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            default(ApplTryAsync< A, B, C>).Apply(
                                default(MTryAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOption&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<TryAsync<C>> SelectMany< A, B, C>(
            this TryOption<TryAsync<A>> ma,
            Func<A, TryAsync<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MTryOption<TryAsync<B>>, TryOption<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MTryOption<TryAsync<C>>, TryOption<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOption&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<TryAsync<C>> SelectMany< A, B, C>(
            this TryOption<TryAsync<A>> ma,
            Func<A, Task<TryAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MTryOption<TryAsync<B>>, TryOption<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MTryOption<TryAsync<C>>, TryOption<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOption&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<TryAsync<C>> SelectMany< A, B, C>(
            this TryOption<TryAsync<A>> ma,
            Func<A, TryAsync<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MTryOption<TryAsync<B>>, TryOption<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MTryOption<TryAsync<C>>, TryOption<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOption&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<TryAsync<C>> SelectMany< A, B, C>(
            this TryOption<TryAsync<A>> ma,
            Func<A, Task<TryAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MTryOption<TryAsync<B>>, TryOption<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MTryOption<TryAsync<C>>, TryOption<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<TryAsync<A>> Where< A>(this TryOption<TryAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).Bind<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<TryAsync<A>> Where< A>(this TryOption<TryAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).BindAsync<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<TryAsync<B>> Select< A, B>(this TryOption<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Map<MTryOption<TryAsync<B>>, TryOption<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOption&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOption&lt;TryAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this TryOption<TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOption&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOption&lt;TryAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this TryOption<TryAsync<A>> ma) =>
            default(TransSyncAsync<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<TryAsync<B>> BindT< A, B>(this TryOption<TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            default(TransSyncAsync<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Bind<MTryOption<TryAsync<B>>, TryOption<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOption&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;TryOption&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;TryOption&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<TryOption<B>> Traverse< A, B>(this TryOption<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Traverse<MTryAsync<TryOption<B>>, TryAsync<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOption&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;TryOption&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;TryOption&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<TryOption<B>> Traverse< A, B>(this TryOption<TryAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .TraverseAsync<MTryAsync<TryOption<B>>, TryAsync<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOption&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;TryOption&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<TryOption<A>> Sequence< A>(this TryOption<TryAsync<A>> ma) =>
            default(TransSyncAsync<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Sequence<MTryAsync<TryOption<A>>, TryAsync<TryOption<A>>, MTryOption<A>, TryOption<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<TryAsync<B>> MapT< A, B>(this TryOption<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Map<MTryOption<TryAsync<B>>, TryOption<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<TryAsync<B>> MapT< A, B>(this TryOption<TryAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .MapAsync<MTryOption<TryAsync<B>>, TryOption<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryOption<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryOption<TryAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryOption<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryOption<TryAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this TryOption<TryAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this TryOption<TryAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOption&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this TryOption<TryAsync<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<TryAsync<A>> FilterT< A>(this TryOption<TryAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Bind<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<TryAsync<A>> FilterT< A>(this TryOption<TryAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .BindAsync<MTryOption<TryAsync<A>>, TryOption<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<TryAsync<A>> PlusT<NUM,  A>(this TryOption<TryAsync<A>> x, TryOption<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<TryAsync<A>> SubtractT<NUM,  A>(this TryOption<TryAsync<A>> x, TryOption<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOption<TryAsync<A>> ProductT<NUM,  A>(this TryOption<TryAsync<A>> x, TryOption<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOption<TryAsync<A>> DivideT<NUM,  A>(this TryOption<TryAsync<A>> x, TryOption<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOption<TryAsync<A>> AppendT<SEMI,  A>(this TryOption<TryAsync<A>> x, TryOption<TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this TryOption<TryAsync<A>> x, TryOption<TryAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this TryOption<TryAsync<A>> x, TryOption<TryAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOption&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <returns>`TryOption&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOption<TryAsync<B>> ApplyT< A, B>(this Func<A, B> fab, TryOption<TryAsync<A>> fa) =>
            default(ApplTryOption< TryAsync<A>, TryAsync<B>>).Apply(
                default(MTryOption< Func<TryAsync<A>, TryAsync<B>>>).Return(
                    (TryAsync<A> a) => 
                        default(ApplTryAsync< A, B>).Apply(
                            default(MTryAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOption&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryOption&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <returns>`TryOption&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOption<TryAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOption<TryAsync<A>> fa, TryOption<TryAsync<B>> fb) =>
            default(ApplTryOption< TryAsync<A>, TryAsync<B>, TryAsync<C>>).Apply(
                default(MTryOption< Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>).Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            default(ApplTryAsync< A, B, C>).Apply(
                                default(MTryAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`IEnumerable&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<TryAsync<C>> SelectMany< A, B, C>(
            this IEnumerable<TryAsync<A>> ma,
            Func<A, TryAsync<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MEnumerable<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MEnumerable<TryAsync<B>>, IEnumerable<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MEnumerable<TryAsync<C>>, IEnumerable<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`IEnumerable&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<TryAsync<C>> SelectMany< A, B, C>(
            this IEnumerable<TryAsync<A>> ma,
            Func<A, Task<TryAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MEnumerable<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MEnumerable<TryAsync<B>>, IEnumerable<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MEnumerable<TryAsync<C>>, IEnumerable<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`IEnumerable&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<TryAsync<C>> SelectMany< A, B, C>(
            this IEnumerable<TryAsync<A>> ma,
            Func<A, TryAsync<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MEnumerable<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MEnumerable<TryAsync<B>>, IEnumerable<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MEnumerable<TryAsync<C>>, IEnumerable<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`IEnumerable&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<TryAsync<C>> SelectMany< A, B, C>(
            this IEnumerable<TryAsync<A>> ma,
            Func<A, Task<TryAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MEnumerable<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MEnumerable<TryAsync<B>>, IEnumerable<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MEnumerable<TryAsync<C>>, IEnumerable<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<TryAsync<A>> Where< A>(this IEnumerable<TryAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MEnumerable<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).Bind<MEnumerable<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<TryAsync<A>> Where< A>(this IEnumerable<TryAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MEnumerable<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).BindAsync<MEnumerable<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<TryAsync<B>> Select< A, B>(this IEnumerable<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MEnumerable<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Map<MEnumerable<TryAsync<B>>, IEnumerable<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `IEnumerable&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `IEnumerable&lt;TryAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this IEnumerable<TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MEnumerable<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `IEnumerable&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `IEnumerable&lt;TryAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this IEnumerable<TryAsync<A>> ma) =>
            default(TransSyncAsync<MEnumerable<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<TryAsync<B>> BindT< A, B>(this IEnumerable<TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            default(TransSyncAsync<MEnumerable<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Bind<MEnumerable<TryAsync<B>>, IEnumerable<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `IEnumerable&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;IEnumerable&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;IEnumerable&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<IEnumerable<B>> Traverse< A, B>(this IEnumerable<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MEnumerable<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Traverse<MTryAsync<IEnumerable<B>>, TryAsync<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `IEnumerable&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;IEnumerable&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;IEnumerable&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<IEnumerable<B>> Traverse< A, B>(this IEnumerable<TryAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MEnumerable<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .TraverseAsync<MTryAsync<IEnumerable<B>>, TryAsync<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `IEnumerable&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;IEnumerable&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<IEnumerable<A>> Sequence< A>(this IEnumerable<TryAsync<A>> ma) =>
            default(TransSyncAsync<MEnumerable<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Sequence<MTryAsync<IEnumerable<A>>, TryAsync<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<TryAsync<B>> MapT< A, B>(this IEnumerable<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MEnumerable<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Map<MEnumerable<TryAsync<B>>, IEnumerable<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<TryAsync<B>> MapT< A, B>(this IEnumerable<TryAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MEnumerable<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .MapAsync<MEnumerable<TryAsync<B>>, IEnumerable<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this IEnumerable<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MEnumerable<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this IEnumerable<TryAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MEnumerable<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this IEnumerable<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MEnumerable<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this IEnumerable<TryAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MEnumerable<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this IEnumerable<TryAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MEnumerable<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this IEnumerable<TryAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MEnumerable<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `IEnumerable&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this IEnumerable<TryAsync<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MEnumerable<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<TryAsync<A>> FilterT< A>(this IEnumerable<TryAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MEnumerable<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Bind<MEnumerable<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<TryAsync<A>> FilterT< A>(this IEnumerable<TryAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MEnumerable<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .BindAsync<MEnumerable<TryAsync<A>>, IEnumerable<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<TryAsync<A>> PlusT<NUM,  A>(this IEnumerable<TryAsync<A>> x, IEnumerable<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<TryAsync<A>> SubtractT<NUM,  A>(this IEnumerable<TryAsync<A>> x, IEnumerable<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static IEnumerable<TryAsync<A>> ProductT<NUM,  A>(this IEnumerable<TryAsync<A>> x, IEnumerable<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static IEnumerable<TryAsync<A>> DivideT<NUM,  A>(this IEnumerable<TryAsync<A>> x, IEnumerable<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static IEnumerable<TryAsync<A>> AppendT<SEMI,  A>(this IEnumerable<TryAsync<A>> x, IEnumerable<TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this IEnumerable<TryAsync<A>> x, IEnumerable<TryAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this IEnumerable<TryAsync<A>> x, IEnumerable<TryAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `IEnumerable&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <returns>`IEnumerable&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static IEnumerable<TryAsync<B>> ApplyT< A, B>(this Func<A, B> fab, IEnumerable<TryAsync<A>> fa) =>
            default(ApplEnumerable< TryAsync<A>, TryAsync<B>>).Apply(
                default(MEnumerable< Func<TryAsync<A>, TryAsync<B>>>).Return(
                    (TryAsync<A> a) => 
                        default(ApplTryAsync< A, B>).Apply(
                            default(MTryAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `IEnumerable&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `IEnumerable&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <returns>`IEnumerable&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static IEnumerable<TryAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, IEnumerable<TryAsync<A>> fa, IEnumerable<TryAsync<B>> fb) =>
            default(ApplEnumerable< TryAsync<A>, TryAsync<B>, TryAsync<C>>).Apply(
                default(MEnumerable< Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>).Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            default(ApplTryAsync< A, B, C>).Apply(
                                default(MTryAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Seq&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Seq<TryAsync<C>> SelectMany< A, B, C>(
            this Seq<TryAsync<A>> ma,
            Func<A, TryAsync<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MSeq<TryAsync<A>>, Seq<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MSeq<TryAsync<B>>, Seq<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MSeq<TryAsync<C>>, Seq<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Seq&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Seq<TryAsync<C>> SelectMany< A, B, C>(
            this Seq<TryAsync<A>> ma,
            Func<A, Task<TryAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MSeq<TryAsync<A>>, Seq<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MSeq<TryAsync<B>>, Seq<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MSeq<TryAsync<C>>, Seq<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Seq&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Seq<TryAsync<C>> SelectMany< A, B, C>(
            this Seq<TryAsync<A>> ma,
            Func<A, TryAsync<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MSeq<TryAsync<A>>, Seq<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MSeq<TryAsync<B>>, Seq<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MSeq<TryAsync<C>>, Seq<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Seq&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Seq<TryAsync<C>> SelectMany< A, B, C>(
            this Seq<TryAsync<A>> ma,
            Func<A, Task<TryAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MSeq<TryAsync<A>>, Seq<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MSeq<TryAsync<B>>, Seq<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MSeq<TryAsync<C>>, Seq<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<TryAsync<A>> Where< A>(this Seq<TryAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MSeq<TryAsync<A>>, Seq<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).Bind<MSeq<TryAsync<A>>, Seq<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<TryAsync<A>> Where< A>(this Seq<TryAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MSeq<TryAsync<A>>, Seq<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).BindAsync<MSeq<TryAsync<A>>, Seq<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<TryAsync<B>> Select< A, B>(this Seq<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MSeq<TryAsync<A>>, Seq<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Map<MSeq<TryAsync<B>>, Seq<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Seq&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Seq&lt;TryAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this Seq<TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MSeq<TryAsync<A>>, Seq<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Seq&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Seq&lt;TryAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this Seq<TryAsync<A>> ma) =>
            default(TransSyncAsync<MSeq<TryAsync<A>>, Seq<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Seq&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<TryAsync<B>> BindT< A, B>(this Seq<TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            default(TransSyncAsync<MSeq<TryAsync<A>>, Seq<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Bind<MSeq<TryAsync<B>>, Seq<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Seq&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;Seq&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Seq&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<Seq<B>> Traverse< A, B>(this Seq<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MSeq<TryAsync<A>>, Seq<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Traverse<MTryAsync<Seq<B>>, TryAsync<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Seq&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;Seq&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Seq&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<Seq<B>> Traverse< A, B>(this Seq<TryAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MSeq<TryAsync<A>>, Seq<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .TraverseAsync<MTryAsync<Seq<B>>, TryAsync<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Seq&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;Seq&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<Seq<A>> Sequence< A>(this Seq<TryAsync<A>> ma) =>
            default(TransSyncAsync<MSeq<TryAsync<A>>, Seq<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Sequence<MTryAsync<Seq<A>>, TryAsync<Seq<A>>, MSeq<A>, Seq<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<TryAsync<B>> MapT< A, B>(this Seq<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MSeq<TryAsync<A>>, Seq<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Map<MSeq<TryAsync<B>>, Seq<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<TryAsync<B>> MapT< A, B>(this Seq<TryAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MSeq<TryAsync<A>>, Seq<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .MapAsync<MSeq<TryAsync<B>>, Seq<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Seq<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MSeq<TryAsync<A>>, Seq<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Seq<TryAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MSeq<TryAsync<A>>, Seq<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Seq<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MSeq<TryAsync<A>>, Seq<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Seq<TryAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MSeq<TryAsync<A>>, Seq<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this Seq<TryAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MSeq<TryAsync<A>>, Seq<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this Seq<TryAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MSeq<TryAsync<A>>, Seq<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Seq&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this Seq<TryAsync<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MSeq<TryAsync<A>>, Seq<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<TryAsync<A>> FilterT< A>(this Seq<TryAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MSeq<TryAsync<A>>, Seq<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Bind<MSeq<TryAsync<A>>, Seq<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<TryAsync<A>> FilterT< A>(this Seq<TryAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MSeq<TryAsync<A>>, Seq<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .BindAsync<MSeq<TryAsync<A>>, Seq<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Seq<TryAsync<A>> PlusT<NUM,  A>(this Seq<TryAsync<A>> x, Seq<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Seq<TryAsync<A>> SubtractT<NUM,  A>(this Seq<TryAsync<A>> x, Seq<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Seq<TryAsync<A>> ProductT<NUM,  A>(this Seq<TryAsync<A>> x, Seq<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Seq<TryAsync<A>> DivideT<NUM,  A>(this Seq<TryAsync<A>> x, Seq<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Seq<TryAsync<A>> AppendT<SEMI,  A>(this Seq<TryAsync<A>> x, Seq<TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this Seq<TryAsync<A>> x, Seq<TryAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this Seq<TryAsync<A>> x, Seq<TryAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Seq&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Seq&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Seq<TryAsync<B>> ApplyT< A, B>(this Func<A, B> fab, Seq<TryAsync<A>> fa) =>
            default(ApplSeq< TryAsync<A>, TryAsync<B>>).Apply(
                default(MSeq< Func<TryAsync<A>, TryAsync<B>>>).Return(
                    (TryAsync<A> a) => 
                        default(ApplTryAsync< A, B>).Apply(
                            default(MTryAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Seq&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Seq&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Seq&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Seq<TryAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Seq<TryAsync<A>> fa, Seq<TryAsync<B>> fb) =>
            default(ApplSeq< TryAsync<A>, TryAsync<B>, TryAsync<C>>).Apply(
                default(MSeq< Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>).Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            default(ApplTryAsync< A, B, C>).Apply(
                                default(MTryAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Set&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Set<TryAsync<C>> SelectMany< A, B, C>(
            this Set<TryAsync<A>> ma,
            Func<A, TryAsync<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MSet<TryAsync<B>>, Set<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MSet<TryAsync<C>>, Set<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Set&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Set<TryAsync<C>> SelectMany< A, B, C>(
            this Set<TryAsync<A>> ma,
            Func<A, Task<TryAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MSet<TryAsync<B>>, Set<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MSet<TryAsync<C>>, Set<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Set&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Set<TryAsync<C>> SelectMany< A, B, C>(
            this Set<TryAsync<A>> ma,
            Func<A, TryAsync<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MSet<TryAsync<B>>, Set<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MSet<TryAsync<C>>, Set<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Set&lt;TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Set<TryAsync<C>> SelectMany< A, B, C>(
            this Set<TryAsync<A>> ma,
            Func<A, Task<TryAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MSet<TryAsync<B>>, Set<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MSet<TryAsync<C>>, Set<TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<TryAsync<A>> Where< A>(this Set<TryAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).Bind<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<TryAsync<A>> Where< A>(this Set<TryAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).BindAsync<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<TryAsync<B>> Select< A, B>(this Set<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Map<MSet<TryAsync<B>>, Set<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Set&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Set&lt;TryAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this Set<TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Set&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Set&lt;TryAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this Set<TryAsync<A>> ma) =>
            default(TransSyncAsync<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<TryAsync<B>> BindT< A, B>(this Set<TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            default(TransSyncAsync<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Bind<MSet<TryAsync<B>>, Set<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Set&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;Set&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Set&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<Set<B>> Traverse< A, B>(this Set<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Traverse<MTryAsync<Set<B>>, TryAsync<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Set&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;Set&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Set&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<Set<B>> Traverse< A, B>(this Set<TryAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .TraverseAsync<MTryAsync<Set<B>>, TryAsync<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Set&lt;TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;Set&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<Set<A>> Sequence< A>(this Set<TryAsync<A>> ma) =>
            default(TransSyncAsync<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Sequence<MTryAsync<Set<A>>, TryAsync<Set<A>>, MSet<A>, Set<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<TryAsync<B>> MapT< A, B>(this Set<TryAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Map<MSet<TryAsync<B>>, Set<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<TryAsync<B>> MapT< A, B>(this Set<TryAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .MapAsync<MSet<TryAsync<B>>, Set<TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Set<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Set<TryAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Set<TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Set<TryAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this Set<TryAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this Set<TryAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Set&lt;TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this Set<TryAsync<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<TryAsync<A>> FilterT< A>(this Set<TryAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Bind<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<TryAsync<A>> FilterT< A>(this Set<TryAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .BindAsync<MSet<TryAsync<A>>, Set<TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Set<TryAsync<A>> PlusT<NUM,  A>(this Set<TryAsync<A>> x, Set<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Set<TryAsync<A>> SubtractT<NUM,  A>(this Set<TryAsync<A>> x, Set<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Set<TryAsync<A>> ProductT<NUM,  A>(this Set<TryAsync<A>> x, Set<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Set<TryAsync<A>> DivideT<NUM,  A>(this Set<TryAsync<A>> x, Set<TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Set<TryAsync<A>> AppendT<SEMI,  A>(this Set<TryAsync<A>> x, Set<TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this Set<TryAsync<A>> x, Set<TryAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;TryAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this Set<TryAsync<A>> x, Set<TryAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Set&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Set&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Set<TryAsync<B>> ApplyT< A, B>(this Func<A, B> fab, Set<TryAsync<A>> fa) =>
            default(ApplSet< TryAsync<A>, TryAsync<B>>).Apply(
                default(MSet< Func<TryAsync<A>, TryAsync<B>>>).Return(
                    (TryAsync<A> a) => 
                        default(ApplTryAsync< A, B>).Apply(
                            default(MTryAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Set&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Set&lt;TryAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Set&lt;TryAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Set<TryAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Set<TryAsync<A>> fa, Set<TryAsync<B>> fb) =>
            default(ApplSet< TryAsync<A>, TryAsync<B>, TryAsync<C>>).Apply(
                default(MSet< Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>).Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            default(ApplTryAsync< A, B, C>).Apply(
                                default(MTryAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Validation&lt;FAIL, TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Validation<FAIL, TryAsync<C>> SelectMany<FAIL, A, B, C>(
            this Validation<FAIL, TryAsync<A>> ma,
            Func<A, TryAsync<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MValidation<FAIL, TryAsync<A>>, Validation<FAIL, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MValidation<FAIL, TryAsync<B>>, Validation<FAIL, TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MValidation<FAIL, TryAsync<C>>, Validation<FAIL, TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Validation&lt;FAIL, TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Validation<FAIL, TryAsync<C>> SelectMany<FAIL, A, B, C>(
            this Validation<FAIL, TryAsync<A>> ma,
            Func<A, Task<TryAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MValidation<FAIL, TryAsync<A>>, Validation<FAIL, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MValidation<FAIL, TryAsync<B>>, Validation<FAIL, TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MValidation<FAIL, TryAsync<C>>, Validation<FAIL, TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Validation&lt;FAIL, TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Validation<FAIL, TryAsync<C>> SelectMany<FAIL, A, B, C>(
            this Validation<FAIL, TryAsync<A>> ma,
            Func<A, TryAsync<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MValidation<FAIL, TryAsync<A>>, Validation<FAIL, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MValidation<FAIL, TryAsync<B>>, Validation<FAIL, TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MValidation<FAIL, TryAsync<C>>, Validation<FAIL, TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Validation&lt;FAIL, TryAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Validation<FAIL, TryAsync<C>> SelectMany<FAIL, A, B, C>(
            this Validation<FAIL, TryAsync<A>> ma,
            Func<A, Task<TryAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MValidation<FAIL, TryAsync<A>>, Validation<FAIL, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .SelectManyAsync<MValidation<FAIL, TryAsync<B>>, Validation<FAIL, TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B, MValidation<FAIL, TryAsync<C>>, Validation<FAIL, TryAsync<C>>, MTryAsync<C>, TryAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, TryAsync<A>> Where<FAIL, A>(this Validation<FAIL, TryAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MValidation<FAIL, TryAsync<A>>, Validation<FAIL, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).Bind<MValidation<FAIL, TryAsync<A>>, Validation<FAIL, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, TryAsync<A>> Where<FAIL, A>(this Validation<FAIL, TryAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MValidation<FAIL, TryAsync<A>>, Validation<FAIL, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).BindAsync<MValidation<FAIL, TryAsync<A>>, Validation<FAIL, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, TryAsync<B>> Select<FAIL, A, B>(this Validation<FAIL, TryAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MValidation<FAIL, TryAsync<A>>, Validation<FAIL, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Map<MValidation<FAIL, TryAsync<B>>, Validation<FAIL, TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA, FAIL, A>(this Validation<FAIL, TryAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MValidation<FAIL, TryAsync<A>>, Validation<FAIL, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT<FAIL, A>(this Validation<FAIL, TryAsync<A>> ma) =>
            default(TransSyncAsync<MValidation<FAIL, TryAsync<A>>, Validation<FAIL, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Validation&lt;FAIL, TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, TryAsync<B>> BindT<FAIL, A, B>(this Validation<FAIL, TryAsync<A>> ma, Func<A, TryAsync<B>> f) =>
            default(TransSyncAsync<MValidation<FAIL, TryAsync<A>>, Validation<FAIL, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Bind<MValidation<FAIL, TryAsync<B>>, Validation<FAIL, TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;Validation&lt;FAIL, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Validation&lt;FAIL, B&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<Validation<FAIL, B>> Traverse<FAIL, A, B>(this Validation<FAIL, TryAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MValidation<FAIL, TryAsync<A>>, Validation<FAIL, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Traverse<MTryAsync<Validation<FAIL, B>>, TryAsync<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;Validation&lt;FAIL, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Validation&lt;FAIL, B&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<Validation<FAIL, B>> Traverse<FAIL, A, B>(this Validation<FAIL, TryAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MValidation<FAIL, TryAsync<A>>, Validation<FAIL, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .TraverseAsync<MTryAsync<Validation<FAIL, B>>, TryAsync<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryAsync&lt;Validation&lt;FAIL, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<FAIL, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static TryAsync<Validation<FAIL, A>> Sequence<FAIL, A>(this Validation<FAIL, TryAsync<A>> ma) =>
            default(TransSyncAsync<MValidation<FAIL, TryAsync<A>>, Validation<FAIL, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Sequence<MTryAsync<Validation<FAIL, A>>, TryAsync<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, TryAsync<B>> MapT<FAIL, A, B>(this Validation<FAIL, TryAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MValidation<FAIL, TryAsync<A>>, Validation<FAIL, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Map<MValidation<FAIL, TryAsync<B>>, Validation<FAIL, TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, TryAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, TryAsync<B>> MapT<FAIL, A, B>(this Validation<FAIL, TryAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MValidation<FAIL, TryAsync<A>>, Validation<FAIL, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .MapAsync<MValidation<FAIL, TryAsync<B>>, Validation<FAIL, TryAsync<B>>, MTryAsync<B>, TryAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, FAIL, A>(this Validation<FAIL, TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MValidation<FAIL, TryAsync<A>>, Validation<FAIL, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, FAIL, A>(this Validation<FAIL, TryAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MValidation<FAIL, TryAsync<A>>, Validation<FAIL, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, FAIL, A>(this Validation<FAIL, TryAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MValidation<FAIL, TryAsync<A>>, Validation<FAIL, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, FAIL, A>(this Validation<FAIL, TryAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MValidation<FAIL, TryAsync<A>>, Validation<FAIL, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT<FAIL, A>(this Validation<FAIL, TryAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MValidation<FAIL, TryAsync<A>>, Validation<FAIL, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT<FAIL, A>(this Validation<FAIL, TryAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MValidation<FAIL, TryAsync<A>>, Validation<FAIL, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT<FAIL, A>(this Validation<FAIL, TryAsync<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MValidation<FAIL, TryAsync<A>>, Validation<FAIL, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, TryAsync<A>> FilterT<FAIL, A>(this Validation<FAIL, TryAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MValidation<FAIL, TryAsync<A>>, Validation<FAIL, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .Bind<MValidation<FAIL, TryAsync<A>>, Validation<FAIL, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, TryAsync<A>> FilterT<FAIL, A>(this Validation<FAIL, TryAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MValidation<FAIL, TryAsync<A>>, Validation<FAIL, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>)
                .BindAsync<MValidation<FAIL, TryAsync<A>>, Validation<FAIL, TryAsync<A>>, MTryAsync<A>, TryAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTryAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Validation<FAIL, TryAsync<A>> PlusT<NUM, FAIL, A>(this Validation<FAIL, TryAsync<A>> x, Validation<FAIL, TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Validation<FAIL, TryAsync<A>> SubtractT<NUM, FAIL, A>(this Validation<FAIL, TryAsync<A>> x, Validation<FAIL, TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Validation<FAIL, TryAsync<A>> ProductT<NUM, FAIL, A>(this Validation<FAIL, TryAsync<A>> x, Validation<FAIL, TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Validation<FAIL, TryAsync<A>> DivideT<NUM, FAIL, A>(this Validation<FAIL, TryAsync<A>> x, Validation<FAIL, TryAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Validation<FAIL, TryAsync<A>> AppendT<SEMI, FAIL, A>(this Validation<FAIL, TryAsync<A>> x, Validation<FAIL, TryAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD, FAIL, A>(this Validation<FAIL, TryAsync<A>> x, Validation<FAIL, TryAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ, FAIL, A>(this Validation<FAIL, TryAsync<A>> x, Validation<FAIL, TryAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Validation&lt;FAIL, TryAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Validation<FAIL, TryAsync<B>> ApplyT<FAIL, A, B>(this Func<A, B> fab, Validation<FAIL, TryAsync<A>> fa) =>
            default(ApplValidation<FAIL, TryAsync<A>, TryAsync<B>>).Apply(
                default(MValidation<FAIL, Func<TryAsync<A>, TryAsync<B>>>).Return(
                    (TryAsync<A> a) => 
                        default(ApplTryAsync< A, B>).Apply(
                            default(MTryAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Validation&lt;FAIL, TryAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Validation&lt;FAIL, TryAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Validation<FAIL, TryAsync<C>> ApplyT<FAIL, A, B, C>(this Func<A, B, C> fabc, Validation<FAIL, TryAsync<A>> fa, Validation<FAIL, TryAsync<B>> fb) =>
            default(ApplValidation<FAIL, TryAsync<A>, TryAsync<B>, TryAsync<C>>).Apply(
                default(MValidation<FAIL, Func<TryAsync<A>, Func<TryAsync<B>, TryAsync<C>>>>).Return(
                    (TryAsync<A> a) =>
                        (TryAsync<B> b) =>
                            default(ApplTryAsync< A, B, C>).Apply(
                                default(MTryAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

    }
    /// <summary>
    /// Async monad transformer for TryOptionAsync, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class TryOptionAsyncT_SyncAsync_Extensions
    {
        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Arr&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<TryOptionAsync<C>> SelectMany< A, B, C>(
            this Arr<TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MArr<TryOptionAsync<B>>, Arr<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MArr<TryOptionAsync<C>>, Arr<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Arr&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<TryOptionAsync<C>> SelectMany< A, B, C>(
            this Arr<TryOptionAsync<A>> ma,
            Func<A, Task<TryOptionAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MArr<TryOptionAsync<B>>, Arr<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MArr<TryOptionAsync<C>>, Arr<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Arr&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<TryOptionAsync<C>> SelectMany< A, B, C>(
            this Arr<TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MArr<TryOptionAsync<B>>, Arr<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MArr<TryOptionAsync<C>>, Arr<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Arr&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<TryOptionAsync<C>> SelectMany< A, B, C>(
            this Arr<TryOptionAsync<A>> ma,
            Func<A, Task<TryOptionAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MArr<TryOptionAsync<B>>, Arr<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MArr<TryOptionAsync<C>>, Arr<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<TryOptionAsync<A>> Where< A>(this Arr<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).Bind<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<TryOptionAsync<A>> Where< A>(this Arr<TryOptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).BindAsync<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<TryOptionAsync<B>> Select< A, B>(this Arr<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Map<MArr<TryOptionAsync<B>>, Arr<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Arr&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Arr&lt;TryOptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this Arr<TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Arr&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Arr&lt;TryOptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this Arr<TryOptionAsync<A>> ma) =>
            default(TransSyncAsync<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<TryOptionAsync<B>> BindT< A, B>(this Arr<TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            default(TransSyncAsync<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Bind<MArr<TryOptionAsync<B>>, Arr<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Arr&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;Arr&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Arr&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<Arr<B>> Traverse< A, B>(this Arr<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Traverse<MTryOptionAsync<Arr<B>>, TryOptionAsync<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Arr&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;Arr&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Arr&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<Arr<B>> Traverse< A, B>(this Arr<TryOptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .TraverseAsync<MTryOptionAsync<Arr<B>>, TryOptionAsync<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Arr&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;Arr&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<Arr<A>> Sequence< A>(this Arr<TryOptionAsync<A>> ma) =>
            default(TransSyncAsync<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Sequence<MTryOptionAsync<Arr<A>>, TryOptionAsync<Arr<A>>, MArr<A>, Arr<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<TryOptionAsync<B>> MapT< A, B>(this Arr<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Map<MArr<TryOptionAsync<B>>, Arr<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<TryOptionAsync<B>> MapT< A, B>(this Arr<TryOptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .MapAsync<MArr<TryOptionAsync<B>>, Arr<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Arr<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Arr<TryOptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Arr<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Arr<TryOptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this Arr<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this Arr<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Arr&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this Arr<TryOptionAsync<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<TryOptionAsync<A>> FilterT< A>(this Arr<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Bind<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<TryOptionAsync<A>> FilterT< A>(this Arr<TryOptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .BindAsync<MArr<TryOptionAsync<A>>, Arr<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Arr<TryOptionAsync<A>> PlusT<NUM,  A>(this Arr<TryOptionAsync<A>> x, Arr<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Arr<TryOptionAsync<A>> SubtractT<NUM,  A>(this Arr<TryOptionAsync<A>> x, Arr<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Arr<TryOptionAsync<A>> ProductT<NUM,  A>(this Arr<TryOptionAsync<A>> x, Arr<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Arr<TryOptionAsync<A>> DivideT<NUM,  A>(this Arr<TryOptionAsync<A>> x, Arr<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Arr<TryOptionAsync<A>> AppendT<SEMI,  A>(this Arr<TryOptionAsync<A>> x, Arr<TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this Arr<TryOptionAsync<A>> x, Arr<TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this Arr<TryOptionAsync<A>> x, Arr<TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Arr&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Arr&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Arr<TryOptionAsync<B>> ApplyT< A, B>(this Func<A, B> fab, Arr<TryOptionAsync<A>> fa) =>
            default(ApplArr< TryOptionAsync<A>, TryOptionAsync<B>>).Apply(
                default(MArr< Func<TryOptionAsync<A>, TryOptionAsync<B>>>).Return(
                    (TryOptionAsync<A> a) => 
                        default(ApplTryOptionAsync< A, B>).Apply(
                            default(MTryOptionAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Arr&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Arr&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Arr&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Arr<TryOptionAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Arr<TryOptionAsync<A>> fa, Arr<TryOptionAsync<B>> fb) =>
            default(ApplArr< TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>).Apply(
                default(MArr< Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>).Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            default(ApplTryOptionAsync< A, B, C>).Apply(
                                default(MTryOptionAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`HashSet&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<TryOptionAsync<C>> SelectMany< A, B, C>(
            this HashSet<TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MHashSet<TryOptionAsync<B>>, HashSet<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MHashSet<TryOptionAsync<C>>, HashSet<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`HashSet&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<TryOptionAsync<C>> SelectMany< A, B, C>(
            this HashSet<TryOptionAsync<A>> ma,
            Func<A, Task<TryOptionAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MHashSet<TryOptionAsync<B>>, HashSet<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MHashSet<TryOptionAsync<C>>, HashSet<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`HashSet&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<TryOptionAsync<C>> SelectMany< A, B, C>(
            this HashSet<TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MHashSet<TryOptionAsync<B>>, HashSet<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MHashSet<TryOptionAsync<C>>, HashSet<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`HashSet&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<TryOptionAsync<C>> SelectMany< A, B, C>(
            this HashSet<TryOptionAsync<A>> ma,
            Func<A, Task<TryOptionAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MHashSet<TryOptionAsync<B>>, HashSet<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MHashSet<TryOptionAsync<C>>, HashSet<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<TryOptionAsync<A>> Where< A>(this HashSet<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).Bind<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<TryOptionAsync<A>> Where< A>(this HashSet<TryOptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).BindAsync<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<TryOptionAsync<B>> Select< A, B>(this HashSet<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Map<MHashSet<TryOptionAsync<B>>, HashSet<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `HashSet&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `HashSet&lt;TryOptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this HashSet<TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `HashSet&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `HashSet&lt;TryOptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this HashSet<TryOptionAsync<A>> ma) =>
            default(TransSyncAsync<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<TryOptionAsync<B>> BindT< A, B>(this HashSet<TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            default(TransSyncAsync<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Bind<MHashSet<TryOptionAsync<B>>, HashSet<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `HashSet&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;HashSet&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;HashSet&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<HashSet<B>> Traverse< A, B>(this HashSet<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Traverse<MTryOptionAsync<HashSet<B>>, TryOptionAsync<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `HashSet&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;HashSet&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;HashSet&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<HashSet<B>> Traverse< A, B>(this HashSet<TryOptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .TraverseAsync<MTryOptionAsync<HashSet<B>>, TryOptionAsync<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `HashSet&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;HashSet&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<HashSet<A>> Sequence< A>(this HashSet<TryOptionAsync<A>> ma) =>
            default(TransSyncAsync<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Sequence<MTryOptionAsync<HashSet<A>>, TryOptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<TryOptionAsync<B>> MapT< A, B>(this HashSet<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Map<MHashSet<TryOptionAsync<B>>, HashSet<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<TryOptionAsync<B>> MapT< A, B>(this HashSet<TryOptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .MapAsync<MHashSet<TryOptionAsync<B>>, HashSet<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this HashSet<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this HashSet<TryOptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this HashSet<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this HashSet<TryOptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this HashSet<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this HashSet<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `HashSet&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this HashSet<TryOptionAsync<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<TryOptionAsync<A>> FilterT< A>(this HashSet<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Bind<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<TryOptionAsync<A>> FilterT< A>(this HashSet<TryOptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .BindAsync<MHashSet<TryOptionAsync<A>>, HashSet<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<TryOptionAsync<A>> PlusT<NUM,  A>(this HashSet<TryOptionAsync<A>> x, HashSet<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<TryOptionAsync<A>> SubtractT<NUM,  A>(this HashSet<TryOptionAsync<A>> x, HashSet<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static HashSet<TryOptionAsync<A>> ProductT<NUM,  A>(this HashSet<TryOptionAsync<A>> x, HashSet<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static HashSet<TryOptionAsync<A>> DivideT<NUM,  A>(this HashSet<TryOptionAsync<A>> x, HashSet<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static HashSet<TryOptionAsync<A>> AppendT<SEMI,  A>(this HashSet<TryOptionAsync<A>> x, HashSet<TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this HashSet<TryOptionAsync<A>> x, HashSet<TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this HashSet<TryOptionAsync<A>> x, HashSet<TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `HashSet&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`HashSet&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static HashSet<TryOptionAsync<B>> ApplyT< A, B>(this Func<A, B> fab, HashSet<TryOptionAsync<A>> fa) =>
            default(ApplHashSet< TryOptionAsync<A>, TryOptionAsync<B>>).Apply(
                default(MHashSet< Func<TryOptionAsync<A>, TryOptionAsync<B>>>).Return(
                    (TryOptionAsync<A> a) => 
                        default(ApplTryOptionAsync< A, B>).Apply(
                            default(MTryOptionAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `HashSet&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `HashSet&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`HashSet&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static HashSet<TryOptionAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, HashSet<TryOptionAsync<A>> fa, HashSet<TryOptionAsync<B>> fb) =>
            default(ApplHashSet< TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>).Apply(
                default(MHashSet< Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>).Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            default(ApplTryOptionAsync< A, B, C>).Apply(
                                default(MTryOptionAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Lst&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<TryOptionAsync<C>> SelectMany< A, B, C>(
            this Lst<TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MLst<TryOptionAsync<B>>, Lst<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MLst<TryOptionAsync<C>>, Lst<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Lst&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<TryOptionAsync<C>> SelectMany< A, B, C>(
            this Lst<TryOptionAsync<A>> ma,
            Func<A, Task<TryOptionAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MLst<TryOptionAsync<B>>, Lst<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MLst<TryOptionAsync<C>>, Lst<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Lst&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<TryOptionAsync<C>> SelectMany< A, B, C>(
            this Lst<TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MLst<TryOptionAsync<B>>, Lst<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MLst<TryOptionAsync<C>>, Lst<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Lst&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<TryOptionAsync<C>> SelectMany< A, B, C>(
            this Lst<TryOptionAsync<A>> ma,
            Func<A, Task<TryOptionAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MLst<TryOptionAsync<B>>, Lst<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MLst<TryOptionAsync<C>>, Lst<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<TryOptionAsync<A>> Where< A>(this Lst<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).Bind<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<TryOptionAsync<A>> Where< A>(this Lst<TryOptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).BindAsync<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<TryOptionAsync<B>> Select< A, B>(this Lst<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Map<MLst<TryOptionAsync<B>>, Lst<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Lst&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Lst&lt;TryOptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this Lst<TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Lst&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Lst&lt;TryOptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this Lst<TryOptionAsync<A>> ma) =>
            default(TransSyncAsync<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<TryOptionAsync<B>> BindT< A, B>(this Lst<TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            default(TransSyncAsync<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Bind<MLst<TryOptionAsync<B>>, Lst<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Lst&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;Lst&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Lst&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<Lst<B>> Traverse< A, B>(this Lst<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Traverse<MTryOptionAsync<Lst<B>>, TryOptionAsync<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Lst&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;Lst&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Lst&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<Lst<B>> Traverse< A, B>(this Lst<TryOptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .TraverseAsync<MTryOptionAsync<Lst<B>>, TryOptionAsync<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Lst&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;Lst&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<Lst<A>> Sequence< A>(this Lst<TryOptionAsync<A>> ma) =>
            default(TransSyncAsync<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Sequence<MTryOptionAsync<Lst<A>>, TryOptionAsync<Lst<A>>, MLst<A>, Lst<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<TryOptionAsync<B>> MapT< A, B>(this Lst<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Map<MLst<TryOptionAsync<B>>, Lst<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<TryOptionAsync<B>> MapT< A, B>(this Lst<TryOptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .MapAsync<MLst<TryOptionAsync<B>>, Lst<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Lst<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Lst<TryOptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Lst<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Lst<TryOptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this Lst<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this Lst<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Lst&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this Lst<TryOptionAsync<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<TryOptionAsync<A>> FilterT< A>(this Lst<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Bind<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<TryOptionAsync<A>> FilterT< A>(this Lst<TryOptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .BindAsync<MLst<TryOptionAsync<A>>, Lst<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Lst<TryOptionAsync<A>> PlusT<NUM,  A>(this Lst<TryOptionAsync<A>> x, Lst<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Lst<TryOptionAsync<A>> SubtractT<NUM,  A>(this Lst<TryOptionAsync<A>> x, Lst<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Lst<TryOptionAsync<A>> ProductT<NUM,  A>(this Lst<TryOptionAsync<A>> x, Lst<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Lst<TryOptionAsync<A>> DivideT<NUM,  A>(this Lst<TryOptionAsync<A>> x, Lst<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Lst<TryOptionAsync<A>> AppendT<SEMI,  A>(this Lst<TryOptionAsync<A>> x, Lst<TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this Lst<TryOptionAsync<A>> x, Lst<TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this Lst<TryOptionAsync<A>> x, Lst<TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Lst&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Lst&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Lst<TryOptionAsync<B>> ApplyT< A, B>(this Func<A, B> fab, Lst<TryOptionAsync<A>> fa) =>
            default(ApplLst< TryOptionAsync<A>, TryOptionAsync<B>>).Apply(
                default(MLst< Func<TryOptionAsync<A>, TryOptionAsync<B>>>).Return(
                    (TryOptionAsync<A> a) => 
                        default(ApplTryOptionAsync< A, B>).Apply(
                            default(MTryOptionAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Lst&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Lst&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Lst&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Lst<TryOptionAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Lst<TryOptionAsync<A>> fa, Lst<TryOptionAsync<B>> fb) =>
            default(ApplLst< TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>).Apply(
                default(MLst< Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>).Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            default(ApplTryOptionAsync< A, B, C>).Apply(
                                default(MTryOptionAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Option&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Option<TryOptionAsync<C>> SelectMany< A, B, C>(
            this Option<TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MOption<TryOptionAsync<B>>, Option<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MOption<TryOptionAsync<C>>, Option<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Option&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Option<TryOptionAsync<C>> SelectMany< A, B, C>(
            this Option<TryOptionAsync<A>> ma,
            Func<A, Task<TryOptionAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MOption<TryOptionAsync<B>>, Option<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MOption<TryOptionAsync<C>>, Option<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Option&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Option<TryOptionAsync<C>> SelectMany< A, B, C>(
            this Option<TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MOption<TryOptionAsync<B>>, Option<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MOption<TryOptionAsync<C>>, Option<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Option&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Option<TryOptionAsync<C>> SelectMany< A, B, C>(
            this Option<TryOptionAsync<A>> ma,
            Func<A, Task<TryOptionAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MOption<TryOptionAsync<B>>, Option<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MOption<TryOptionAsync<C>>, Option<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<TryOptionAsync<A>> Where< A>(this Option<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).Bind<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<TryOptionAsync<A>> Where< A>(this Option<TryOptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).BindAsync<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<TryOptionAsync<B>> Select< A, B>(this Option<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Map<MOption<TryOptionAsync<B>>, Option<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Option&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Option&lt;TryOptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this Option<TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Option&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Option&lt;TryOptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this Option<TryOptionAsync<A>> ma) =>
            default(TransSyncAsync<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<TryOptionAsync<B>> BindT< A, B>(this Option<TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            default(TransSyncAsync<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Bind<MOption<TryOptionAsync<B>>, Option<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Option&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;Option&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Option&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<Option<B>> Traverse< A, B>(this Option<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Traverse<MTryOptionAsync<Option<B>>, TryOptionAsync<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Option&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;Option&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Option&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<Option<B>> Traverse< A, B>(this Option<TryOptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .TraverseAsync<MTryOptionAsync<Option<B>>, TryOptionAsync<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Option&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;Option&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<Option<A>> Sequence< A>(this Option<TryOptionAsync<A>> ma) =>
            default(TransSyncAsync<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Sequence<MTryOptionAsync<Option<A>>, TryOptionAsync<Option<A>>, MOption<A>, Option<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<TryOptionAsync<B>> MapT< A, B>(this Option<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Map<MOption<TryOptionAsync<B>>, Option<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<TryOptionAsync<B>> MapT< A, B>(this Option<TryOptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .MapAsync<MOption<TryOptionAsync<B>>, Option<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Option<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Option<TryOptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Option<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Option<TryOptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this Option<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this Option<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Option&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this Option<TryOptionAsync<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<TryOptionAsync<A>> FilterT< A>(this Option<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Bind<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<TryOptionAsync<A>> FilterT< A>(this Option<TryOptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .BindAsync<MOption<TryOptionAsync<A>>, Option<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Option<TryOptionAsync<A>> PlusT<NUM,  A>(this Option<TryOptionAsync<A>> x, Option<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Option<TryOptionAsync<A>> SubtractT<NUM,  A>(this Option<TryOptionAsync<A>> x, Option<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Option<TryOptionAsync<A>> ProductT<NUM,  A>(this Option<TryOptionAsync<A>> x, Option<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Option<TryOptionAsync<A>> DivideT<NUM,  A>(this Option<TryOptionAsync<A>> x, Option<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Option<TryOptionAsync<A>> AppendT<SEMI,  A>(this Option<TryOptionAsync<A>> x, Option<TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this Option<TryOptionAsync<A>> x, Option<TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this Option<TryOptionAsync<A>> x, Option<TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Option&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Option&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Option<TryOptionAsync<B>> ApplyT< A, B>(this Func<A, B> fab, Option<TryOptionAsync<A>> fa) =>
            default(ApplOption< TryOptionAsync<A>, TryOptionAsync<B>>).Apply(
                default(MOption< Func<TryOptionAsync<A>, TryOptionAsync<B>>>).Return(
                    (TryOptionAsync<A> a) => 
                        default(ApplTryOptionAsync< A, B>).Apply(
                            default(MTryOptionAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Option&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Option&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Option&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Option<TryOptionAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Option<TryOptionAsync<A>> fa, Option<TryOptionAsync<B>> fb) =>
            default(ApplOption< TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>).Apply(
                default(MOption< Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>).Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            default(ApplTryOptionAsync< A, B, C>).Apply(
                                default(MTryOptionAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionUnsafe&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<C>> SelectMany< A, B, C>(
            this OptionUnsafe<TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MOptionUnsafe<TryOptionAsync<B>>, OptionUnsafe<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MOptionUnsafe<TryOptionAsync<C>>, OptionUnsafe<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionUnsafe&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<C>> SelectMany< A, B, C>(
            this OptionUnsafe<TryOptionAsync<A>> ma,
            Func<A, Task<TryOptionAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MOptionUnsafe<TryOptionAsync<B>>, OptionUnsafe<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MOptionUnsafe<TryOptionAsync<C>>, OptionUnsafe<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionUnsafe&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<C>> SelectMany< A, B, C>(
            this OptionUnsafe<TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MOptionUnsafe<TryOptionAsync<B>>, OptionUnsafe<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MOptionUnsafe<TryOptionAsync<C>>, OptionUnsafe<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionUnsafe&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<C>> SelectMany< A, B, C>(
            this OptionUnsafe<TryOptionAsync<A>> ma,
            Func<A, Task<TryOptionAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MOptionUnsafe<TryOptionAsync<B>>, OptionUnsafe<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MOptionUnsafe<TryOptionAsync<C>>, OptionUnsafe<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<A>> Where< A>(this OptionUnsafe<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).Bind<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<A>> Where< A>(this OptionUnsafe<TryOptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).BindAsync<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<B>> Select< A, B>(this OptionUnsafe<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Map<MOptionUnsafe<TryOptionAsync<B>>, OptionUnsafe<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this OptionUnsafe<TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this OptionUnsafe<TryOptionAsync<A>> ma) =>
            default(TransSyncAsync<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<B>> BindT< A, B>(this OptionUnsafe<TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            default(TransSyncAsync<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Bind<MOptionUnsafe<TryOptionAsync<B>>, OptionUnsafe<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;OptionUnsafe&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;OptionUnsafe&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<B>> Traverse< A, B>(this OptionUnsafe<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Traverse<MTryOptionAsync<OptionUnsafe<B>>, TryOptionAsync<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;OptionUnsafe&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;OptionUnsafe&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<B>> Traverse< A, B>(this OptionUnsafe<TryOptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .TraverseAsync<MTryOptionAsync<OptionUnsafe<B>>, TryOptionAsync<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<A>> Sequence< A>(this OptionUnsafe<TryOptionAsync<A>> ma) =>
            default(TransSyncAsync<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Sequence<MTryOptionAsync<OptionUnsafe<A>>, TryOptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<B>> MapT< A, B>(this OptionUnsafe<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Map<MOptionUnsafe<TryOptionAsync<B>>, OptionUnsafe<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<B>> MapT< A, B>(this OptionUnsafe<TryOptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .MapAsync<MOptionUnsafe<TryOptionAsync<B>>, OptionUnsafe<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this OptionUnsafe<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this OptionUnsafe<TryOptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this OptionUnsafe<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this OptionUnsafe<TryOptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this OptionUnsafe<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this OptionUnsafe<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this OptionUnsafe<TryOptionAsync<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<A>> FilterT< A>(this OptionUnsafe<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Bind<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<A>> FilterT< A>(this OptionUnsafe<TryOptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .BindAsync<MOptionUnsafe<TryOptionAsync<A>>, OptionUnsafe<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<A>> PlusT<NUM,  A>(this OptionUnsafe<TryOptionAsync<A>> x, OptionUnsafe<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<A>> SubtractT<NUM,  A>(this OptionUnsafe<TryOptionAsync<A>> x, OptionUnsafe<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<A>> ProductT<NUM,  A>(this OptionUnsafe<TryOptionAsync<A>> x, OptionUnsafe<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<A>> DivideT<NUM,  A>(this OptionUnsafe<TryOptionAsync<A>> x, OptionUnsafe<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<A>> AppendT<SEMI,  A>(this OptionUnsafe<TryOptionAsync<A>> x, OptionUnsafe<TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this OptionUnsafe<TryOptionAsync<A>> x, OptionUnsafe<TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this OptionUnsafe<TryOptionAsync<A>> x, OptionUnsafe<TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`OptionUnsafe&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<B>> ApplyT< A, B>(this Func<A, B> fab, OptionUnsafe<TryOptionAsync<A>> fa) =>
            default(ApplOptionUnsafe< TryOptionAsync<A>, TryOptionAsync<B>>).Apply(
                default(MOptionUnsafe< Func<TryOptionAsync<A>, TryOptionAsync<B>>>).Return(
                    (TryOptionAsync<A> a) => 
                        default(ApplTryOptionAsync< A, B>).Apply(
                            default(MTryOptionAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `OptionUnsafe&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`OptionUnsafe&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionUnsafe<TryOptionAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, OptionUnsafe<TryOptionAsync<A>> fa, OptionUnsafe<TryOptionAsync<B>> fb) =>
            default(ApplOptionUnsafe< TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>).Apply(
                default(MOptionUnsafe< Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>).Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            default(ApplTryOptionAsync< A, B, C>).Apply(
                                default(MTryOptionAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Either&lt;L, TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, TryOptionAsync<C>> SelectMany<L, A, B, C>(
            this Either<L, TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MEither<L, TryOptionAsync<B>>, Either<L, TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MEither<L, TryOptionAsync<C>>, Either<L, TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Either&lt;L, TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, TryOptionAsync<C>> SelectMany<L, A, B, C>(
            this Either<L, TryOptionAsync<A>> ma,
            Func<A, Task<TryOptionAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MEither<L, TryOptionAsync<B>>, Either<L, TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MEither<L, TryOptionAsync<C>>, Either<L, TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Either&lt;L, TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, TryOptionAsync<C>> SelectMany<L, A, B, C>(
            this Either<L, TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MEither<L, TryOptionAsync<B>>, Either<L, TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MEither<L, TryOptionAsync<C>>, Either<L, TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Either&lt;L, TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, TryOptionAsync<C>> SelectMany<L, A, B, C>(
            this Either<L, TryOptionAsync<A>> ma,
            Func<A, Task<TryOptionAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MEither<L, TryOptionAsync<B>>, Either<L, TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MEither<L, TryOptionAsync<C>>, Either<L, TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, TryOptionAsync<A>> Where<L, A>(this Either<L, TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).Bind<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, TryOptionAsync<A>> Where<L, A>(this Either<L, TryOptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).BindAsync<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, TryOptionAsync<B>> Select<L, A, B>(this Either<L, TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Map<MEither<L, TryOptionAsync<B>>, Either<L, TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Either&lt;L, TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Either&lt;L, TryOptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA, L, A>(this Either<L, TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Either&lt;L, TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Either&lt;L, TryOptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT<L, A>(this Either<L, TryOptionAsync<A>> ma) =>
            default(TransSyncAsync<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either&lt;L, TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, TryOptionAsync<B>> BindT<L, A, B>(this Either<L, TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            default(TransSyncAsync<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Bind<MEither<L, TryOptionAsync<B>>, Either<L, TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Either&lt;L, TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;Either&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Either&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<Either<L, B>> Traverse<L, A, B>(this Either<L, TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Traverse<MTryOptionAsync<Either<L, B>>, TryOptionAsync<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Either&lt;L, TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;Either&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Either&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<Either<L, B>> Traverse<L, A, B>(this Either<L, TryOptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .TraverseAsync<MTryOptionAsync<Either<L, B>>, TryOptionAsync<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Either&lt;L, TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;Either&lt;L, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<Either<L, A>> Sequence<L, A>(this Either<L, TryOptionAsync<A>> ma) =>
            default(TransSyncAsync<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Sequence<MTryOptionAsync<Either<L, A>>, TryOptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, TryOptionAsync<B>> MapT<L, A, B>(this Either<L, TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Map<MEither<L, TryOptionAsync<B>>, Either<L, TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, TryOptionAsync<B>> MapT<L, A, B>(this Either<L, TryOptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .MapAsync<MEither<L, TryOptionAsync<B>>, Either<L, TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, L, A>(this Either<L, TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, L, A>(this Either<L, TryOptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, L, A>(this Either<L, TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, L, A>(this Either<L, TryOptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT<L, A>(this Either<L, TryOptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT<L, A>(this Either<L, TryOptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Either&lt;L, TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT<L, A>(this Either<L, TryOptionAsync<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, TryOptionAsync<A>> FilterT<L, A>(this Either<L, TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Bind<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, TryOptionAsync<A>> FilterT<L, A>(this Either<L, TryOptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .BindAsync<MEither<L, TryOptionAsync<A>>, Either<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, TryOptionAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, TryOptionAsync<A>> PlusT<NUM, L, A>(this Either<L, TryOptionAsync<A>> x, Either<L, TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, TryOptionAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, TryOptionAsync<A>> SubtractT<NUM, L, A>(this Either<L, TryOptionAsync<A>> x, Either<L, TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Either<L, TryOptionAsync<A>> ProductT<NUM, L, A>(this Either<L, TryOptionAsync<A>> x, Either<L, TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Either<L, TryOptionAsync<A>> DivideT<NUM, L, A>(this Either<L, TryOptionAsync<A>> x, Either<L, TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Either<L, TryOptionAsync<A>> AppendT<SEMI, L, A>(this Either<L, TryOptionAsync<A>> x, Either<L, TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD, L, A>(this Either<L, TryOptionAsync<A>> x, Either<L, TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ, L, A>(this Either<L, TryOptionAsync<A>> x, Either<L, TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Either&lt;L, TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Either&lt;L, TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Either<L, TryOptionAsync<B>> ApplyT<L, A, B>(this Func<A, B> fab, Either<L, TryOptionAsync<A>> fa) =>
            default(ApplEither<L, TryOptionAsync<A>, TryOptionAsync<B>>).Apply(
                default(MEither<L, Func<TryOptionAsync<A>, TryOptionAsync<B>>>).Return(
                    (TryOptionAsync<A> a) => 
                        default(ApplTryOptionAsync< A, B>).Apply(
                            default(MTryOptionAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Either&lt;L, TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Either&lt;L, TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Either&lt;L, TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Either<L, TryOptionAsync<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Either<L, TryOptionAsync<A>> fa, Either<L, TryOptionAsync<B>> fb) =>
            default(ApplEither<L, TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>).Apply(
                default(MEither<L, Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>).Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            default(ApplTryOptionAsync< A, B, C>).Apply(
                                default(MTryOptionAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`EitherUnsafe&lt;L, TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MEitherUnsafe<L, TryOptionAsync<B>>, EitherUnsafe<L, TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MEitherUnsafe<L, TryOptionAsync<C>>, EitherUnsafe<L, TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`EitherUnsafe&lt;L, TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, TryOptionAsync<A>> ma,
            Func<A, Task<TryOptionAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MEitherUnsafe<L, TryOptionAsync<B>>, EitherUnsafe<L, TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MEitherUnsafe<L, TryOptionAsync<C>>, EitherUnsafe<L, TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`EitherUnsafe&lt;L, TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MEitherUnsafe<L, TryOptionAsync<B>>, EitherUnsafe<L, TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MEitherUnsafe<L, TryOptionAsync<C>>, EitherUnsafe<L, TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`EitherUnsafe&lt;L, TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, TryOptionAsync<A>> ma,
            Func<A, Task<TryOptionAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MEitherUnsafe<L, TryOptionAsync<B>>, EitherUnsafe<L, TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MEitherUnsafe<L, TryOptionAsync<C>>, EitherUnsafe<L, TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<A>> Where<L, A>(this EitherUnsafe<L, TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).Bind<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<A>> Where<L, A>(this EitherUnsafe<L, TryOptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).BindAsync<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<B>> Select<L, A, B>(this EitherUnsafe<L, TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Map<MEitherUnsafe<L, TryOptionAsync<B>>, EitherUnsafe<L, TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA, L, A>(this EitherUnsafe<L, TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT<L, A>(this EitherUnsafe<L, TryOptionAsync<A>> ma) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<B>> BindT<L, A, B>(this EitherUnsafe<L, TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Bind<MEitherUnsafe<L, TryOptionAsync<B>>, EitherUnsafe<L, TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;EitherUnsafe&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;EitherUnsafe&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, B>> Traverse<L, A, B>(this EitherUnsafe<L, TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Traverse<MTryOptionAsync<EitherUnsafe<L, B>>, TryOptionAsync<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;EitherUnsafe&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;EitherUnsafe&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, B>> Traverse<L, A, B>(this EitherUnsafe<L, TryOptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .TraverseAsync<MTryOptionAsync<EitherUnsafe<L, B>>, TryOptionAsync<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, A>> Sequence<L, A>(this EitherUnsafe<L, TryOptionAsync<A>> ma) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Sequence<MTryOptionAsync<EitherUnsafe<L, A>>, TryOptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<B>> MapT<L, A, B>(this EitherUnsafe<L, TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Map<MEitherUnsafe<L, TryOptionAsync<B>>, EitherUnsafe<L, TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<B>> MapT<L, A, B>(this EitherUnsafe<L, TryOptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .MapAsync<MEitherUnsafe<L, TryOptionAsync<B>>, EitherUnsafe<L, TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, L, A>(this EitherUnsafe<L, TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, L, A>(this EitherUnsafe<L, TryOptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, L, A>(this EitherUnsafe<L, TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, L, A>(this EitherUnsafe<L, TryOptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT<L, A>(this EitherUnsafe<L, TryOptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT<L, A>(this EitherUnsafe<L, TryOptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT<L, A>(this EitherUnsafe<L, TryOptionAsync<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<A>> FilterT<L, A>(this EitherUnsafe<L, TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Bind<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<A>> FilterT<L, A>(this EitherUnsafe<L, TryOptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .BindAsync<MEitherUnsafe<L, TryOptionAsync<A>>, EitherUnsafe<L, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<A>> PlusT<NUM, L, A>(this EitherUnsafe<L, TryOptionAsync<A>> x, EitherUnsafe<L, TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<A>> SubtractT<NUM, L, A>(this EitherUnsafe<L, TryOptionAsync<A>> x, EitherUnsafe<L, TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<A>> ProductT<NUM, L, A>(this EitherUnsafe<L, TryOptionAsync<A>> x, EitherUnsafe<L, TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<A>> DivideT<NUM, L, A>(this EitherUnsafe<L, TryOptionAsync<A>> x, EitherUnsafe<L, TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<A>> AppendT<SEMI, L, A>(this EitherUnsafe<L, TryOptionAsync<A>> x, EitherUnsafe<L, TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD, L, A>(this EitherUnsafe<L, TryOptionAsync<A>> x, EitherUnsafe<L, TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ, L, A>(this EitherUnsafe<L, TryOptionAsync<A>> x, EitherUnsafe<L, TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`EitherUnsafe&lt;L, TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherUnsafe<L, TryOptionAsync<A>> fa) =>
            default(ApplEitherUnsafe<L, TryOptionAsync<A>, TryOptionAsync<B>>).Apply(
                default(MEitherUnsafe<L, Func<TryOptionAsync<A>, TryOptionAsync<B>>>).Return(
                    (TryOptionAsync<A> a) => 
                        default(ApplTryOptionAsync< A, B>).Apply(
                            default(MTryOptionAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `EitherUnsafe&lt;L, TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`EitherUnsafe&lt;L, TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherUnsafe<L, TryOptionAsync<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherUnsafe<L, TryOptionAsync<A>> fa, EitherUnsafe<L, TryOptionAsync<B>> fb) =>
            default(ApplEitherUnsafe<L, TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>).Apply(
                default(MEitherUnsafe<L, Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>).Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            default(ApplTryOptionAsync< A, B, C>).Apply(
                                default(MTryOptionAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Try&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Try<TryOptionAsync<C>> SelectMany< A, B, C>(
            this Try<TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MTry<TryOptionAsync<B>>, Try<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MTry<TryOptionAsync<C>>, Try<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Try&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Try<TryOptionAsync<C>> SelectMany< A, B, C>(
            this Try<TryOptionAsync<A>> ma,
            Func<A, Task<TryOptionAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MTry<TryOptionAsync<B>>, Try<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MTry<TryOptionAsync<C>>, Try<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Try&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Try<TryOptionAsync<C>> SelectMany< A, B, C>(
            this Try<TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MTry<TryOptionAsync<B>>, Try<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MTry<TryOptionAsync<C>>, Try<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Try&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Try<TryOptionAsync<C>> SelectMany< A, B, C>(
            this Try<TryOptionAsync<A>> ma,
            Func<A, Task<TryOptionAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MTry<TryOptionAsync<B>>, Try<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MTry<TryOptionAsync<C>>, Try<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<TryOptionAsync<A>> Where< A>(this Try<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).Bind<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<TryOptionAsync<A>> Where< A>(this Try<TryOptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).BindAsync<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<TryOptionAsync<B>> Select< A, B>(this Try<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Map<MTry<TryOptionAsync<B>>, Try<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Try&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Try&lt;TryOptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this Try<TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Try&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Try&lt;TryOptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this Try<TryOptionAsync<A>> ma) =>
            default(TransSyncAsync<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<TryOptionAsync<B>> BindT< A, B>(this Try<TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            default(TransSyncAsync<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Bind<MTry<TryOptionAsync<B>>, Try<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Try&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;Try&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Try&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<Try<B>> Traverse< A, B>(this Try<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Traverse<MTryOptionAsync<Try<B>>, TryOptionAsync<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Try&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;Try&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Try&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<Try<B>> Traverse< A, B>(this Try<TryOptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .TraverseAsync<MTryOptionAsync<Try<B>>, TryOptionAsync<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Try&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;Try&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<Try<A>> Sequence< A>(this Try<TryOptionAsync<A>> ma) =>
            default(TransSyncAsync<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Sequence<MTryOptionAsync<Try<A>>, TryOptionAsync<Try<A>>, MTry<A>, Try<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<TryOptionAsync<B>> MapT< A, B>(this Try<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Map<MTry<TryOptionAsync<B>>, Try<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<TryOptionAsync<B>> MapT< A, B>(this Try<TryOptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .MapAsync<MTry<TryOptionAsync<B>>, Try<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Try<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Try<TryOptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Try<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Try<TryOptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this Try<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this Try<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Try&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this Try<TryOptionAsync<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<TryOptionAsync<A>> FilterT< A>(this Try<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Bind<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<TryOptionAsync<A>> FilterT< A>(this Try<TryOptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .BindAsync<MTry<TryOptionAsync<A>>, Try<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Try<TryOptionAsync<A>> PlusT<NUM,  A>(this Try<TryOptionAsync<A>> x, Try<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Try<TryOptionAsync<A>> SubtractT<NUM,  A>(this Try<TryOptionAsync<A>> x, Try<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Try<TryOptionAsync<A>> ProductT<NUM,  A>(this Try<TryOptionAsync<A>> x, Try<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Try<TryOptionAsync<A>> DivideT<NUM,  A>(this Try<TryOptionAsync<A>> x, Try<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Try<TryOptionAsync<A>> AppendT<SEMI,  A>(this Try<TryOptionAsync<A>> x, Try<TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this Try<TryOptionAsync<A>> x, Try<TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this Try<TryOptionAsync<A>> x, Try<TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Try&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Try&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Try<TryOptionAsync<B>> ApplyT< A, B>(this Func<A, B> fab, Try<TryOptionAsync<A>> fa) =>
            default(ApplTry< TryOptionAsync<A>, TryOptionAsync<B>>).Apply(
                default(MTry< Func<TryOptionAsync<A>, TryOptionAsync<B>>>).Return(
                    (TryOptionAsync<A> a) => 
                        default(ApplTryOptionAsync< A, B>).Apply(
                            default(MTryOptionAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Try&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Try&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Try&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Try<TryOptionAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Try<TryOptionAsync<A>> fa, Try<TryOptionAsync<B>> fb) =>
            default(ApplTry< TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>).Apply(
                default(MTry< Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>).Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            default(ApplTryOptionAsync< A, B, C>).Apply(
                                default(MTryOptionAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOption&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<TryOptionAsync<C>> SelectMany< A, B, C>(
            this TryOption<TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MTryOption<TryOptionAsync<B>>, TryOption<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MTryOption<TryOptionAsync<C>>, TryOption<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOption&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<TryOptionAsync<C>> SelectMany< A, B, C>(
            this TryOption<TryOptionAsync<A>> ma,
            Func<A, Task<TryOptionAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MTryOption<TryOptionAsync<B>>, TryOption<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MTryOption<TryOptionAsync<C>>, TryOption<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOption&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<TryOptionAsync<C>> SelectMany< A, B, C>(
            this TryOption<TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MTryOption<TryOptionAsync<B>>, TryOption<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MTryOption<TryOptionAsync<C>>, TryOption<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOption&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<TryOptionAsync<C>> SelectMany< A, B, C>(
            this TryOption<TryOptionAsync<A>> ma,
            Func<A, Task<TryOptionAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MTryOption<TryOptionAsync<B>>, TryOption<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MTryOption<TryOptionAsync<C>>, TryOption<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<TryOptionAsync<A>> Where< A>(this TryOption<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).Bind<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<TryOptionAsync<A>> Where< A>(this TryOption<TryOptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).BindAsync<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<TryOptionAsync<B>> Select< A, B>(this TryOption<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Map<MTryOption<TryOptionAsync<B>>, TryOption<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOption&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOption&lt;TryOptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this TryOption<TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOption&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOption&lt;TryOptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this TryOption<TryOptionAsync<A>> ma) =>
            default(TransSyncAsync<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<TryOptionAsync<B>> BindT< A, B>(this TryOption<TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            default(TransSyncAsync<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Bind<MTryOption<TryOptionAsync<B>>, TryOption<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOption&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;TryOption&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;TryOption&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<TryOption<B>> Traverse< A, B>(this TryOption<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Traverse<MTryOptionAsync<TryOption<B>>, TryOptionAsync<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOption&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;TryOption&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;TryOption&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<TryOption<B>> Traverse< A, B>(this TryOption<TryOptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .TraverseAsync<MTryOptionAsync<TryOption<B>>, TryOptionAsync<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOption&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;TryOption&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<TryOption<A>> Sequence< A>(this TryOption<TryOptionAsync<A>> ma) =>
            default(TransSyncAsync<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Sequence<MTryOptionAsync<TryOption<A>>, TryOptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<TryOptionAsync<B>> MapT< A, B>(this TryOption<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Map<MTryOption<TryOptionAsync<B>>, TryOption<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<TryOptionAsync<B>> MapT< A, B>(this TryOption<TryOptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .MapAsync<MTryOption<TryOptionAsync<B>>, TryOption<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryOption<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryOption<TryOptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryOption<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryOption<TryOptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this TryOption<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this TryOption<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOption&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this TryOption<TryOptionAsync<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<TryOptionAsync<A>> FilterT< A>(this TryOption<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Bind<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<TryOptionAsync<A>> FilterT< A>(this TryOption<TryOptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .BindAsync<MTryOption<TryOptionAsync<A>>, TryOption<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<TryOptionAsync<A>> PlusT<NUM,  A>(this TryOption<TryOptionAsync<A>> x, TryOption<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<TryOptionAsync<A>> SubtractT<NUM,  A>(this TryOption<TryOptionAsync<A>> x, TryOption<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOption<TryOptionAsync<A>> ProductT<NUM,  A>(this TryOption<TryOptionAsync<A>> x, TryOption<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOption<TryOptionAsync<A>> DivideT<NUM,  A>(this TryOption<TryOptionAsync<A>> x, TryOption<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOption<TryOptionAsync<A>> AppendT<SEMI,  A>(this TryOption<TryOptionAsync<A>> x, TryOption<TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this TryOption<TryOptionAsync<A>> x, TryOption<TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this TryOption<TryOptionAsync<A>> x, TryOption<TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOption&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`TryOption&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOption<TryOptionAsync<B>> ApplyT< A, B>(this Func<A, B> fab, TryOption<TryOptionAsync<A>> fa) =>
            default(ApplTryOption< TryOptionAsync<A>, TryOptionAsync<B>>).Apply(
                default(MTryOption< Func<TryOptionAsync<A>, TryOptionAsync<B>>>).Return(
                    (TryOptionAsync<A> a) => 
                        default(ApplTryOptionAsync< A, B>).Apply(
                            default(MTryOptionAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOption&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryOption&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`TryOption&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOption<TryOptionAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOption<TryOptionAsync<A>> fa, TryOption<TryOptionAsync<B>> fb) =>
            default(ApplTryOption< TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>).Apply(
                default(MTryOption< Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>).Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            default(ApplTryOptionAsync< A, B, C>).Apply(
                                default(MTryOptionAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`IEnumerable&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<C>> SelectMany< A, B, C>(
            this IEnumerable<TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MEnumerable<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MEnumerable<TryOptionAsync<B>>, IEnumerable<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MEnumerable<TryOptionAsync<C>>, IEnumerable<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`IEnumerable&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<C>> SelectMany< A, B, C>(
            this IEnumerable<TryOptionAsync<A>> ma,
            Func<A, Task<TryOptionAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MEnumerable<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MEnumerable<TryOptionAsync<B>>, IEnumerable<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MEnumerable<TryOptionAsync<C>>, IEnumerable<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`IEnumerable&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<C>> SelectMany< A, B, C>(
            this IEnumerable<TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MEnumerable<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MEnumerable<TryOptionAsync<B>>, IEnumerable<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MEnumerable<TryOptionAsync<C>>, IEnumerable<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`IEnumerable&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<C>> SelectMany< A, B, C>(
            this IEnumerable<TryOptionAsync<A>> ma,
            Func<A, Task<TryOptionAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MEnumerable<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MEnumerable<TryOptionAsync<B>>, IEnumerable<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MEnumerable<TryOptionAsync<C>>, IEnumerable<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<A>> Where< A>(this IEnumerable<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MEnumerable<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).Bind<MEnumerable<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<A>> Where< A>(this IEnumerable<TryOptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MEnumerable<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).BindAsync<MEnumerable<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<B>> Select< A, B>(this IEnumerable<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MEnumerable<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Map<MEnumerable<TryOptionAsync<B>>, IEnumerable<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this IEnumerable<TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MEnumerable<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this IEnumerable<TryOptionAsync<A>> ma) =>
            default(TransSyncAsync<MEnumerable<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<B>> BindT< A, B>(this IEnumerable<TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            default(TransSyncAsync<MEnumerable<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Bind<MEnumerable<TryOptionAsync<B>>, IEnumerable<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;IEnumerable&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;IEnumerable&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<IEnumerable<B>> Traverse< A, B>(this IEnumerable<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MEnumerable<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Traverse<MTryOptionAsync<IEnumerable<B>>, TryOptionAsync<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;IEnumerable&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;IEnumerable&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<IEnumerable<B>> Traverse< A, B>(this IEnumerable<TryOptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MEnumerable<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .TraverseAsync<MTryOptionAsync<IEnumerable<B>>, TryOptionAsync<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;IEnumerable&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<IEnumerable<A>> Sequence< A>(this IEnumerable<TryOptionAsync<A>> ma) =>
            default(TransSyncAsync<MEnumerable<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Sequence<MTryOptionAsync<IEnumerable<A>>, TryOptionAsync<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<B>> MapT< A, B>(this IEnumerable<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MEnumerable<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Map<MEnumerable<TryOptionAsync<B>>, IEnumerable<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<B>> MapT< A, B>(this IEnumerable<TryOptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MEnumerable<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .MapAsync<MEnumerable<TryOptionAsync<B>>, IEnumerable<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this IEnumerable<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MEnumerable<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this IEnumerable<TryOptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MEnumerable<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this IEnumerable<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MEnumerable<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this IEnumerable<TryOptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MEnumerable<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this IEnumerable<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MEnumerable<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this IEnumerable<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MEnumerable<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this IEnumerable<TryOptionAsync<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MEnumerable<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<A>> FilterT< A>(this IEnumerable<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MEnumerable<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Bind<MEnumerable<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<A>> FilterT< A>(this IEnumerable<TryOptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MEnumerable<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .BindAsync<MEnumerable<TryOptionAsync<A>>, IEnumerable<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<A>> PlusT<NUM,  A>(this IEnumerable<TryOptionAsync<A>> x, IEnumerable<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<A>> SubtractT<NUM,  A>(this IEnumerable<TryOptionAsync<A>> x, IEnumerable<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<A>> ProductT<NUM,  A>(this IEnumerable<TryOptionAsync<A>> x, IEnumerable<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<A>> DivideT<NUM,  A>(this IEnumerable<TryOptionAsync<A>> x, IEnumerable<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<A>> AppendT<SEMI,  A>(this IEnumerable<TryOptionAsync<A>> x, IEnumerable<TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this IEnumerable<TryOptionAsync<A>> x, IEnumerable<TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this IEnumerable<TryOptionAsync<A>> x, IEnumerable<TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`IEnumerable&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<B>> ApplyT< A, B>(this Func<A, B> fab, IEnumerable<TryOptionAsync<A>> fa) =>
            default(ApplEnumerable< TryOptionAsync<A>, TryOptionAsync<B>>).Apply(
                default(MEnumerable< Func<TryOptionAsync<A>, TryOptionAsync<B>>>).Return(
                    (TryOptionAsync<A> a) => 
                        default(ApplTryOptionAsync< A, B>).Apply(
                            default(MTryOptionAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `IEnumerable&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`IEnumerable&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static IEnumerable<TryOptionAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, IEnumerable<TryOptionAsync<A>> fa, IEnumerable<TryOptionAsync<B>> fb) =>
            default(ApplEnumerable< TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>).Apply(
                default(MEnumerable< Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>).Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            default(ApplTryOptionAsync< A, B, C>).Apply(
                                default(MTryOptionAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Seq&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Seq<TryOptionAsync<C>> SelectMany< A, B, C>(
            this Seq<TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MSeq<TryOptionAsync<A>>, Seq<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MSeq<TryOptionAsync<B>>, Seq<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MSeq<TryOptionAsync<C>>, Seq<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Seq&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Seq<TryOptionAsync<C>> SelectMany< A, B, C>(
            this Seq<TryOptionAsync<A>> ma,
            Func<A, Task<TryOptionAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MSeq<TryOptionAsync<A>>, Seq<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MSeq<TryOptionAsync<B>>, Seq<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MSeq<TryOptionAsync<C>>, Seq<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Seq&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Seq<TryOptionAsync<C>> SelectMany< A, B, C>(
            this Seq<TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MSeq<TryOptionAsync<A>>, Seq<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MSeq<TryOptionAsync<B>>, Seq<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MSeq<TryOptionAsync<C>>, Seq<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Seq&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Seq<TryOptionAsync<C>> SelectMany< A, B, C>(
            this Seq<TryOptionAsync<A>> ma,
            Func<A, Task<TryOptionAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MSeq<TryOptionAsync<A>>, Seq<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MSeq<TryOptionAsync<B>>, Seq<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MSeq<TryOptionAsync<C>>, Seq<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<TryOptionAsync<A>> Where< A>(this Seq<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MSeq<TryOptionAsync<A>>, Seq<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).Bind<MSeq<TryOptionAsync<A>>, Seq<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<TryOptionAsync<A>> Where< A>(this Seq<TryOptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MSeq<TryOptionAsync<A>>, Seq<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).BindAsync<MSeq<TryOptionAsync<A>>, Seq<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<TryOptionAsync<B>> Select< A, B>(this Seq<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MSeq<TryOptionAsync<A>>, Seq<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Map<MSeq<TryOptionAsync<B>>, Seq<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Seq&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Seq&lt;TryOptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this Seq<TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MSeq<TryOptionAsync<A>>, Seq<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Seq&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Seq&lt;TryOptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this Seq<TryOptionAsync<A>> ma) =>
            default(TransSyncAsync<MSeq<TryOptionAsync<A>>, Seq<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Seq&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<TryOptionAsync<B>> BindT< A, B>(this Seq<TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            default(TransSyncAsync<MSeq<TryOptionAsync<A>>, Seq<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Bind<MSeq<TryOptionAsync<B>>, Seq<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Seq&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;Seq&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Seq&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<Seq<B>> Traverse< A, B>(this Seq<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MSeq<TryOptionAsync<A>>, Seq<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Traverse<MTryOptionAsync<Seq<B>>, TryOptionAsync<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Seq&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;Seq&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Seq&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<Seq<B>> Traverse< A, B>(this Seq<TryOptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MSeq<TryOptionAsync<A>>, Seq<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .TraverseAsync<MTryOptionAsync<Seq<B>>, TryOptionAsync<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Seq&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;Seq&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<Seq<A>> Sequence< A>(this Seq<TryOptionAsync<A>> ma) =>
            default(TransSyncAsync<MSeq<TryOptionAsync<A>>, Seq<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Sequence<MTryOptionAsync<Seq<A>>, TryOptionAsync<Seq<A>>, MSeq<A>, Seq<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<TryOptionAsync<B>> MapT< A, B>(this Seq<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MSeq<TryOptionAsync<A>>, Seq<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Map<MSeq<TryOptionAsync<B>>, Seq<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<TryOptionAsync<B>> MapT< A, B>(this Seq<TryOptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MSeq<TryOptionAsync<A>>, Seq<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .MapAsync<MSeq<TryOptionAsync<B>>, Seq<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Seq<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MSeq<TryOptionAsync<A>>, Seq<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Seq<TryOptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MSeq<TryOptionAsync<A>>, Seq<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Seq<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MSeq<TryOptionAsync<A>>, Seq<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Seq<TryOptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MSeq<TryOptionAsync<A>>, Seq<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this Seq<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MSeq<TryOptionAsync<A>>, Seq<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this Seq<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MSeq<TryOptionAsync<A>>, Seq<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Seq&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this Seq<TryOptionAsync<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MSeq<TryOptionAsync<A>>, Seq<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<TryOptionAsync<A>> FilterT< A>(this Seq<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MSeq<TryOptionAsync<A>>, Seq<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Bind<MSeq<TryOptionAsync<A>>, Seq<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<TryOptionAsync<A>> FilterT< A>(this Seq<TryOptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MSeq<TryOptionAsync<A>>, Seq<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .BindAsync<MSeq<TryOptionAsync<A>>, Seq<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Seq<TryOptionAsync<A>> PlusT<NUM,  A>(this Seq<TryOptionAsync<A>> x, Seq<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Seq<TryOptionAsync<A>> SubtractT<NUM,  A>(this Seq<TryOptionAsync<A>> x, Seq<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Seq<TryOptionAsync<A>> ProductT<NUM,  A>(this Seq<TryOptionAsync<A>> x, Seq<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Seq<TryOptionAsync<A>> DivideT<NUM,  A>(this Seq<TryOptionAsync<A>> x, Seq<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Seq<TryOptionAsync<A>> AppendT<SEMI,  A>(this Seq<TryOptionAsync<A>> x, Seq<TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this Seq<TryOptionAsync<A>> x, Seq<TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this Seq<TryOptionAsync<A>> x, Seq<TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Seq&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Seq&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Seq<TryOptionAsync<B>> ApplyT< A, B>(this Func<A, B> fab, Seq<TryOptionAsync<A>> fa) =>
            default(ApplSeq< TryOptionAsync<A>, TryOptionAsync<B>>).Apply(
                default(MSeq< Func<TryOptionAsync<A>, TryOptionAsync<B>>>).Return(
                    (TryOptionAsync<A> a) => 
                        default(ApplTryOptionAsync< A, B>).Apply(
                            default(MTryOptionAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Seq&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Seq&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Seq&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Seq<TryOptionAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Seq<TryOptionAsync<A>> fa, Seq<TryOptionAsync<B>> fb) =>
            default(ApplSeq< TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>).Apply(
                default(MSeq< Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>).Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            default(ApplTryOptionAsync< A, B, C>).Apply(
                                default(MTryOptionAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Set&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Set<TryOptionAsync<C>> SelectMany< A, B, C>(
            this Set<TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MSet<TryOptionAsync<B>>, Set<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MSet<TryOptionAsync<C>>, Set<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Set&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Set<TryOptionAsync<C>> SelectMany< A, B, C>(
            this Set<TryOptionAsync<A>> ma,
            Func<A, Task<TryOptionAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MSet<TryOptionAsync<B>>, Set<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MSet<TryOptionAsync<C>>, Set<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Set&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Set<TryOptionAsync<C>> SelectMany< A, B, C>(
            this Set<TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MSet<TryOptionAsync<B>>, Set<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MSet<TryOptionAsync<C>>, Set<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Set&lt;TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Set<TryOptionAsync<C>> SelectMany< A, B, C>(
            this Set<TryOptionAsync<A>> ma,
            Func<A, Task<TryOptionAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MSet<TryOptionAsync<B>>, Set<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MSet<TryOptionAsync<C>>, Set<TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<TryOptionAsync<A>> Where< A>(this Set<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).Bind<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<TryOptionAsync<A>> Where< A>(this Set<TryOptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).BindAsync<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<TryOptionAsync<B>> Select< A, B>(this Set<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Map<MSet<TryOptionAsync<B>>, Set<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Set&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Set&lt;TryOptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this Set<TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Set&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Set&lt;TryOptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this Set<TryOptionAsync<A>> ma) =>
            default(TransSyncAsync<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<TryOptionAsync<B>> BindT< A, B>(this Set<TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            default(TransSyncAsync<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Bind<MSet<TryOptionAsync<B>>, Set<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Set&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;Set&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Set&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<Set<B>> Traverse< A, B>(this Set<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Traverse<MTryOptionAsync<Set<B>>, TryOptionAsync<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Set&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;Set&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Set&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<Set<B>> Traverse< A, B>(this Set<TryOptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .TraverseAsync<MTryOptionAsync<Set<B>>, TryOptionAsync<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Set&lt;TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;Set&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<Set<A>> Sequence< A>(this Set<TryOptionAsync<A>> ma) =>
            default(TransSyncAsync<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Sequence<MTryOptionAsync<Set<A>>, TryOptionAsync<Set<A>>, MSet<A>, Set<A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<TryOptionAsync<B>> MapT< A, B>(this Set<TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Map<MSet<TryOptionAsync<B>>, Set<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<TryOptionAsync<B>> MapT< A, B>(this Set<TryOptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .MapAsync<MSet<TryOptionAsync<B>>, Set<TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Set<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Set<TryOptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Set<TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Set<TryOptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this Set<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this Set<TryOptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Set&lt;TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this Set<TryOptionAsync<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<TryOptionAsync<A>> FilterT< A>(this Set<TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Bind<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<TryOptionAsync<A>> FilterT< A>(this Set<TryOptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .BindAsync<MSet<TryOptionAsync<A>>, Set<TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Set<TryOptionAsync<A>> PlusT<NUM,  A>(this Set<TryOptionAsync<A>> x, Set<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Set<TryOptionAsync<A>> SubtractT<NUM,  A>(this Set<TryOptionAsync<A>> x, Set<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Set<TryOptionAsync<A>> ProductT<NUM,  A>(this Set<TryOptionAsync<A>> x, Set<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Set<TryOptionAsync<A>> DivideT<NUM,  A>(this Set<TryOptionAsync<A>> x, Set<TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Set<TryOptionAsync<A>> AppendT<SEMI,  A>(this Set<TryOptionAsync<A>> x, Set<TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this Set<TryOptionAsync<A>> x, Set<TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this Set<TryOptionAsync<A>> x, Set<TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Set&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Set&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Set<TryOptionAsync<B>> ApplyT< A, B>(this Func<A, B> fab, Set<TryOptionAsync<A>> fa) =>
            default(ApplSet< TryOptionAsync<A>, TryOptionAsync<B>>).Apply(
                default(MSet< Func<TryOptionAsync<A>, TryOptionAsync<B>>>).Return(
                    (TryOptionAsync<A> a) => 
                        default(ApplTryOptionAsync< A, B>).Apply(
                            default(MTryOptionAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Set&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Set&lt;TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Set&lt;TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Set<TryOptionAsync<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Set<TryOptionAsync<A>> fa, Set<TryOptionAsync<B>> fb) =>
            default(ApplSet< TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>).Apply(
                default(MSet< Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>).Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            default(ApplTryOptionAsync< A, B, C>).Apply(
                                default(MTryOptionAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Validation&lt;FAIL, TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Validation<FAIL, TryOptionAsync<C>> SelectMany<FAIL, A, B, C>(
            this Validation<FAIL, TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<B>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MValidation<FAIL, TryOptionAsync<A>>, Validation<FAIL, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MValidation<FAIL, TryOptionAsync<B>>, Validation<FAIL, TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MValidation<FAIL, TryOptionAsync<C>>, Validation<FAIL, TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Validation&lt;FAIL, TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Validation<FAIL, TryOptionAsync<C>> SelectMany<FAIL, A, B, C>(
            this Validation<FAIL, TryOptionAsync<A>> ma,
            Func<A, Task<TryOptionAsync<B>>> bind,
            Func<A, B, C> project) =>
            default(TransSyncAsync<MValidation<FAIL, TryOptionAsync<A>>, Validation<FAIL, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MValidation<FAIL, TryOptionAsync<B>>, Validation<FAIL, TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MValidation<FAIL, TryOptionAsync<C>>, Validation<FAIL, TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Validation&lt;FAIL, TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Validation<FAIL, TryOptionAsync<C>> SelectMany<FAIL, A, B, C>(
            this Validation<FAIL, TryOptionAsync<A>> ma,
            Func<A, TryOptionAsync<B>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MValidation<FAIL, TryOptionAsync<A>>, Validation<FAIL, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MValidation<FAIL, TryOptionAsync<B>>, Validation<FAIL, TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MValidation<FAIL, TryOptionAsync<C>>, Validation<FAIL, TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Validation&lt;FAIL, TryOptionAsync&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Validation<FAIL, TryOptionAsync<C>> SelectMany<FAIL, A, B, C>(
            this Validation<FAIL, TryOptionAsync<A>> ma,
            Func<A, Task<TryOptionAsync<B>>> bind,
            Func<A, B, Task<C>> project) =>
            default(TransSyncAsync<MValidation<FAIL, TryOptionAsync<A>>, Validation<FAIL, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .SelectManyAsync<MValidation<FAIL, TryOptionAsync<B>>, Validation<FAIL, TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B, MValidation<FAIL, TryOptionAsync<C>>, Validation<FAIL, TryOptionAsync<C>>, MTryOptionAsync<C>, TryOptionAsync<C>, C>(ma, bind, project);

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, TryOptionAsync<A>> Where<FAIL, A>(this Validation<FAIL, TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MValidation<FAIL, TryOptionAsync<A>>, Validation<FAIL, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).Bind<MValidation<FAIL, TryOptionAsync<A>>, Validation<FAIL, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                a => pred(a)
                    ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, TryOptionAsync<A>> Where<FAIL, A>(this Validation<FAIL, TryOptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MValidation<FAIL, TryOptionAsync<A>>, Validation<FAIL, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).BindAsync<MValidation<FAIL, TryOptionAsync<A>>, Validation<FAIL, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                async a => (await pred(a))
                    ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                    : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, TryOptionAsync<B>> Select<FAIL, A, B>(this Validation<FAIL, TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MValidation<FAIL, TryOptionAsync<A>>, Validation<FAIL, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Map<MValidation<FAIL, TryOptionAsync<B>>, Validation<FAIL, TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA, FAIL, A>(this Validation<FAIL, TryOptionAsync<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransSyncAsync<MValidation<FAIL, TryOptionAsync<A>>, Validation<FAIL, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT<FAIL, A>(this Validation<FAIL, TryOptionAsync<A>> ma) =>
            default(TransSyncAsync<MValidation<FAIL, TryOptionAsync<A>>, Validation<FAIL, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Validation&lt;FAIL, TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, TryOptionAsync<B>> BindT<FAIL, A, B>(this Validation<FAIL, TryOptionAsync<A>> ma, Func<A, TryOptionAsync<B>> f) =>
            default(TransSyncAsync<MValidation<FAIL, TryOptionAsync<A>>, Validation<FAIL, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Bind<MValidation<FAIL, TryOptionAsync<B>>, Validation<FAIL, TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;Validation&lt;FAIL, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Validation&lt;FAIL, B&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<Validation<FAIL, B>> Traverse<FAIL, A, B>(this Validation<FAIL, TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MValidation<FAIL, TryOptionAsync<A>>, Validation<FAIL, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Traverse<MTryOptionAsync<Validation<FAIL, B>>, TryOptionAsync<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;Validation&lt;FAIL, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Validation&lt;FAIL, B&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<Validation<FAIL, B>> Traverse<FAIL, A, B>(this Validation<FAIL, TryOptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MValidation<FAIL, TryOptionAsync<A>>, Validation<FAIL, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .TraverseAsync<MTryOptionAsync<Validation<FAIL, B>>, TryOptionAsync<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<FAIL, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static TryOptionAsync<Validation<FAIL, A>> Sequence<FAIL, A>(this Validation<FAIL, TryOptionAsync<A>> ma) =>
            default(TransSyncAsync<MValidation<FAIL, TryOptionAsync<A>>, Validation<FAIL, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Sequence<MTryOptionAsync<Validation<FAIL, A>>, TryOptionAsync<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>>(ma);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, TryOptionAsync<B>> MapT<FAIL, A, B>(this Validation<FAIL, TryOptionAsync<A>> ma, Func<A, B> f) =>
            default(TransSyncAsync<MValidation<FAIL, TryOptionAsync<A>>, Validation<FAIL, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Map<MValidation<FAIL, TryOptionAsync<B>>, Validation<FAIL, TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, TryOptionAsync<B>> MapT<FAIL, A, B>(this Validation<FAIL, TryOptionAsync<A>> ma, Func<A, Task<B>> f) =>
            default(TransSyncAsync<MValidation<FAIL, TryOptionAsync<A>>, Validation<FAIL, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .MapAsync<MValidation<FAIL, TryOptionAsync<B>>, Validation<FAIL, TryOptionAsync<B>>, MTryOptionAsync<B>, TryOptionAsync<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, FAIL, A>(this Validation<FAIL, TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MValidation<FAIL, TryOptionAsync<A>>, Validation<FAIL, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, FAIL, A>(this Validation<FAIL, TryOptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MValidation<FAIL, TryOptionAsync<A>>, Validation<FAIL, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldAsync(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, FAIL, A>(this Validation<FAIL, TryOptionAsync<A>> ma, S state, Func<S, A, S> f) =>
            default(TransSyncAsync<MValidation<FAIL, TryOptionAsync<A>>, Validation<FAIL, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, FAIL, A>(this Validation<FAIL, TryOptionAsync<A>> ma, S state, Func<S, A, Task<S>> f) =>
            default(TransSyncAsync<MValidation<FAIL, TryOptionAsync<A>>, Validation<FAIL, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .FoldBackAsync(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT<FAIL, A>(this Validation<FAIL, TryOptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MValidation<FAIL, TryOptionAsync<A>>, Validation<FAIL, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT<FAIL, A>(this Validation<FAIL, TryOptionAsync<A>> ma, Func<A, bool> f) =>
            default(TransSyncAsync<MValidation<FAIL, TryOptionAsync<A>>, Validation<FAIL, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT<FAIL, A>(this Validation<FAIL, TryOptionAsync<A>> ma, Action<A> f) =>
            default(TransSyncAsync<MValidation<FAIL, TryOptionAsync<A>>, Validation<FAIL, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, TryOptionAsync<A>> FilterT<FAIL, A>(this Validation<FAIL, TryOptionAsync<A>> ma, Func<A, bool> pred) =>
            default(TransSyncAsync<MValidation<FAIL, TryOptionAsync<A>>, Validation<FAIL, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .Bind<MValidation<FAIL, TryOptionAsync<A>>, Validation<FAIL, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, TryOptionAsync<A>> FilterT<FAIL, A>(this Validation<FAIL, TryOptionAsync<A>> ma, Func<A, Task<bool>> pred) =>
            default(TransSyncAsync<MValidation<FAIL, TryOptionAsync<A>>, Validation<FAIL, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>)
                .BindAsync<MValidation<FAIL, TryOptionAsync<A>>, Validation<FAIL, TryOptionAsync<A>>, MTryOptionAsync<A>, TryOptionAsync<A>, A>(ma, 
                    async a => (await pred(a))
                        ? default(MTryOptionAsync<A>).ReturnAsync(a.AsTask())
                        : default(MTryOptionAsync<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Validation<FAIL, TryOptionAsync<A>> PlusT<NUM, FAIL, A>(this Validation<FAIL, TryOptionAsync<A>> x, Validation<FAIL, TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Validation<FAIL, TryOptionAsync<A>> SubtractT<NUM, FAIL, A>(this Validation<FAIL, TryOptionAsync<A>> x, Validation<FAIL, TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Validation<FAIL, TryOptionAsync<A>> ProductT<NUM, FAIL, A>(this Validation<FAIL, TryOptionAsync<A>> x, Validation<FAIL, TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Validation<FAIL, TryOptionAsync<A>> DivideT<NUM, FAIL, A>(this Validation<FAIL, TryOptionAsync<A>> x, Validation<FAIL, TryOptionAsync<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Validation<FAIL, TryOptionAsync<A>> AppendT<SEMI, FAIL, A>(this Validation<FAIL, TryOptionAsync<A>> x, Validation<FAIL, TryOptionAsync<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD, FAIL, A>(this Validation<FAIL, TryOptionAsync<A>> x, Validation<FAIL, TryOptionAsync<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ, FAIL, A>(this Validation<FAIL, TryOptionAsync<A>> x, Validation<FAIL, TryOptionAsync<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Validation&lt;FAIL, TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Validation<FAIL, TryOptionAsync<B>> ApplyT<FAIL, A, B>(this Func<A, B> fab, Validation<FAIL, TryOptionAsync<A>> fa) =>
            default(ApplValidation<FAIL, TryOptionAsync<A>, TryOptionAsync<B>>).Apply(
                default(MValidation<FAIL, Func<TryOptionAsync<A>, TryOptionAsync<B>>>).Return(
                    (TryOptionAsync<A> a) => 
                        default(ApplTryOptionAsync< A, B>).Apply(
                            default(MTryOptionAsync< Func<A, B>>).ReturnAsync(fab.AsTask()), 
                            a)),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Validation&lt;FAIL, TryOptionAsync&lt;A&gt;&gt;`</param>
        /// <returns>`Validation&lt;FAIL, TryOptionAsync&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Validation<FAIL, TryOptionAsync<C>> ApplyT<FAIL, A, B, C>(this Func<A, B, C> fabc, Validation<FAIL, TryOptionAsync<A>> fa, Validation<FAIL, TryOptionAsync<B>> fb) =>
            default(ApplValidation<FAIL, TryOptionAsync<A>, TryOptionAsync<B>, TryOptionAsync<C>>).Apply(
                default(MValidation<FAIL, Func<TryOptionAsync<A>, Func<TryOptionAsync<B>, TryOptionAsync<C>>>>).Return(
                    (TryOptionAsync<A> a) =>
                        (TryOptionAsync<B> b) =>
                            default(ApplTryOptionAsync< A, B, C>).Apply(
                                default(MTryOptionAsync< Func<A, Func<B, C>>>).ReturnAsync(curry(fabc).AsTask()), a, b)), fa, fb);

    }
}
