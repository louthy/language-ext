// <auto-generated/>

using System;
using System.Text;
using System.Linq;
using System.Threading.Tasks;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using LanguageExt.TypeClasses;
using LanguageExt.ClassInstances;
using static LanguageExt.Prelude;

namespace LanguageExt
{
    /// <summary>
    /// Monad transformer for Arr, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class ArrT_Extensions
    {
        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Arr&lt;Arr&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<Arr<C>> SelectMany< A, B, C>(
            this Arr<Arr<A>> ma,
            Func<A, Arr<Arr<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MArr<Arr<C>>, Arr<Arr<C>>, MArr<C>, Arr<C>, C>(ma, a =>
                    SeqTrans<MArr<Arr<B>>, Arr<Arr<B>>, MArr<B>, Arr<B>, B>
                        .Inst.Bind<MArr<Arr<C>>, Arr<Arr<C>>, MArr<C>, Arr<C>, C>(bind(a), b =>
                            default(MArr<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;Arr&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<Arr<A>> Where< A>(this Arr<Arr<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Arr<B>> Select< A, B>(this Arr<Arr<A>> ma, Func<A, B> f) =>
            SeqTrans<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MArr<Arr<B>>, Arr<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Arr&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Arr&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Arr&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Arr<Arr<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Arr&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Arr&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Arr&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Arr<Arr<A>> ma) =>
            SeqTrans<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Arr<B>> BindT< A, B>(this Arr<Arr<A>> ma, Func<A, Arr<B>> f) =>
            SeqTrans<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MArr<Arr<B>>, Arr<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Arr<B>> BindT< A, B>(this Arr<Arr<A>> ma, Func<A, Arr<Arr<B>>> f) =>
            SeqTrans<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MArr<Arr<B>>, Arr<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Arr&lt;Arr&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Arr&lt;Arr&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;Arr&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Arr<Arr<B>> Traverse< A, B>(this Arr<Arr<A>> ma, Func<A, B> f) =>
            SeqTrans<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<Arr<B>>, Arr<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Arr&lt;Arr&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Arr&lt;Arr&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Arr<Arr<A>> Sequence< A>(this Arr<Arr<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Arr<B>> MapT< A, B>(this Arr<Arr<A>> ma, Func<A, B> f) =>
            SeqTrans<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MArr<Arr<B>>, Arr<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Arr<Arr<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Arr<Arr<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Arr<Arr<A>> ma, Func<A, bool> f) =>
            SeqTrans<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Arr<Arr<A>> ma, Func<A, bool> f) =>
            SeqTrans<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Arr&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Arr<Arr<A>> ma, Action<A> f) =>
            SeqTrans<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;Arr&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<Arr<A>> FilterT< A>(this Arr<Arr<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MArr<Arr<A>>, Arr<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Arr&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Arr<Arr<A>> PlusT<NUM,  A>(this Arr<Arr<A>> x, Arr<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Arr&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Arr<Arr<A>> SubtractT<NUM,  A>(this Arr<Arr<A>> x, Arr<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Arr<Arr<A>> ProductT<NUM,  A>(this Arr<Arr<A>> x, Arr<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Arr<Arr<A>> DivideT<NUM,  A>(this Arr<Arr<A>> x, Arr<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Arr<Arr<A>> AppendT<SEMI,  A>(this Arr<Arr<A>> x, Arr<Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Arr<Arr<A>> x, Arr<Arr<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Arr<Arr<A>> x, Arr<Arr<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Arr&lt;Arr&lt;A&gt;&gt;`</param>
        /// <returns>`Arr&lt;Arr&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Arr<Arr<B>> ApplyT< A, B>(this Func<A, B> fab, Arr<Arr<A>> fa) =>
            ApplArr< Arr<A>, Arr<B>>.Inst.Apply(
                 MArr< Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => ApplArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Arr&lt;Arr&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Arr&lt;Arr&lt;A&gt;&gt;`</param>
        /// <returns>`Arr&lt;Arr&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Arr<Arr<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Arr<Arr<A>> fa, Arr<Arr<B>> fb) =>
            ApplArr< Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MArr< Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            ApplArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`HashSet&lt;Arr&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<Arr<C>> SelectMany< A, B, C>(
            this HashSet<Arr<A>> ma,
            Func<A, HashSet<Arr<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MHashSet<Arr<C>>, HashSet<Arr<C>>, MArr<C>, Arr<C>, C>(ma, a =>
                    SeqTrans<MHashSet<Arr<B>>, HashSet<Arr<B>>, MArr<B>, Arr<B>, B>
                        .Inst.Bind<MHashSet<Arr<C>>, HashSet<Arr<C>>, MArr<C>, Arr<C>, C>(bind(a), b =>
                            default(MArr<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;Arr&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<Arr<A>> Where< A>(this HashSet<Arr<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Arr<B>> Select< A, B>(this HashSet<Arr<A>> ma, Func<A, B> f) =>
            SeqTrans<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MHashSet<Arr<B>>, HashSet<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `HashSet&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Arr&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `HashSet&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this HashSet<Arr<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `HashSet&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Arr&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `HashSet&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this HashSet<Arr<A>> ma) =>
            SeqTrans<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Arr<B>> BindT< A, B>(this HashSet<Arr<A>> ma, Func<A, Arr<B>> f) =>
            SeqTrans<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MHashSet<Arr<B>>, HashSet<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Arr<B>> BindT< A, B>(this HashSet<Arr<A>> ma, Func<A, HashSet<Arr<B>>> f) =>
            SeqTrans<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MHashSet<Arr<B>>, HashSet<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `HashSet&lt;Arr&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Arr&lt;HashSet&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;HashSet&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Arr<HashSet<B>> Traverse< A, B>(this HashSet<Arr<A>> ma, Func<A, B> f) =>
            SeqTrans<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<HashSet<B>>, Arr<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `HashSet&lt;Arr&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Arr&lt;HashSet&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Arr<HashSet<A>> Sequence< A>(this HashSet<Arr<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Arr<B>> MapT< A, B>(this HashSet<Arr<A>> ma, Func<A, B> f) =>
            SeqTrans<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MHashSet<Arr<B>>, HashSet<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this HashSet<Arr<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this HashSet<Arr<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this HashSet<Arr<A>> ma, Func<A, bool> f) =>
            SeqTrans<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this HashSet<Arr<A>> ma, Func<A, bool> f) =>
            SeqTrans<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `HashSet&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this HashSet<Arr<A>> ma, Action<A> f) =>
            SeqTrans<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;Arr&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<Arr<A>> FilterT< A>(this HashSet<Arr<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MHashSet<Arr<A>>, HashSet<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Arr&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<Arr<A>> PlusT<NUM,  A>(this HashSet<Arr<A>> x, HashSet<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Arr&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<Arr<A>> SubtractT<NUM,  A>(this HashSet<Arr<A>> x, HashSet<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static HashSet<Arr<A>> ProductT<NUM,  A>(this HashSet<Arr<A>> x, HashSet<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static HashSet<Arr<A>> DivideT<NUM,  A>(this HashSet<Arr<A>> x, HashSet<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static HashSet<Arr<A>> AppendT<SEMI,  A>(this HashSet<Arr<A>> x, HashSet<Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this HashSet<Arr<A>> x, HashSet<Arr<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this HashSet<Arr<A>> x, HashSet<Arr<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `HashSet&lt;Arr&lt;A&gt;&gt;`</param>
        /// <returns>`HashSet&lt;Arr&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static HashSet<Arr<B>> ApplyT< A, B>(this Func<A, B> fab, HashSet<Arr<A>> fa) =>
            ApplHashSet< Arr<A>, Arr<B>>.Inst.Apply(
                 MHashSet< Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => ApplArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `HashSet&lt;Arr&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `HashSet&lt;Arr&lt;A&gt;&gt;`</param>
        /// <returns>`HashSet&lt;Arr&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static HashSet<Arr<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, HashSet<Arr<A>> fa, HashSet<Arr<B>> fb) =>
            ApplHashSet< Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MHashSet< Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            ApplArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Lst&lt;Arr&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<Arr<C>> SelectMany< A, B, C>(
            this Lst<Arr<A>> ma,
            Func<A, Lst<Arr<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MLst<Arr<C>>, Lst<Arr<C>>, MArr<C>, Arr<C>, C>(ma, a =>
                    SeqTrans<MLst<Arr<B>>, Lst<Arr<B>>, MArr<B>, Arr<B>, B>
                        .Inst.Bind<MLst<Arr<C>>, Lst<Arr<C>>, MArr<C>, Arr<C>, C>(bind(a), b =>
                            default(MArr<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;Arr&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<Arr<A>> Where< A>(this Lst<Arr<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Arr<B>> Select< A, B>(this Lst<Arr<A>> ma, Func<A, B> f) =>
            SeqTrans<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MLst<Arr<B>>, Lst<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Lst&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Arr&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Lst&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Lst<Arr<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Lst&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Arr&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Lst&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Lst<Arr<A>> ma) =>
            SeqTrans<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Arr<B>> BindT< A, B>(this Lst<Arr<A>> ma, Func<A, Arr<B>> f) =>
            SeqTrans<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MLst<Arr<B>>, Lst<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Arr<B>> BindT< A, B>(this Lst<Arr<A>> ma, Func<A, Lst<Arr<B>>> f) =>
            SeqTrans<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MLst<Arr<B>>, Lst<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Lst&lt;Arr&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Arr&lt;Lst&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;Lst&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Arr<Lst<B>> Traverse< A, B>(this Lst<Arr<A>> ma, Func<A, B> f) =>
            SeqTrans<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<Lst<B>>, Arr<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Lst&lt;Arr&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Arr&lt;Lst&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Arr<Lst<A>> Sequence< A>(this Lst<Arr<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Arr<B>> MapT< A, B>(this Lst<Arr<A>> ma, Func<A, B> f) =>
            SeqTrans<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MLst<Arr<B>>, Lst<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Lst<Arr<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Lst<Arr<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Lst<Arr<A>> ma, Func<A, bool> f) =>
            SeqTrans<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Lst<Arr<A>> ma, Func<A, bool> f) =>
            SeqTrans<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Lst&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Lst<Arr<A>> ma, Action<A> f) =>
            SeqTrans<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;Arr&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<Arr<A>> FilterT< A>(this Lst<Arr<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MLst<Arr<A>>, Lst<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Arr&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Lst<Arr<A>> PlusT<NUM,  A>(this Lst<Arr<A>> x, Lst<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Arr&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Lst<Arr<A>> SubtractT<NUM,  A>(this Lst<Arr<A>> x, Lst<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Lst<Arr<A>> ProductT<NUM,  A>(this Lst<Arr<A>> x, Lst<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Lst<Arr<A>> DivideT<NUM,  A>(this Lst<Arr<A>> x, Lst<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Lst<Arr<A>> AppendT<SEMI,  A>(this Lst<Arr<A>> x, Lst<Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Lst<Arr<A>> x, Lst<Arr<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Lst<Arr<A>> x, Lst<Arr<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Lst&lt;Arr&lt;A&gt;&gt;`</param>
        /// <returns>`Lst&lt;Arr&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Lst<Arr<B>> ApplyT< A, B>(this Func<A, B> fab, Lst<Arr<A>> fa) =>
            ApplLst< Arr<A>, Arr<B>>.Inst.Apply(
                 MLst< Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => ApplArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Lst&lt;Arr&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Lst&lt;Arr&lt;A&gt;&gt;`</param>
        /// <returns>`Lst&lt;Arr&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Lst<Arr<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Lst<Arr<A>> fa, Lst<Arr<B>> fb) =>
            ApplLst< Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MLst< Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            ApplArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Option&lt;Arr&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Option<Arr<C>> SelectMany< A, B, C>(
            this Option<Arr<A>> ma,
            Func<A, Option<Arr<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MOption<Arr<C>>, Option<Arr<C>>, MArr<C>, Arr<C>, C>(ma, a =>
                    Trans<MOption<Arr<B>>, Option<Arr<B>>, MArr<B>, Arr<B>, B>
                        .Inst.Bind<MOption<Arr<C>>, Option<Arr<C>>, MArr<C>, Arr<C>, C>(bind(a), b =>
                            default(MArr<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;Arr&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<Arr<A>> Where< A>(this Option<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Arr<B>> Select< A, B>(this Option<Arr<A>> ma, Func<A, B> f) =>
            Trans<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MOption<Arr<B>>, Option<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Option&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Arr&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Option&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Option<Arr<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Option&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Arr&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Option&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Option<Arr<A>> ma) =>
            Trans<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Arr<B>> BindT< A, B>(this Option<Arr<A>> ma, Func<A, Arr<B>> f) =>
            Trans<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MOption<Arr<B>>, Option<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Arr<B>> BindT< A, B>(this Option<Arr<A>> ma, Func<A, Option<Arr<B>>> f) =>
            Trans<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MOption<Arr<B>>, Option<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Option&lt;Arr&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Arr&lt;Option&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;Option&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Arr<Option<B>> Traverse< A, B>(this Option<Arr<A>> ma, Func<A, B> f) =>
            SeqTrans<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<Option<B>>, Arr<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Option&lt;Arr&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Arr&lt;Option&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Arr<Option<A>> Sequence< A>(this Option<Arr<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Arr<B>> MapT< A, B>(this Option<Arr<A>> ma, Func<A, B> f) =>
            Trans<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MOption<Arr<B>>, Option<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Option<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Option<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Option<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Option<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Option&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Option<Arr<A>> ma, Action<A> f) =>
            Trans<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;Arr&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<Arr<A>> FilterT< A>(this Option<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MOption<Arr<A>>, Option<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Arr&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Option<Arr<A>> PlusT<NUM,  A>(this Option<Arr<A>> x, Option<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Arr&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Option<Arr<A>> SubtractT<NUM,  A>(this Option<Arr<A>> x, Option<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Option<Arr<A>> ProductT<NUM,  A>(this Option<Arr<A>> x, Option<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Option<Arr<A>> DivideT<NUM,  A>(this Option<Arr<A>> x, Option<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Option<Arr<A>> AppendT<SEMI,  A>(this Option<Arr<A>> x, Option<Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Option<Arr<A>> x, Option<Arr<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Option<Arr<A>> x, Option<Arr<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Option&lt;Arr&lt;A&gt;&gt;`</param>
        /// <returns>`Option&lt;Arr&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Option<Arr<B>> ApplyT< A, B>(this Func<A, B> fab, Option<Arr<A>> fa) =>
            ApplOption< Arr<A>, Arr<B>>.Inst.Apply(
                 MOption< Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => ApplArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Option&lt;Arr&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Option&lt;Arr&lt;A&gt;&gt;`</param>
        /// <returns>`Option&lt;Arr&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Option<Arr<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Option<Arr<A>> fa, Option<Arr<B>> fb) =>
            ApplOption< Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MOption< Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            ApplArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionUnsafe&lt;Arr&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<Arr<C>> SelectMany< A, B, C>(
            this OptionUnsafe<Arr<A>> ma,
            Func<A, OptionUnsafe<Arr<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MOptionUnsafe<Arr<C>>, OptionUnsafe<Arr<C>>, MArr<C>, Arr<C>, C>(ma, a =>
                    Trans<MOptionUnsafe<Arr<B>>, OptionUnsafe<Arr<B>>, MArr<B>, Arr<B>, B>
                        .Inst.Bind<MOptionUnsafe<Arr<C>>, OptionUnsafe<Arr<C>>, MArr<C>, Arr<C>, C>(bind(a), b =>
                            default(MArr<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;Arr&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<Arr<A>> Where< A>(this OptionUnsafe<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Arr<B>> Select< A, B>(this OptionUnsafe<Arr<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MOptionUnsafe<Arr<B>>, OptionUnsafe<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionUnsafe&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Arr&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionUnsafe&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this OptionUnsafe<Arr<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionUnsafe&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Arr&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionUnsafe&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this OptionUnsafe<Arr<A>> ma) =>
            Trans<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Arr<B>> BindT< A, B>(this OptionUnsafe<Arr<A>> ma, Func<A, Arr<B>> f) =>
            Trans<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MOptionUnsafe<Arr<B>>, OptionUnsafe<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Arr<B>> BindT< A, B>(this OptionUnsafe<Arr<A>> ma, Func<A, OptionUnsafe<Arr<B>>> f) =>
            Trans<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MOptionUnsafe<Arr<B>>, OptionUnsafe<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionUnsafe&lt;Arr&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Arr&lt;OptionUnsafe&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;OptionUnsafe&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Arr<OptionUnsafe<B>> Traverse< A, B>(this OptionUnsafe<Arr<A>> ma, Func<A, B> f) =>
            SeqTrans<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<OptionUnsafe<B>>, Arr<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionUnsafe&lt;Arr&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Arr&lt;OptionUnsafe&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Arr<OptionUnsafe<A>> Sequence< A>(this OptionUnsafe<Arr<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Arr<B>> MapT< A, B>(this OptionUnsafe<Arr<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MOptionUnsafe<Arr<B>>, OptionUnsafe<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this OptionUnsafe<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this OptionUnsafe<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this OptionUnsafe<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this OptionUnsafe<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionUnsafe&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this OptionUnsafe<Arr<A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;Arr&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<Arr<A>> FilterT< A>(this OptionUnsafe<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MOptionUnsafe<Arr<A>>, OptionUnsafe<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Arr&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<Arr<A>> PlusT<NUM,  A>(this OptionUnsafe<Arr<A>> x, OptionUnsafe<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Arr&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<Arr<A>> SubtractT<NUM,  A>(this OptionUnsafe<Arr<A>> x, OptionUnsafe<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionUnsafe<Arr<A>> ProductT<NUM,  A>(this OptionUnsafe<Arr<A>> x, OptionUnsafe<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionUnsafe<Arr<A>> DivideT<NUM,  A>(this OptionUnsafe<Arr<A>> x, OptionUnsafe<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionUnsafe<Arr<A>> AppendT<SEMI,  A>(this OptionUnsafe<Arr<A>> x, OptionUnsafe<Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this OptionUnsafe<Arr<A>> x, OptionUnsafe<Arr<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this OptionUnsafe<Arr<A>> x, OptionUnsafe<Arr<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe&lt;Arr&lt;A&gt;&gt;`</param>
        /// <returns>`OptionUnsafe&lt;Arr&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionUnsafe<Arr<B>> ApplyT< A, B>(this Func<A, B> fab, OptionUnsafe<Arr<A>> fa) =>
            ApplOptionUnsafe< Arr<A>, Arr<B>>.Inst.Apply(
                 MOptionUnsafe< Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => ApplArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe&lt;Arr&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `OptionUnsafe&lt;Arr&lt;A&gt;&gt;`</param>
        /// <returns>`OptionUnsafe&lt;Arr&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionUnsafe<Arr<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, OptionUnsafe<Arr<A>> fa, OptionUnsafe<Arr<B>> fb) =>
            ApplOptionUnsafe< Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MOptionUnsafe< Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            ApplArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Either&lt;L, Arr&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, Arr<C>> SelectMany<L, A, B, C>(
            this Either<L, Arr<A>> ma,
            Func<A, Either<L, Arr<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MEither<L, Arr<C>>, Either<L, Arr<C>>, MArr<C>, Arr<C>, C>(ma, a =>
                    Trans<MEither<L, Arr<B>>, Either<L, Arr<B>>, MArr<B>, Arr<B>, B>
                        .Inst.Bind<MEither<L, Arr<C>>, Either<L, Arr<C>>, MArr<C>, Arr<C>, C>(bind(a), b =>
                            default(MArr<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, Arr&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, Arr<A>> Where<L, A>(this Either<L, Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Arr<B>> Select<L, A, B>(this Either<L, Arr<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MEither<L, Arr<B>>, Either<L, Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Either&lt;L, Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Arr&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Either&lt;L, Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Either<L, Arr<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Either&lt;L, Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Arr&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Either&lt;L, Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this Either<L, Arr<A>> ma) =>
            Trans<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either&lt;L, Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Arr<B>> BindT<L, A, B>(this Either<L, Arr<A>> ma, Func<A, Arr<B>> f) =>
            Trans<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MEither<L, Arr<B>>, Either<L, Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either&lt;L, Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Arr<B>> BindT<L, A, B>(this Either<L, Arr<A>> ma, Func<A, Either<L, Arr<B>>> f) =>
            Trans<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MEither<L, Arr<B>>, Either<L, Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Either&lt;L, Arr&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Arr&lt;Either&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;Either&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static Arr<Either<L, B>> Traverse<L, A, B>(this Either<L, Arr<A>> ma, Func<A, B> f) =>
            SeqTrans<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<Either<L, B>>, Arr<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Either&lt;L, Arr&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Arr&lt;Either&lt;L, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static Arr<Either<L, A>> Sequence<L, A>(this Either<L, Arr<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Arr<B>> MapT<L, A, B>(this Either<L, Arr<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MEither<L, Arr<B>>, Either<L, Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Either<L, Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Either<L, Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Either<L, Arr<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Either<L, Arr<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Either&lt;L, Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Either<L, Arr<A>> ma, Action<A> f) =>
            Trans<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, Arr&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, Arr<A>> FilterT<L, A>(this Either<L, Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MEither<L, Arr<A>>, Either<L, Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Arr&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, Arr<A>> PlusT<NUM, L, A>(this Either<L, Arr<A>> x, Either<L, Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Arr&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, Arr<A>> SubtractT<NUM, L, A>(this Either<L, Arr<A>> x, Either<L, Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Arr&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Either<L, Arr<A>> ProductT<NUM, L, A>(this Either<L, Arr<A>> x, Either<L, Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Arr&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Either<L, Arr<A>> DivideT<NUM, L, A>(this Either<L, Arr<A>> x, Either<L, Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Arr&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Either<L, Arr<A>> AppendT<SEMI, L, A>(this Either<L, Arr<A>> x, Either<L, Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Either<L, Arr<A>> x, Either<L, Arr<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Arr&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Either<L, Arr<A>> x, Either<L, Arr<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Either&lt;L, Arr&lt;A&gt;&gt;`</param>
        /// <returns>`Either&lt;L, Arr&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Either<L, Arr<B>> ApplyT<L, A, B>(this Func<A, B> fab, Either<L, Arr<A>> fa) =>
            ApplEither<L, Arr<A>, Arr<B>>.Inst.Apply(
                 MEither<L, Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => ApplArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Either&lt;L, Arr&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Either&lt;L, Arr&lt;A&gt;&gt;`</param>
        /// <returns>`Either&lt;L, Arr&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Either<L, Arr<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Either<L, Arr<A>> fa, Either<L, Arr<B>> fb) =>
            ApplEither<L, Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MEither<L, Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            ApplArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`EitherUnsafe&lt;L, Arr&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, Arr<A>> ma,
            Func<A, EitherUnsafe<L, Arr<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Arr<C>>, EitherUnsafe<L, Arr<C>>, MArr<C>, Arr<C>, C>(ma, a =>
                    Trans<MEitherUnsafe<L, Arr<B>>, EitherUnsafe<L, Arr<B>>, MArr<B>, Arr<B>, B>
                        .Inst.Bind<MEitherUnsafe<L, Arr<C>>, EitherUnsafe<L, Arr<C>>, MArr<C>, Arr<C>, C>(bind(a), b =>
                            default(MArr<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, Arr&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<A>> Where<L, A>(this EitherUnsafe<L, Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<B>> Select<L, A, B>(this EitherUnsafe<L, Arr<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MEitherUnsafe<L, Arr<B>>, EitherUnsafe<L, Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherUnsafe&lt;L, Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Arr&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherUnsafe&lt;L, Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this EitherUnsafe<L, Arr<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherUnsafe&lt;L, Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Arr&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherUnsafe&lt;L, Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this EitherUnsafe<L, Arr<A>> ma) =>
            Trans<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<B>> BindT<L, A, B>(this EitherUnsafe<L, Arr<A>> ma, Func<A, Arr<B>> f) =>
            Trans<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Arr<B>>, EitherUnsafe<L, Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<B>> BindT<L, A, B>(this EitherUnsafe<L, Arr<A>> ma, Func<A, EitherUnsafe<L, Arr<B>>> f) =>
            Trans<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Arr<B>>, EitherUnsafe<L, Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `EitherUnsafe&lt;L, Arr&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Arr&lt;EitherUnsafe&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;EitherUnsafe&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, B>> Traverse<L, A, B>(this EitherUnsafe<L, Arr<A>> ma, Func<A, B> f) =>
            SeqTrans<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<EitherUnsafe<L, B>>, Arr<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `EitherUnsafe&lt;L, Arr&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Arr&lt;EitherUnsafe&lt;L, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, A>> Sequence<L, A>(this EitherUnsafe<L, Arr<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<B>> MapT<L, A, B>(this EitherUnsafe<L, Arr<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MEitherUnsafe<L, Arr<B>>, EitherUnsafe<L, Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this EitherUnsafe<L, Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this EitherUnsafe<L, Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this EitherUnsafe<L, Arr<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this EitherUnsafe<L, Arr<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherUnsafe&lt;L, Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this EitherUnsafe<L, Arr<A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, Arr&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<A>> FilterT<L, A>(this EitherUnsafe<L, Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Arr<A>>, EitherUnsafe<L, Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Arr&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<A>> PlusT<NUM, L, A>(this EitherUnsafe<L, Arr<A>> x, EitherUnsafe<L, Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Arr&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<A>> SubtractT<NUM, L, A>(this EitherUnsafe<L, Arr<A>> x, EitherUnsafe<L, Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Arr&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<A>> ProductT<NUM, L, A>(this EitherUnsafe<L, Arr<A>> x, EitherUnsafe<L, Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Arr&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<A>> DivideT<NUM, L, A>(this EitherUnsafe<L, Arr<A>> x, EitherUnsafe<L, Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Arr&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<A>> AppendT<SEMI, L, A>(this EitherUnsafe<L, Arr<A>> x, EitherUnsafe<L, Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this EitherUnsafe<L, Arr<A>> x, EitherUnsafe<L, Arr<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Arr&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this EitherUnsafe<L, Arr<A>> x, EitherUnsafe<L, Arr<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe&lt;L, Arr&lt;A&gt;&gt;`</param>
        /// <returns>`EitherUnsafe&lt;L, Arr&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherUnsafe<L, Arr<A>> fa) =>
            ApplEitherUnsafe<L, Arr<A>, Arr<B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => ApplArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe&lt;L, Arr&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `EitherUnsafe&lt;L, Arr&lt;A&gt;&gt;`</param>
        /// <returns>`EitherUnsafe&lt;L, Arr&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherUnsafe<L, Arr<A>> fa, EitherUnsafe<L, Arr<B>> fb) =>
            ApplEitherUnsafe<L, Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MEitherUnsafe<L, Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            ApplArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Try&lt;Arr&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Try<Arr<C>> SelectMany< A, B, C>(
            this Try<Arr<A>> ma,
            Func<A, Try<Arr<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MTry<Arr<C>>, Try<Arr<C>>, MArr<C>, Arr<C>, C>(ma, a =>
                    Trans<MTry<Arr<B>>, Try<Arr<B>>, MArr<B>, Arr<B>, B>
                        .Inst.Bind<MTry<Arr<C>>, Try<Arr<C>>, MArr<C>, Arr<C>, C>(bind(a), b =>
                            default(MArr<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;Arr&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<Arr<A>> Where< A>(this Try<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Arr<B>> Select< A, B>(this Try<Arr<A>> ma, Func<A, B> f) =>
            Trans<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MTry<Arr<B>>, Try<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Try&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Arr&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Try&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Try<Arr<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Try&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Arr&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Try&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Try<Arr<A>> ma) =>
            Trans<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Arr<B>> BindT< A, B>(this Try<Arr<A>> ma, Func<A, Arr<B>> f) =>
            Trans<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MTry<Arr<B>>, Try<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Arr<B>> BindT< A, B>(this Try<Arr<A>> ma, Func<A, Try<Arr<B>>> f) =>
            Trans<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MTry<Arr<B>>, Try<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Try&lt;Arr&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Arr&lt;Try&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;Try&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Arr<Try<B>> Traverse< A, B>(this Try<Arr<A>> ma, Func<A, B> f) =>
            SeqTrans<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<Try<B>>, Arr<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Try&lt;Arr&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Arr&lt;Try&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Arr<Try<A>> Sequence< A>(this Try<Arr<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Arr<B>> MapT< A, B>(this Try<Arr<A>> ma, Func<A, B> f) =>
            Trans<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MTry<Arr<B>>, Try<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Try<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Try<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Try<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Try<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Try&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Try<Arr<A>> ma, Action<A> f) =>
            Trans<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;Arr&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<Arr<A>> FilterT< A>(this Try<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MTry<Arr<A>>, Try<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Arr&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Try<Arr<A>> PlusT<NUM,  A>(this Try<Arr<A>> x, Try<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Arr&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Try<Arr<A>> SubtractT<NUM,  A>(this Try<Arr<A>> x, Try<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Try<Arr<A>> ProductT<NUM,  A>(this Try<Arr<A>> x, Try<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Try<Arr<A>> DivideT<NUM,  A>(this Try<Arr<A>> x, Try<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Try<Arr<A>> AppendT<SEMI,  A>(this Try<Arr<A>> x, Try<Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Try<Arr<A>> x, Try<Arr<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Try<Arr<A>> x, Try<Arr<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Try&lt;Arr&lt;A&gt;&gt;`</param>
        /// <returns>`Try&lt;Arr&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Try<Arr<B>> ApplyT< A, B>(this Func<A, B> fab, Try<Arr<A>> fa) =>
            ApplTry< Arr<A>, Arr<B>>.Inst.Apply(
                 MTry< Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => ApplArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Try&lt;Arr&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Try&lt;Arr&lt;A&gt;&gt;`</param>
        /// <returns>`Try&lt;Arr&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Try<Arr<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Try<Arr<A>> fa, Try<Arr<B>> fb) =>
            ApplTry< Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MTry< Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            ApplArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOption&lt;Arr&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<Arr<C>> SelectMany< A, B, C>(
            this TryOption<Arr<A>> ma,
            Func<A, TryOption<Arr<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MTryOption<Arr<C>>, TryOption<Arr<C>>, MArr<C>, Arr<C>, C>(ma, a =>
                    Trans<MTryOption<Arr<B>>, TryOption<Arr<B>>, MArr<B>, Arr<B>, B>
                        .Inst.Bind<MTryOption<Arr<C>>, TryOption<Arr<C>>, MArr<C>, Arr<C>, C>(bind(a), b =>
                            default(MArr<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;Arr&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<Arr<A>> Where< A>(this TryOption<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Arr<B>> Select< A, B>(this TryOption<Arr<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MTryOption<Arr<B>>, TryOption<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOption&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Arr&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOption&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryOption<Arr<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOption&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Arr&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOption&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this TryOption<Arr<A>> ma) =>
            Trans<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Arr<B>> BindT< A, B>(this TryOption<Arr<A>> ma, Func<A, Arr<B>> f) =>
            Trans<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MTryOption<Arr<B>>, TryOption<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Arr<B>> BindT< A, B>(this TryOption<Arr<A>> ma, Func<A, TryOption<Arr<B>>> f) =>
            Trans<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MTryOption<Arr<B>>, TryOption<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOption&lt;Arr&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Arr&lt;TryOption&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;TryOption&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Arr<TryOption<B>> Traverse< A, B>(this TryOption<Arr<A>> ma, Func<A, B> f) =>
            SeqTrans<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<TryOption<B>>, Arr<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOption&lt;Arr&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Arr&lt;TryOption&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Arr<TryOption<A>> Sequence< A>(this TryOption<Arr<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Arr<B>> MapT< A, B>(this TryOption<Arr<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MTryOption<Arr<B>>, TryOption<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryOption<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryOption<Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryOption<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryOption<Arr<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOption&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryOption<Arr<A>> ma, Action<A> f) =>
            Trans<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;Arr&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<Arr<A>> FilterT< A>(this TryOption<Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MTryOption<Arr<A>>, TryOption<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Arr&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<Arr<A>> PlusT<NUM,  A>(this TryOption<Arr<A>> x, TryOption<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Arr&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<Arr<A>> SubtractT<NUM,  A>(this TryOption<Arr<A>> x, TryOption<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOption<Arr<A>> ProductT<NUM,  A>(this TryOption<Arr<A>> x, TryOption<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOption<Arr<A>> DivideT<NUM,  A>(this TryOption<Arr<A>> x, TryOption<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOption<Arr<A>> AppendT<SEMI,  A>(this TryOption<Arr<A>> x, TryOption<Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryOption<Arr<A>> x, TryOption<Arr<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryOption<Arr<A>> x, TryOption<Arr<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOption&lt;Arr&lt;A&gt;&gt;`</param>
        /// <returns>`TryOption&lt;Arr&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOption<Arr<B>> ApplyT< A, B>(this Func<A, B> fab, TryOption<Arr<A>> fa) =>
            ApplTryOption< Arr<A>, Arr<B>>.Inst.Apply(
                 MTryOption< Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => ApplArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOption&lt;Arr&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryOption&lt;Arr&lt;A&gt;&gt;`</param>
        /// <returns>`TryOption&lt;Arr&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOption<Arr<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOption<Arr<A>> fa, TryOption<Arr<B>> fb) =>
            ApplTryOption< Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MTryOption< Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            ApplArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`IEnumerable&lt;Arr&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<Arr<C>> SelectMany< A, B, C>(
            this IEnumerable<Arr<A>> ma,
            Func<A, IEnumerable<Arr<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MEnumerable<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MEnumerable<Arr<C>>, IEnumerable<Arr<C>>, MArr<C>, Arr<C>, C>(ma, a =>
                    SeqTrans<MEnumerable<Arr<B>>, IEnumerable<Arr<B>>, MArr<B>, Arr<B>, B>
                        .Inst.Bind<MEnumerable<Arr<C>>, IEnumerable<Arr<C>>, MArr<C>, Arr<C>, C>(bind(a), b =>
                            default(MArr<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;Arr&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<Arr<A>> Where< A>(this IEnumerable<Arr<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MEnumerable<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MEnumerable<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Arr<B>> Select< A, B>(this IEnumerable<Arr<A>> ma, Func<A, B> f) =>
            SeqTrans<MEnumerable<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MEnumerable<Arr<B>>, IEnumerable<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `IEnumerable&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Arr&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `IEnumerable&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this IEnumerable<Arr<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MEnumerable<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `IEnumerable&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Arr&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `IEnumerable&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this IEnumerable<Arr<A>> ma) =>
            SeqTrans<MEnumerable<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Arr<B>> BindT< A, B>(this IEnumerable<Arr<A>> ma, Func<A, Arr<B>> f) =>
            SeqTrans<MEnumerable<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MEnumerable<Arr<B>>, IEnumerable<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Arr<B>> BindT< A, B>(this IEnumerable<Arr<A>> ma, Func<A, IEnumerable<Arr<B>>> f) =>
            SeqTrans<MEnumerable<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MEnumerable<Arr<B>>, IEnumerable<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `IEnumerable&lt;Arr&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Arr&lt;IEnumerable&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;IEnumerable&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Arr<IEnumerable<B>> Traverse< A, B>(this IEnumerable<Arr<A>> ma, Func<A, B> f) =>
            SeqTrans<MEnumerable<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<IEnumerable<B>>, Arr<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `IEnumerable&lt;Arr&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Arr&lt;IEnumerable&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Arr<IEnumerable<A>> Sequence< A>(this IEnumerable<Arr<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Arr<B>> MapT< A, B>(this IEnumerable<Arr<A>> ma, Func<A, B> f) =>
            SeqTrans<MEnumerable<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MEnumerable<Arr<B>>, IEnumerable<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this IEnumerable<Arr<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MEnumerable<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this IEnumerable<Arr<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MEnumerable<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this IEnumerable<Arr<A>> ma, Func<A, bool> f) =>
            SeqTrans<MEnumerable<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this IEnumerable<Arr<A>> ma, Func<A, bool> f) =>
            SeqTrans<MEnumerable<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `IEnumerable&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this IEnumerable<Arr<A>> ma, Action<A> f) =>
            SeqTrans<MEnumerable<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;Arr&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<Arr<A>> FilterT< A>(this IEnumerable<Arr<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MEnumerable<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MEnumerable<Arr<A>>, IEnumerable<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Arr&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<Arr<A>> PlusT<NUM,  A>(this IEnumerable<Arr<A>> x, IEnumerable<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Arr&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<Arr<A>> SubtractT<NUM,  A>(this IEnumerable<Arr<A>> x, IEnumerable<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static IEnumerable<Arr<A>> ProductT<NUM,  A>(this IEnumerable<Arr<A>> x, IEnumerable<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static IEnumerable<Arr<A>> DivideT<NUM,  A>(this IEnumerable<Arr<A>> x, IEnumerable<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static IEnumerable<Arr<A>> AppendT<SEMI,  A>(this IEnumerable<Arr<A>> x, IEnumerable<Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this IEnumerable<Arr<A>> x, IEnumerable<Arr<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this IEnumerable<Arr<A>> x, IEnumerable<Arr<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `IEnumerable&lt;Arr&lt;A&gt;&gt;`</param>
        /// <returns>`IEnumerable&lt;Arr&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static IEnumerable<Arr<B>> ApplyT< A, B>(this Func<A, B> fab, IEnumerable<Arr<A>> fa) =>
            ApplEnumerable< Arr<A>, Arr<B>>.Inst.Apply(
                 MEnumerable< Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => ApplArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `IEnumerable&lt;Arr&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `IEnumerable&lt;Arr&lt;A&gt;&gt;`</param>
        /// <returns>`IEnumerable&lt;Arr&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static IEnumerable<Arr<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, IEnumerable<Arr<A>> fa, IEnumerable<Arr<B>> fb) =>
            ApplEnumerable< Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MEnumerable< Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            ApplArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Seq&lt;Arr&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Seq<Arr<C>> SelectMany< A, B, C>(
            this Seq<Arr<A>> ma,
            Func<A, Seq<Arr<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MSeq<Arr<A>>, Seq<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MSeq<Arr<C>>, Seq<Arr<C>>, MArr<C>, Arr<C>, C>(ma, a =>
                    SeqTrans<MSeq<Arr<B>>, Seq<Arr<B>>, MArr<B>, Arr<B>, B>
                        .Inst.Bind<MSeq<Arr<C>>, Seq<Arr<C>>, MArr<C>, Arr<C>, C>(bind(a), b =>
                            default(MArr<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;Arr&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<Arr<A>> Where< A>(this Seq<Arr<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSeq<Arr<A>>, Seq<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MSeq<Arr<A>>, Seq<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<Arr<B>> Select< A, B>(this Seq<Arr<A>> ma, Func<A, B> f) =>
            SeqTrans<MSeq<Arr<A>>, Seq<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MSeq<Arr<B>>, Seq<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Seq&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Arr&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Seq&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Seq<Arr<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MSeq<Arr<A>>, Seq<Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Seq&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Arr&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Seq&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Seq<Arr<A>> ma) =>
            SeqTrans<MSeq<Arr<A>>, Seq<Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Seq&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<Arr<B>> BindT< A, B>(this Seq<Arr<A>> ma, Func<A, Arr<B>> f) =>
            SeqTrans<MSeq<Arr<A>>, Seq<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MSeq<Arr<B>>, Seq<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Seq&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<Arr<B>> BindT< A, B>(this Seq<Arr<A>> ma, Func<A, Seq<Arr<B>>> f) =>
            SeqTrans<MSeq<Arr<A>>, Seq<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MSeq<Arr<B>>, Seq<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Seq&lt;Arr&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Arr&lt;Seq&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;Seq&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Arr<Seq<B>> Traverse< A, B>(this Seq<Arr<A>> ma, Func<A, B> f) =>
            SeqTrans<MSeq<Arr<A>>, Seq<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<Seq<B>>, Arr<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Seq&lt;Arr&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Arr&lt;Seq&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Arr<Seq<A>> Sequence< A>(this Seq<Arr<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<Arr<B>> MapT< A, B>(this Seq<Arr<A>> ma, Func<A, B> f) =>
            SeqTrans<MSeq<Arr<A>>, Seq<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MSeq<Arr<B>>, Seq<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Seq<Arr<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSeq<Arr<A>>, Seq<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Seq<Arr<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSeq<Arr<A>>, Seq<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Seq<Arr<A>> ma, Func<A, bool> f) =>
            SeqTrans<MSeq<Arr<A>>, Seq<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Seq<Arr<A>> ma, Func<A, bool> f) =>
            SeqTrans<MSeq<Arr<A>>, Seq<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Seq&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Seq<Arr<A>> ma, Action<A> f) =>
            SeqTrans<MSeq<Arr<A>>, Seq<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;Arr&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<Arr<A>> FilterT< A>(this Seq<Arr<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSeq<Arr<A>>, Seq<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MSeq<Arr<A>>, Seq<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Arr&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Seq<Arr<A>> PlusT<NUM,  A>(this Seq<Arr<A>> x, Seq<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Arr&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Seq<Arr<A>> SubtractT<NUM,  A>(this Seq<Arr<A>> x, Seq<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Seq<Arr<A>> ProductT<NUM,  A>(this Seq<Arr<A>> x, Seq<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Seq<Arr<A>> DivideT<NUM,  A>(this Seq<Arr<A>> x, Seq<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Seq<Arr<A>> AppendT<SEMI,  A>(this Seq<Arr<A>> x, Seq<Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Seq<Arr<A>> x, Seq<Arr<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Seq<Arr<A>> x, Seq<Arr<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Seq&lt;Arr&lt;A&gt;&gt;`</param>
        /// <returns>`Seq&lt;Arr&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Seq<Arr<B>> ApplyT< A, B>(this Func<A, B> fab, Seq<Arr<A>> fa) =>
            ApplSeq< Arr<A>, Arr<B>>.Inst.Apply(
                 MSeq< Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => ApplArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Seq&lt;Arr&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Seq&lt;Arr&lt;A&gt;&gt;`</param>
        /// <returns>`Seq&lt;Arr&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Seq<Arr<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Seq<Arr<A>> fa, Seq<Arr<B>> fb) =>
            ApplSeq< Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MSeq< Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            ApplArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Set&lt;Arr&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Set<Arr<C>> SelectMany< A, B, C>(
            this Set<Arr<A>> ma,
            Func<A, Set<Arr<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MSet<Arr<C>>, Set<Arr<C>>, MArr<C>, Arr<C>, C>(ma, a =>
                    SeqTrans<MSet<Arr<B>>, Set<Arr<B>>, MArr<B>, Arr<B>, B>
                        .Inst.Bind<MSet<Arr<C>>, Set<Arr<C>>, MArr<C>, Arr<C>, C>(bind(a), b =>
                            default(MArr<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;Arr&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<Arr<A>> Where< A>(this Set<Arr<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Arr<B>> Select< A, B>(this Set<Arr<A>> ma, Func<A, B> f) =>
            SeqTrans<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MSet<Arr<B>>, Set<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Set&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Arr&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Set&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Set<Arr<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Set&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Arr&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Set&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Set<Arr<A>> ma) =>
            SeqTrans<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Arr<B>> BindT< A, B>(this Set<Arr<A>> ma, Func<A, Arr<B>> f) =>
            SeqTrans<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MSet<Arr<B>>, Set<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Arr<B>> BindT< A, B>(this Set<Arr<A>> ma, Func<A, Set<Arr<B>>> f) =>
            SeqTrans<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MSet<Arr<B>>, Set<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Set&lt;Arr&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Arr&lt;Set&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;Set&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Arr<Set<B>> Traverse< A, B>(this Set<Arr<A>> ma, Func<A, B> f) =>
            SeqTrans<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<Set<B>>, Arr<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Set&lt;Arr&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Arr&lt;Set&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Arr<Set<A>> Sequence< A>(this Set<Arr<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Arr<B>> MapT< A, B>(this Set<Arr<A>> ma, Func<A, B> f) =>
            SeqTrans<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MSet<Arr<B>>, Set<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Set<Arr<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Set<Arr<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Set<Arr<A>> ma, Func<A, bool> f) =>
            SeqTrans<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Set<Arr<A>> ma, Func<A, bool> f) =>
            SeqTrans<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Set&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Set<Arr<A>> ma, Action<A> f) =>
            SeqTrans<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;Arr&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<Arr<A>> FilterT< A>(this Set<Arr<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MSet<Arr<A>>, Set<Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Arr&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Set<Arr<A>> PlusT<NUM,  A>(this Set<Arr<A>> x, Set<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Arr&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Set<Arr<A>> SubtractT<NUM,  A>(this Set<Arr<A>> x, Set<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Set<Arr<A>> ProductT<NUM,  A>(this Set<Arr<A>> x, Set<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Set<Arr<A>> DivideT<NUM,  A>(this Set<Arr<A>> x, Set<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Set<Arr<A>> AppendT<SEMI,  A>(this Set<Arr<A>> x, Set<Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Set<Arr<A>> x, Set<Arr<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Set<Arr<A>> x, Set<Arr<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Set&lt;Arr&lt;A&gt;&gt;`</param>
        /// <returns>`Set&lt;Arr&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Set<Arr<B>> ApplyT< A, B>(this Func<A, B> fab, Set<Arr<A>> fa) =>
            ApplSet< Arr<A>, Arr<B>>.Inst.Apply(
                 MSet< Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => ApplArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Set&lt;Arr&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Set&lt;Arr&lt;A&gt;&gt;`</param>
        /// <returns>`Set&lt;Arr&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Set<Arr<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Set<Arr<A>> fa, Set<Arr<B>> fb) =>
            ApplSet< Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MSet< Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            ApplArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Validation&lt;FAIL, Arr&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Validation<FAIL, Arr<C>> SelectMany<FAIL, A, B, C>(
            this Validation<FAIL, Arr<A>> ma,
            Func<A, Validation<FAIL, Arr<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MValidation<FAIL, Arr<A>>, Validation<FAIL, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MValidation<FAIL, Arr<C>>, Validation<FAIL, Arr<C>>, MArr<C>, Arr<C>, C>(ma, a =>
                    Trans<MValidation<FAIL, Arr<B>>, Validation<FAIL, Arr<B>>, MArr<B>, Arr<B>, B>
                        .Inst.Bind<MValidation<FAIL, Arr<C>>, Validation<FAIL, Arr<C>>, MArr<C>, Arr<C>, C>(bind(a), b =>
                            default(MArr<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, Arr&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, Arr<A>> Where<FAIL, A>(this Validation<FAIL, Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MValidation<FAIL, Arr<A>>, Validation<FAIL, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MValidation<FAIL, Arr<A>>, Validation<FAIL, Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, Arr<B>> Select<FAIL, A, B>(this Validation<FAIL, Arr<A>> ma, Func<A, B> f) =>
            Trans<MValidation<FAIL, Arr<A>>, Validation<FAIL, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MValidation<FAIL, Arr<B>>, Validation<FAIL, Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Validation&lt;FAIL, Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Arr&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Validation&lt;FAIL, Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, FAIL, A>(this Validation<FAIL, Arr<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MValidation<FAIL, Arr<A>>, Validation<FAIL, Arr<A>>, MArr<A>, Arr<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Validation&lt;FAIL, Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Arr&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Validation&lt;FAIL, Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<FAIL, A>(this Validation<FAIL, Arr<A>> ma) =>
            Trans<MValidation<FAIL, Arr<A>>, Validation<FAIL, Arr<A>>, MArr<A>, Arr<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Validation&lt;FAIL, Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, Arr<B>> BindT<FAIL, A, B>(this Validation<FAIL, Arr<A>> ma, Func<A, Arr<B>> f) =>
            Trans<MValidation<FAIL, Arr<A>>, Validation<FAIL, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MValidation<FAIL, Arr<B>>, Validation<FAIL, Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Validation&lt;FAIL, Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, Arr<B>> BindT<FAIL, A, B>(this Validation<FAIL, Arr<A>> ma, Func<A, Validation<FAIL, Arr<B>>> f) =>
            Trans<MValidation<FAIL, Arr<A>>, Validation<FAIL, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MValidation<FAIL, Arr<B>>, Validation<FAIL, Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Validation&lt;FAIL, Arr&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Arr&lt;Validation&lt;FAIL, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;Validation&lt;FAIL, B&gt;&gt;`</returns>
        [Pure]
        public static Arr<Validation<FAIL, B>> Traverse<FAIL, A, B>(this Validation<FAIL, Arr<A>> ma, Func<A, B> f) =>
            SeqTrans<MValidation<FAIL, Arr<A>>, Validation<FAIL, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Traverse<MArr<Validation<FAIL, B>>, Arr<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Validation&lt;FAIL, Arr&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Arr&lt;Validation&lt;FAIL, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<FAIL, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static Arr<Validation<FAIL, A>> Sequence<FAIL, A>(this Validation<FAIL, Arr<A>> ma) =>
            ma.Traverse<FAIL, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, Arr<B>> MapT<FAIL, A, B>(this Validation<FAIL, Arr<A>> ma, Func<A, B> f) =>
            Trans<MValidation<FAIL, Arr<A>>, Validation<FAIL, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Map<MValidation<FAIL, Arr<B>>, Validation<FAIL, Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, FAIL, A>(this Validation<FAIL, Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MValidation<FAIL, Arr<A>>, Validation<FAIL, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, FAIL, A>(this Validation<FAIL, Arr<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MValidation<FAIL, Arr<A>>, Validation<FAIL, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<FAIL, A>(this Validation<FAIL, Arr<A>> ma, Func<A, bool> f) =>
            Trans<MValidation<FAIL, Arr<A>>, Validation<FAIL, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<FAIL, A>(this Validation<FAIL, Arr<A>> ma, Func<A, bool> f) =>
            Trans<MValidation<FAIL, Arr<A>>, Validation<FAIL, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Validation&lt;FAIL, Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<FAIL, A>(this Validation<FAIL, Arr<A>> ma, Action<A> f) =>
            Trans<MValidation<FAIL, Arr<A>>, Validation<FAIL, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, Arr&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, Arr<A>> FilterT<FAIL, A>(this Validation<FAIL, Arr<A>> ma, Func<A, bool> pred) =>
            Trans<MValidation<FAIL, Arr<A>>, Validation<FAIL, Arr<A>>, MArr<A>, Arr<A>, A>
                .Inst.Bind<MValidation<FAIL, Arr<A>>, Validation<FAIL, Arr<A>>, MArr<A>, Arr<A>, A>(ma, 
                    a => pred(a)
                        ? default(MArr<A>).Return(a)
                        : default(MArr<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Arr&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Validation<FAIL, Arr<A>> PlusT<NUM, FAIL, A>(this Validation<FAIL, Arr<A>> x, Validation<FAIL, Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Arr&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Validation<FAIL, Arr<A>> SubtractT<NUM, FAIL, A>(this Validation<FAIL, Arr<A>> x, Validation<FAIL, Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Arr&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Validation<FAIL, Arr<A>> ProductT<NUM, FAIL, A>(this Validation<FAIL, Arr<A>> x, Validation<FAIL, Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Arr&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Validation<FAIL, Arr<A>> DivideT<NUM, FAIL, A>(this Validation<FAIL, Arr<A>> x, Validation<FAIL, Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Arr&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Validation<FAIL, Arr<A>> AppendT<SEMI, FAIL, A>(this Validation<FAIL, Arr<A>> x, Validation<FAIL, Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, FAIL, A>(this Validation<FAIL, Arr<A>> x, Validation<FAIL, Arr<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Arr&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, FAIL, A>(this Validation<FAIL, Arr<A>> x, Validation<FAIL, Arr<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Validation&lt;FAIL, Arr&lt;A&gt;&gt;`</param>
        /// <returns>`Validation&lt;FAIL, Arr&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Validation<FAIL, Arr<B>> ApplyT<FAIL, A, B>(this Func<A, B> fab, Validation<FAIL, Arr<A>> fa) =>
            ApplValidation<FAIL, Arr<A>, Arr<B>>.Inst.Apply(
                 MValidation<FAIL, Func<Arr<A>, Arr<B>>>.Inst.Return((Arr<A> a) => ApplArr< A, B>.Inst.Apply(
                     MArr< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Validation&lt;FAIL, Arr&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Validation&lt;FAIL, Arr&lt;A&gt;&gt;`</param>
        /// <returns>`Validation&lt;FAIL, Arr&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Validation<FAIL, Arr<C>> ApplyT<FAIL, A, B, C>(this Func<A, B, C> fabc, Validation<FAIL, Arr<A>> fa, Validation<FAIL, Arr<B>> fb) =>
            ApplValidation<FAIL, Arr<A>, Arr<B>, Arr<C>>.Inst.Apply(
                MValidation<FAIL, Func<Arr<A>, Func<Arr<B>, Arr<C>>>>.Inst.Return(
                    (Arr<A> a) =>
                        (Arr<B> b) =>
                            ApplArr< A, B, C>.Inst.Apply(
                                MArr< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    /// <summary>
    /// Monad transformer for HashSet, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class HashSetT_Extensions
    {
        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Arr&lt;HashSet&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<HashSet<C>> SelectMany< A, B, C>(
            this Arr<HashSet<A>> ma,
            Func<A, Arr<HashSet<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MArr<HashSet<C>>, Arr<HashSet<C>>, MHashSet<C>, HashSet<C>, C>(ma, a =>
                    SeqTrans<MArr<HashSet<B>>, Arr<HashSet<B>>, MHashSet<B>, HashSet<B>, B>
                        .Inst.Bind<MArr<HashSet<C>>, Arr<HashSet<C>>, MHashSet<C>, HashSet<C>, C>(bind(a), b =>
                            default(MHashSet<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;HashSet&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<HashSet<A>> Where< A>(this Arr<HashSet<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<HashSet<B>> Select< A, B>(this Arr<HashSet<A>> ma, Func<A, B> f) =>
            SeqTrans<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MArr<HashSet<B>>, Arr<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Arr&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;HashSet&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Arr&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Arr<HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Arr&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;HashSet&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Arr&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Arr<HashSet<A>> ma) =>
            SeqTrans<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<HashSet<B>> BindT< A, B>(this Arr<HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            SeqTrans<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MArr<HashSet<B>>, Arr<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<HashSet<B>> BindT< A, B>(this Arr<HashSet<A>> ma, Func<A, Arr<HashSet<B>>> f) =>
            SeqTrans<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MArr<HashSet<B>>, Arr<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Arr&lt;HashSet&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `HashSet&lt;Arr&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;Arr&lt;B&gt;&gt;`</returns>
        [Pure]
        public static HashSet<Arr<B>> Traverse< A, B>(this Arr<HashSet<A>> ma, Func<A, B> f) =>
            SeqTrans<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<Arr<B>>, HashSet<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Arr&lt;HashSet&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `HashSet&lt;Arr&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static HashSet<Arr<A>> Sequence< A>(this Arr<HashSet<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<HashSet<B>> MapT< A, B>(this Arr<HashSet<A>> ma, Func<A, B> f) =>
            SeqTrans<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MArr<HashSet<B>>, Arr<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Arr<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Arr<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Arr<HashSet<A>> ma, Func<A, bool> f) =>
            SeqTrans<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Arr<HashSet<A>> ma, Func<A, bool> f) =>
            SeqTrans<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Arr&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Arr<HashSet<A>> ma, Action<A> f) =>
            SeqTrans<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;HashSet&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<HashSet<A>> FilterT< A>(this Arr<HashSet<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MArr<HashSet<A>>, Arr<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;HashSet&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Arr<HashSet<A>> PlusT<NUM,  A>(this Arr<HashSet<A>> x, Arr<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;HashSet&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Arr<HashSet<A>> SubtractT<NUM,  A>(this Arr<HashSet<A>> x, Arr<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Arr<HashSet<A>> ProductT<NUM,  A>(this Arr<HashSet<A>> x, Arr<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Arr<HashSet<A>> DivideT<NUM,  A>(this Arr<HashSet<A>> x, Arr<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Arr<HashSet<A>> AppendT<SEMI,  A>(this Arr<HashSet<A>> x, Arr<HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Arr<HashSet<A>> x, Arr<HashSet<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Arr<HashSet<A>> x, Arr<HashSet<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Arr&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <returns>`Arr&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Arr<HashSet<B>> ApplyT< A, B>(this Func<A, B> fab, Arr<HashSet<A>> fa) =>
            ApplArr< HashSet<A>, HashSet<B>>.Inst.Apply(
                 MArr< Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => ApplHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Arr&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Arr&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <returns>`Arr&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Arr<HashSet<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Arr<HashSet<A>> fa, Arr<HashSet<B>> fb) =>
            ApplArr< HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MArr< Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            ApplHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`HashSet&lt;HashSet&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<HashSet<C>> SelectMany< A, B, C>(
            this HashSet<HashSet<A>> ma,
            Func<A, HashSet<HashSet<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MHashSet<HashSet<C>>, HashSet<HashSet<C>>, MHashSet<C>, HashSet<C>, C>(ma, a =>
                    SeqTrans<MHashSet<HashSet<B>>, HashSet<HashSet<B>>, MHashSet<B>, HashSet<B>, B>
                        .Inst.Bind<MHashSet<HashSet<C>>, HashSet<HashSet<C>>, MHashSet<C>, HashSet<C>, C>(bind(a), b =>
                            default(MHashSet<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;HashSet&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<HashSet<A>> Where< A>(this HashSet<HashSet<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<HashSet<B>> Select< A, B>(this HashSet<HashSet<A>> ma, Func<A, B> f) =>
            SeqTrans<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MHashSet<HashSet<B>>, HashSet<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `HashSet&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;HashSet&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `HashSet&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this HashSet<HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `HashSet&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;HashSet&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `HashSet&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this HashSet<HashSet<A>> ma) =>
            SeqTrans<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<HashSet<B>> BindT< A, B>(this HashSet<HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            SeqTrans<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MHashSet<HashSet<B>>, HashSet<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<HashSet<B>> BindT< A, B>(this HashSet<HashSet<A>> ma, Func<A, HashSet<HashSet<B>>> f) =>
            SeqTrans<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MHashSet<HashSet<B>>, HashSet<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `HashSet&lt;HashSet&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `HashSet&lt;HashSet&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;HashSet&lt;B&gt;&gt;`</returns>
        [Pure]
        public static HashSet<HashSet<B>> Traverse< A, B>(this HashSet<HashSet<A>> ma, Func<A, B> f) =>
            SeqTrans<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<HashSet<B>>, HashSet<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `HashSet&lt;HashSet&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `HashSet&lt;HashSet&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static HashSet<HashSet<A>> Sequence< A>(this HashSet<HashSet<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<HashSet<B>> MapT< A, B>(this HashSet<HashSet<A>> ma, Func<A, B> f) =>
            SeqTrans<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MHashSet<HashSet<B>>, HashSet<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this HashSet<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this HashSet<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this HashSet<HashSet<A>> ma, Func<A, bool> f) =>
            SeqTrans<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this HashSet<HashSet<A>> ma, Func<A, bool> f) =>
            SeqTrans<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `HashSet&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this HashSet<HashSet<A>> ma, Action<A> f) =>
            SeqTrans<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;HashSet&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<HashSet<A>> FilterT< A>(this HashSet<HashSet<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MHashSet<HashSet<A>>, HashSet<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;HashSet&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<HashSet<A>> PlusT<NUM,  A>(this HashSet<HashSet<A>> x, HashSet<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;HashSet&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<HashSet<A>> SubtractT<NUM,  A>(this HashSet<HashSet<A>> x, HashSet<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static HashSet<HashSet<A>> ProductT<NUM,  A>(this HashSet<HashSet<A>> x, HashSet<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static HashSet<HashSet<A>> DivideT<NUM,  A>(this HashSet<HashSet<A>> x, HashSet<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static HashSet<HashSet<A>> AppendT<SEMI,  A>(this HashSet<HashSet<A>> x, HashSet<HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this HashSet<HashSet<A>> x, HashSet<HashSet<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this HashSet<HashSet<A>> x, HashSet<HashSet<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `HashSet&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <returns>`HashSet&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static HashSet<HashSet<B>> ApplyT< A, B>(this Func<A, B> fab, HashSet<HashSet<A>> fa) =>
            ApplHashSet< HashSet<A>, HashSet<B>>.Inst.Apply(
                 MHashSet< Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => ApplHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `HashSet&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `HashSet&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <returns>`HashSet&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static HashSet<HashSet<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, HashSet<HashSet<A>> fa, HashSet<HashSet<B>> fb) =>
            ApplHashSet< HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MHashSet< Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            ApplHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Lst&lt;HashSet&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<HashSet<C>> SelectMany< A, B, C>(
            this Lst<HashSet<A>> ma,
            Func<A, Lst<HashSet<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MLst<HashSet<C>>, Lst<HashSet<C>>, MHashSet<C>, HashSet<C>, C>(ma, a =>
                    SeqTrans<MLst<HashSet<B>>, Lst<HashSet<B>>, MHashSet<B>, HashSet<B>, B>
                        .Inst.Bind<MLst<HashSet<C>>, Lst<HashSet<C>>, MHashSet<C>, HashSet<C>, C>(bind(a), b =>
                            default(MHashSet<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;HashSet&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<HashSet<A>> Where< A>(this Lst<HashSet<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<HashSet<B>> Select< A, B>(this Lst<HashSet<A>> ma, Func<A, B> f) =>
            SeqTrans<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MLst<HashSet<B>>, Lst<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Lst&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;HashSet&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Lst&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Lst<HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Lst&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;HashSet&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Lst&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Lst<HashSet<A>> ma) =>
            SeqTrans<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<HashSet<B>> BindT< A, B>(this Lst<HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            SeqTrans<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MLst<HashSet<B>>, Lst<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<HashSet<B>> BindT< A, B>(this Lst<HashSet<A>> ma, Func<A, Lst<HashSet<B>>> f) =>
            SeqTrans<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MLst<HashSet<B>>, Lst<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Lst&lt;HashSet&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `HashSet&lt;Lst&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;Lst&lt;B&gt;&gt;`</returns>
        [Pure]
        public static HashSet<Lst<B>> Traverse< A, B>(this Lst<HashSet<A>> ma, Func<A, B> f) =>
            SeqTrans<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<Lst<B>>, HashSet<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Lst&lt;HashSet&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `HashSet&lt;Lst&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static HashSet<Lst<A>> Sequence< A>(this Lst<HashSet<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<HashSet<B>> MapT< A, B>(this Lst<HashSet<A>> ma, Func<A, B> f) =>
            SeqTrans<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MLst<HashSet<B>>, Lst<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Lst<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Lst<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Lst<HashSet<A>> ma, Func<A, bool> f) =>
            SeqTrans<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Lst<HashSet<A>> ma, Func<A, bool> f) =>
            SeqTrans<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Lst&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Lst<HashSet<A>> ma, Action<A> f) =>
            SeqTrans<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;HashSet&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<HashSet<A>> FilterT< A>(this Lst<HashSet<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MLst<HashSet<A>>, Lst<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;HashSet&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Lst<HashSet<A>> PlusT<NUM,  A>(this Lst<HashSet<A>> x, Lst<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;HashSet&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Lst<HashSet<A>> SubtractT<NUM,  A>(this Lst<HashSet<A>> x, Lst<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Lst<HashSet<A>> ProductT<NUM,  A>(this Lst<HashSet<A>> x, Lst<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Lst<HashSet<A>> DivideT<NUM,  A>(this Lst<HashSet<A>> x, Lst<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Lst<HashSet<A>> AppendT<SEMI,  A>(this Lst<HashSet<A>> x, Lst<HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Lst<HashSet<A>> x, Lst<HashSet<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Lst<HashSet<A>> x, Lst<HashSet<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Lst&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <returns>`Lst&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Lst<HashSet<B>> ApplyT< A, B>(this Func<A, B> fab, Lst<HashSet<A>> fa) =>
            ApplLst< HashSet<A>, HashSet<B>>.Inst.Apply(
                 MLst< Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => ApplHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Lst&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Lst&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <returns>`Lst&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Lst<HashSet<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Lst<HashSet<A>> fa, Lst<HashSet<B>> fb) =>
            ApplLst< HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MLst< Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            ApplHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Option&lt;HashSet&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Option<HashSet<C>> SelectMany< A, B, C>(
            this Option<HashSet<A>> ma,
            Func<A, Option<HashSet<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MOption<HashSet<C>>, Option<HashSet<C>>, MHashSet<C>, HashSet<C>, C>(ma, a =>
                    Trans<MOption<HashSet<B>>, Option<HashSet<B>>, MHashSet<B>, HashSet<B>, B>
                        .Inst.Bind<MOption<HashSet<C>>, Option<HashSet<C>>, MHashSet<C>, HashSet<C>, C>(bind(a), b =>
                            default(MHashSet<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;HashSet&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<HashSet<A>> Where< A>(this Option<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<HashSet<B>> Select< A, B>(this Option<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MOption<HashSet<B>>, Option<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Option&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;HashSet&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Option&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Option<HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Option&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;HashSet&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Option&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Option<HashSet<A>> ma) =>
            Trans<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<HashSet<B>> BindT< A, B>(this Option<HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            Trans<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MOption<HashSet<B>>, Option<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<HashSet<B>> BindT< A, B>(this Option<HashSet<A>> ma, Func<A, Option<HashSet<B>>> f) =>
            Trans<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MOption<HashSet<B>>, Option<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Option&lt;HashSet&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `HashSet&lt;Option&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;Option&lt;B&gt;&gt;`</returns>
        [Pure]
        public static HashSet<Option<B>> Traverse< A, B>(this Option<HashSet<A>> ma, Func<A, B> f) =>
            SeqTrans<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<Option<B>>, HashSet<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Option&lt;HashSet&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `HashSet&lt;Option&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static HashSet<Option<A>> Sequence< A>(this Option<HashSet<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<HashSet<B>> MapT< A, B>(this Option<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MOption<HashSet<B>>, Option<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Option<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Option<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Option<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Option<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Option&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Option<HashSet<A>> ma, Action<A> f) =>
            Trans<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;HashSet&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<HashSet<A>> FilterT< A>(this Option<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MOption<HashSet<A>>, Option<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;HashSet&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Option<HashSet<A>> PlusT<NUM,  A>(this Option<HashSet<A>> x, Option<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;HashSet&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Option<HashSet<A>> SubtractT<NUM,  A>(this Option<HashSet<A>> x, Option<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Option<HashSet<A>> ProductT<NUM,  A>(this Option<HashSet<A>> x, Option<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Option<HashSet<A>> DivideT<NUM,  A>(this Option<HashSet<A>> x, Option<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Option<HashSet<A>> AppendT<SEMI,  A>(this Option<HashSet<A>> x, Option<HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Option<HashSet<A>> x, Option<HashSet<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Option<HashSet<A>> x, Option<HashSet<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Option&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <returns>`Option&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Option<HashSet<B>> ApplyT< A, B>(this Func<A, B> fab, Option<HashSet<A>> fa) =>
            ApplOption< HashSet<A>, HashSet<B>>.Inst.Apply(
                 MOption< Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => ApplHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Option&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Option&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <returns>`Option&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Option<HashSet<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Option<HashSet<A>> fa, Option<HashSet<B>> fb) =>
            ApplOption< HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MOption< Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            ApplHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionUnsafe&lt;HashSet&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<HashSet<C>> SelectMany< A, B, C>(
            this OptionUnsafe<HashSet<A>> ma,
            Func<A, OptionUnsafe<HashSet<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MOptionUnsafe<HashSet<C>>, OptionUnsafe<HashSet<C>>, MHashSet<C>, HashSet<C>, C>(ma, a =>
                    Trans<MOptionUnsafe<HashSet<B>>, OptionUnsafe<HashSet<B>>, MHashSet<B>, HashSet<B>, B>
                        .Inst.Bind<MOptionUnsafe<HashSet<C>>, OptionUnsafe<HashSet<C>>, MHashSet<C>, HashSet<C>, C>(bind(a), b =>
                            default(MHashSet<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;HashSet&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<HashSet<A>> Where< A>(this OptionUnsafe<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<HashSet<B>> Select< A, B>(this OptionUnsafe<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MOptionUnsafe<HashSet<B>>, OptionUnsafe<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionUnsafe&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;HashSet&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionUnsafe&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this OptionUnsafe<HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionUnsafe&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;HashSet&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionUnsafe&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this OptionUnsafe<HashSet<A>> ma) =>
            Trans<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<HashSet<B>> BindT< A, B>(this OptionUnsafe<HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            Trans<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MOptionUnsafe<HashSet<B>>, OptionUnsafe<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<HashSet<B>> BindT< A, B>(this OptionUnsafe<HashSet<A>> ma, Func<A, OptionUnsafe<HashSet<B>>> f) =>
            Trans<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MOptionUnsafe<HashSet<B>>, OptionUnsafe<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionUnsafe&lt;HashSet&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `HashSet&lt;OptionUnsafe&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;OptionUnsafe&lt;B&gt;&gt;`</returns>
        [Pure]
        public static HashSet<OptionUnsafe<B>> Traverse< A, B>(this OptionUnsafe<HashSet<A>> ma, Func<A, B> f) =>
            SeqTrans<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<OptionUnsafe<B>>, HashSet<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionUnsafe&lt;HashSet&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `HashSet&lt;OptionUnsafe&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static HashSet<OptionUnsafe<A>> Sequence< A>(this OptionUnsafe<HashSet<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<HashSet<B>> MapT< A, B>(this OptionUnsafe<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MOptionUnsafe<HashSet<B>>, OptionUnsafe<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this OptionUnsafe<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this OptionUnsafe<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this OptionUnsafe<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this OptionUnsafe<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionUnsafe&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this OptionUnsafe<HashSet<A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;HashSet&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<HashSet<A>> FilterT< A>(this OptionUnsafe<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MOptionUnsafe<HashSet<A>>, OptionUnsafe<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;HashSet&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<HashSet<A>> PlusT<NUM,  A>(this OptionUnsafe<HashSet<A>> x, OptionUnsafe<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;HashSet&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<HashSet<A>> SubtractT<NUM,  A>(this OptionUnsafe<HashSet<A>> x, OptionUnsafe<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionUnsafe<HashSet<A>> ProductT<NUM,  A>(this OptionUnsafe<HashSet<A>> x, OptionUnsafe<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionUnsafe<HashSet<A>> DivideT<NUM,  A>(this OptionUnsafe<HashSet<A>> x, OptionUnsafe<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionUnsafe<HashSet<A>> AppendT<SEMI,  A>(this OptionUnsafe<HashSet<A>> x, OptionUnsafe<HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this OptionUnsafe<HashSet<A>> x, OptionUnsafe<HashSet<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this OptionUnsafe<HashSet<A>> x, OptionUnsafe<HashSet<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <returns>`OptionUnsafe&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionUnsafe<HashSet<B>> ApplyT< A, B>(this Func<A, B> fab, OptionUnsafe<HashSet<A>> fa) =>
            ApplOptionUnsafe< HashSet<A>, HashSet<B>>.Inst.Apply(
                 MOptionUnsafe< Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => ApplHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `OptionUnsafe&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <returns>`OptionUnsafe&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionUnsafe<HashSet<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, OptionUnsafe<HashSet<A>> fa, OptionUnsafe<HashSet<B>> fb) =>
            ApplOptionUnsafe< HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MOptionUnsafe< Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            ApplHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Either&lt;L, HashSet&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, HashSet<C>> SelectMany<L, A, B, C>(
            this Either<L, HashSet<A>> ma,
            Func<A, Either<L, HashSet<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MEither<L, HashSet<C>>, Either<L, HashSet<C>>, MHashSet<C>, HashSet<C>, C>(ma, a =>
                    Trans<MEither<L, HashSet<B>>, Either<L, HashSet<B>>, MHashSet<B>, HashSet<B>, B>
                        .Inst.Bind<MEither<L, HashSet<C>>, Either<L, HashSet<C>>, MHashSet<C>, HashSet<C>, C>(bind(a), b =>
                            default(MHashSet<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, HashSet&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, HashSet<A>> Where<L, A>(this Either<L, HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, HashSet<B>> Select<L, A, B>(this Either<L, HashSet<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MEither<L, HashSet<B>>, Either<L, HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Either&lt;L, HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, HashSet&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Either&lt;L, HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Either<L, HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Either&lt;L, HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, HashSet&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Either&lt;L, HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this Either<L, HashSet<A>> ma) =>
            Trans<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either&lt;L, HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, HashSet<B>> BindT<L, A, B>(this Either<L, HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            Trans<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MEither<L, HashSet<B>>, Either<L, HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either&lt;L, HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, HashSet<B>> BindT<L, A, B>(this Either<L, HashSet<A>> ma, Func<A, Either<L, HashSet<B>>> f) =>
            Trans<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MEither<L, HashSet<B>>, Either<L, HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Either&lt;L, HashSet&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `HashSet&lt;Either&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;Either&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static HashSet<Either<L, B>> Traverse<L, A, B>(this Either<L, HashSet<A>> ma, Func<A, B> f) =>
            SeqTrans<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<Either<L, B>>, HashSet<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Either&lt;L, HashSet&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `HashSet&lt;Either&lt;L, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static HashSet<Either<L, A>> Sequence<L, A>(this Either<L, HashSet<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, HashSet<B>> MapT<L, A, B>(this Either<L, HashSet<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MEither<L, HashSet<B>>, Either<L, HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Either<L, HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Either<L, HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Either<L, HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Either<L, HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Either&lt;L, HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Either<L, HashSet<A>> ma, Action<A> f) =>
            Trans<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, HashSet&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, HashSet<A>> FilterT<L, A>(this Either<L, HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MEither<L, HashSet<A>>, Either<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, HashSet&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, HashSet<A>> PlusT<NUM, L, A>(this Either<L, HashSet<A>> x, Either<L, HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, HashSet&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, HashSet<A>> SubtractT<NUM, L, A>(this Either<L, HashSet<A>> x, Either<L, HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, HashSet&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Either<L, HashSet<A>> ProductT<NUM, L, A>(this Either<L, HashSet<A>> x, Either<L, HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, HashSet&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Either<L, HashSet<A>> DivideT<NUM, L, A>(this Either<L, HashSet<A>> x, Either<L, HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, HashSet&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Either<L, HashSet<A>> AppendT<SEMI, L, A>(this Either<L, HashSet<A>> x, Either<L, HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Either<L, HashSet<A>> x, Either<L, HashSet<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, HashSet&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Either<L, HashSet<A>> x, Either<L, HashSet<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Either&lt;L, HashSet&lt;A&gt;&gt;`</param>
        /// <returns>`Either&lt;L, HashSet&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Either<L, HashSet<B>> ApplyT<L, A, B>(this Func<A, B> fab, Either<L, HashSet<A>> fa) =>
            ApplEither<L, HashSet<A>, HashSet<B>>.Inst.Apply(
                 MEither<L, Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => ApplHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Either&lt;L, HashSet&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Either&lt;L, HashSet&lt;A&gt;&gt;`</param>
        /// <returns>`Either&lt;L, HashSet&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Either<L, HashSet<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Either<L, HashSet<A>> fa, Either<L, HashSet<B>> fb) =>
            ApplEither<L, HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MEither<L, Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            ApplHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`EitherUnsafe&lt;L, HashSet&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, HashSet<A>> ma,
            Func<A, EitherUnsafe<L, HashSet<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MEitherUnsafe<L, HashSet<C>>, EitherUnsafe<L, HashSet<C>>, MHashSet<C>, HashSet<C>, C>(ma, a =>
                    Trans<MEitherUnsafe<L, HashSet<B>>, EitherUnsafe<L, HashSet<B>>, MHashSet<B>, HashSet<B>, B>
                        .Inst.Bind<MEitherUnsafe<L, HashSet<C>>, EitherUnsafe<L, HashSet<C>>, MHashSet<C>, HashSet<C>, C>(bind(a), b =>
                            default(MHashSet<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, HashSet&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<A>> Where<L, A>(this EitherUnsafe<L, HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<B>> Select<L, A, B>(this EitherUnsafe<L, HashSet<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MEitherUnsafe<L, HashSet<B>>, EitherUnsafe<L, HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherUnsafe&lt;L, HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, HashSet&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherUnsafe&lt;L, HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this EitherUnsafe<L, HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherUnsafe&lt;L, HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, HashSet&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherUnsafe&lt;L, HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this EitherUnsafe<L, HashSet<A>> ma) =>
            Trans<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<B>> BindT<L, A, B>(this EitherUnsafe<L, HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            Trans<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MEitherUnsafe<L, HashSet<B>>, EitherUnsafe<L, HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<B>> BindT<L, A, B>(this EitherUnsafe<L, HashSet<A>> ma, Func<A, EitherUnsafe<L, HashSet<B>>> f) =>
            Trans<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MEitherUnsafe<L, HashSet<B>>, EitherUnsafe<L, HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `EitherUnsafe&lt;L, HashSet&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `HashSet&lt;EitherUnsafe&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;EitherUnsafe&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, B>> Traverse<L, A, B>(this EitherUnsafe<L, HashSet<A>> ma, Func<A, B> f) =>
            SeqTrans<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<EitherUnsafe<L, B>>, HashSet<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `EitherUnsafe&lt;L, HashSet&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `HashSet&lt;EitherUnsafe&lt;L, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, A>> Sequence<L, A>(this EitherUnsafe<L, HashSet<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<B>> MapT<L, A, B>(this EitherUnsafe<L, HashSet<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MEitherUnsafe<L, HashSet<B>>, EitherUnsafe<L, HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this EitherUnsafe<L, HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this EitherUnsafe<L, HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this EitherUnsafe<L, HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this EitherUnsafe<L, HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherUnsafe&lt;L, HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this EitherUnsafe<L, HashSet<A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, HashSet&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<A>> FilterT<L, A>(this EitherUnsafe<L, HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MEitherUnsafe<L, HashSet<A>>, EitherUnsafe<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, HashSet&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<A>> PlusT<NUM, L, A>(this EitherUnsafe<L, HashSet<A>> x, EitherUnsafe<L, HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, HashSet&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<A>> SubtractT<NUM, L, A>(this EitherUnsafe<L, HashSet<A>> x, EitherUnsafe<L, HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, HashSet&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<A>> ProductT<NUM, L, A>(this EitherUnsafe<L, HashSet<A>> x, EitherUnsafe<L, HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, HashSet&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<A>> DivideT<NUM, L, A>(this EitherUnsafe<L, HashSet<A>> x, EitherUnsafe<L, HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, HashSet&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<A>> AppendT<SEMI, L, A>(this EitherUnsafe<L, HashSet<A>> x, EitherUnsafe<L, HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this EitherUnsafe<L, HashSet<A>> x, EitherUnsafe<L, HashSet<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, HashSet&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this EitherUnsafe<L, HashSet<A>> x, EitherUnsafe<L, HashSet<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe&lt;L, HashSet&lt;A&gt;&gt;`</param>
        /// <returns>`EitherUnsafe&lt;L, HashSet&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherUnsafe<L, HashSet<A>> fa) =>
            ApplEitherUnsafe<L, HashSet<A>, HashSet<B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => ApplHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe&lt;L, HashSet&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `EitherUnsafe&lt;L, HashSet&lt;A&gt;&gt;`</param>
        /// <returns>`EitherUnsafe&lt;L, HashSet&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherUnsafe<L, HashSet<A>> fa, EitherUnsafe<L, HashSet<B>> fb) =>
            ApplEitherUnsafe<L, HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MEitherUnsafe<L, Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            ApplHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Try&lt;HashSet&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Try<HashSet<C>> SelectMany< A, B, C>(
            this Try<HashSet<A>> ma,
            Func<A, Try<HashSet<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MTry<HashSet<C>>, Try<HashSet<C>>, MHashSet<C>, HashSet<C>, C>(ma, a =>
                    Trans<MTry<HashSet<B>>, Try<HashSet<B>>, MHashSet<B>, HashSet<B>, B>
                        .Inst.Bind<MTry<HashSet<C>>, Try<HashSet<C>>, MHashSet<C>, HashSet<C>, C>(bind(a), b =>
                            default(MHashSet<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;HashSet&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<HashSet<A>> Where< A>(this Try<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<HashSet<B>> Select< A, B>(this Try<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MTry<HashSet<B>>, Try<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Try&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;HashSet&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Try&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Try<HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Try&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;HashSet&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Try&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Try<HashSet<A>> ma) =>
            Trans<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<HashSet<B>> BindT< A, B>(this Try<HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            Trans<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MTry<HashSet<B>>, Try<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<HashSet<B>> BindT< A, B>(this Try<HashSet<A>> ma, Func<A, Try<HashSet<B>>> f) =>
            Trans<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MTry<HashSet<B>>, Try<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Try&lt;HashSet&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `HashSet&lt;Try&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;Try&lt;B&gt;&gt;`</returns>
        [Pure]
        public static HashSet<Try<B>> Traverse< A, B>(this Try<HashSet<A>> ma, Func<A, B> f) =>
            SeqTrans<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<Try<B>>, HashSet<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Try&lt;HashSet&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `HashSet&lt;Try&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static HashSet<Try<A>> Sequence< A>(this Try<HashSet<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<HashSet<B>> MapT< A, B>(this Try<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MTry<HashSet<B>>, Try<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Try<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Try<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Try<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Try<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Try&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Try<HashSet<A>> ma, Action<A> f) =>
            Trans<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;HashSet&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<HashSet<A>> FilterT< A>(this Try<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MTry<HashSet<A>>, Try<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;HashSet&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Try<HashSet<A>> PlusT<NUM,  A>(this Try<HashSet<A>> x, Try<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;HashSet&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Try<HashSet<A>> SubtractT<NUM,  A>(this Try<HashSet<A>> x, Try<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Try<HashSet<A>> ProductT<NUM,  A>(this Try<HashSet<A>> x, Try<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Try<HashSet<A>> DivideT<NUM,  A>(this Try<HashSet<A>> x, Try<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Try<HashSet<A>> AppendT<SEMI,  A>(this Try<HashSet<A>> x, Try<HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Try<HashSet<A>> x, Try<HashSet<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Try<HashSet<A>> x, Try<HashSet<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Try&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <returns>`Try&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Try<HashSet<B>> ApplyT< A, B>(this Func<A, B> fab, Try<HashSet<A>> fa) =>
            ApplTry< HashSet<A>, HashSet<B>>.Inst.Apply(
                 MTry< Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => ApplHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Try&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Try&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <returns>`Try&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Try<HashSet<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Try<HashSet<A>> fa, Try<HashSet<B>> fb) =>
            ApplTry< HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MTry< Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            ApplHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOption&lt;HashSet&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<HashSet<C>> SelectMany< A, B, C>(
            this TryOption<HashSet<A>> ma,
            Func<A, TryOption<HashSet<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MTryOption<HashSet<C>>, TryOption<HashSet<C>>, MHashSet<C>, HashSet<C>, C>(ma, a =>
                    Trans<MTryOption<HashSet<B>>, TryOption<HashSet<B>>, MHashSet<B>, HashSet<B>, B>
                        .Inst.Bind<MTryOption<HashSet<C>>, TryOption<HashSet<C>>, MHashSet<C>, HashSet<C>, C>(bind(a), b =>
                            default(MHashSet<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;HashSet&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<HashSet<A>> Where< A>(this TryOption<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<HashSet<B>> Select< A, B>(this TryOption<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MTryOption<HashSet<B>>, TryOption<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOption&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;HashSet&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOption&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryOption<HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOption&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;HashSet&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOption&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this TryOption<HashSet<A>> ma) =>
            Trans<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<HashSet<B>> BindT< A, B>(this TryOption<HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            Trans<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MTryOption<HashSet<B>>, TryOption<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<HashSet<B>> BindT< A, B>(this TryOption<HashSet<A>> ma, Func<A, TryOption<HashSet<B>>> f) =>
            Trans<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MTryOption<HashSet<B>>, TryOption<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOption&lt;HashSet&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `HashSet&lt;TryOption&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;TryOption&lt;B&gt;&gt;`</returns>
        [Pure]
        public static HashSet<TryOption<B>> Traverse< A, B>(this TryOption<HashSet<A>> ma, Func<A, B> f) =>
            SeqTrans<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<TryOption<B>>, HashSet<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOption&lt;HashSet&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `HashSet&lt;TryOption&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static HashSet<TryOption<A>> Sequence< A>(this TryOption<HashSet<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<HashSet<B>> MapT< A, B>(this TryOption<HashSet<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MTryOption<HashSet<B>>, TryOption<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryOption<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryOption<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryOption<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryOption<HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOption&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryOption<HashSet<A>> ma, Action<A> f) =>
            Trans<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;HashSet&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<HashSet<A>> FilterT< A>(this TryOption<HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MTryOption<HashSet<A>>, TryOption<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;HashSet&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<HashSet<A>> PlusT<NUM,  A>(this TryOption<HashSet<A>> x, TryOption<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;HashSet&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<HashSet<A>> SubtractT<NUM,  A>(this TryOption<HashSet<A>> x, TryOption<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOption<HashSet<A>> ProductT<NUM,  A>(this TryOption<HashSet<A>> x, TryOption<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOption<HashSet<A>> DivideT<NUM,  A>(this TryOption<HashSet<A>> x, TryOption<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOption<HashSet<A>> AppendT<SEMI,  A>(this TryOption<HashSet<A>> x, TryOption<HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryOption<HashSet<A>> x, TryOption<HashSet<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryOption<HashSet<A>> x, TryOption<HashSet<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOption&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <returns>`TryOption&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOption<HashSet<B>> ApplyT< A, B>(this Func<A, B> fab, TryOption<HashSet<A>> fa) =>
            ApplTryOption< HashSet<A>, HashSet<B>>.Inst.Apply(
                 MTryOption< Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => ApplHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOption&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryOption&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <returns>`TryOption&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOption<HashSet<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOption<HashSet<A>> fa, TryOption<HashSet<B>> fb) =>
            ApplTryOption< HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MTryOption< Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            ApplHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`IEnumerable&lt;HashSet&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<HashSet<C>> SelectMany< A, B, C>(
            this IEnumerable<HashSet<A>> ma,
            Func<A, IEnumerable<HashSet<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MEnumerable<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MEnumerable<HashSet<C>>, IEnumerable<HashSet<C>>, MHashSet<C>, HashSet<C>, C>(ma, a =>
                    SeqTrans<MEnumerable<HashSet<B>>, IEnumerable<HashSet<B>>, MHashSet<B>, HashSet<B>, B>
                        .Inst.Bind<MEnumerable<HashSet<C>>, IEnumerable<HashSet<C>>, MHashSet<C>, HashSet<C>, C>(bind(a), b =>
                            default(MHashSet<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;HashSet&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<HashSet<A>> Where< A>(this IEnumerable<HashSet<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MEnumerable<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MEnumerable<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<HashSet<B>> Select< A, B>(this IEnumerable<HashSet<A>> ma, Func<A, B> f) =>
            SeqTrans<MEnumerable<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MEnumerable<HashSet<B>>, IEnumerable<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `IEnumerable&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;HashSet&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `IEnumerable&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this IEnumerable<HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MEnumerable<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `IEnumerable&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;HashSet&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `IEnumerable&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this IEnumerable<HashSet<A>> ma) =>
            SeqTrans<MEnumerable<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<HashSet<B>> BindT< A, B>(this IEnumerable<HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            SeqTrans<MEnumerable<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MEnumerable<HashSet<B>>, IEnumerable<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<HashSet<B>> BindT< A, B>(this IEnumerable<HashSet<A>> ma, Func<A, IEnumerable<HashSet<B>>> f) =>
            SeqTrans<MEnumerable<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MEnumerable<HashSet<B>>, IEnumerable<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `IEnumerable&lt;HashSet&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `HashSet&lt;IEnumerable&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;IEnumerable&lt;B&gt;&gt;`</returns>
        [Pure]
        public static HashSet<IEnumerable<B>> Traverse< A, B>(this IEnumerable<HashSet<A>> ma, Func<A, B> f) =>
            SeqTrans<MEnumerable<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<IEnumerable<B>>, HashSet<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `IEnumerable&lt;HashSet&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `HashSet&lt;IEnumerable&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static HashSet<IEnumerable<A>> Sequence< A>(this IEnumerable<HashSet<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<HashSet<B>> MapT< A, B>(this IEnumerable<HashSet<A>> ma, Func<A, B> f) =>
            SeqTrans<MEnumerable<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MEnumerable<HashSet<B>>, IEnumerable<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this IEnumerable<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MEnumerable<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this IEnumerable<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MEnumerable<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this IEnumerable<HashSet<A>> ma, Func<A, bool> f) =>
            SeqTrans<MEnumerable<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this IEnumerable<HashSet<A>> ma, Func<A, bool> f) =>
            SeqTrans<MEnumerable<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `IEnumerable&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this IEnumerable<HashSet<A>> ma, Action<A> f) =>
            SeqTrans<MEnumerable<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;HashSet&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<HashSet<A>> FilterT< A>(this IEnumerable<HashSet<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MEnumerable<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MEnumerable<HashSet<A>>, IEnumerable<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;HashSet&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<HashSet<A>> PlusT<NUM,  A>(this IEnumerable<HashSet<A>> x, IEnumerable<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;HashSet&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<HashSet<A>> SubtractT<NUM,  A>(this IEnumerable<HashSet<A>> x, IEnumerable<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static IEnumerable<HashSet<A>> ProductT<NUM,  A>(this IEnumerable<HashSet<A>> x, IEnumerable<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static IEnumerable<HashSet<A>> DivideT<NUM,  A>(this IEnumerable<HashSet<A>> x, IEnumerable<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static IEnumerable<HashSet<A>> AppendT<SEMI,  A>(this IEnumerable<HashSet<A>> x, IEnumerable<HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this IEnumerable<HashSet<A>> x, IEnumerable<HashSet<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this IEnumerable<HashSet<A>> x, IEnumerable<HashSet<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `IEnumerable&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <returns>`IEnumerable&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static IEnumerable<HashSet<B>> ApplyT< A, B>(this Func<A, B> fab, IEnumerable<HashSet<A>> fa) =>
            ApplEnumerable< HashSet<A>, HashSet<B>>.Inst.Apply(
                 MEnumerable< Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => ApplHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `IEnumerable&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `IEnumerable&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <returns>`IEnumerable&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static IEnumerable<HashSet<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, IEnumerable<HashSet<A>> fa, IEnumerable<HashSet<B>> fb) =>
            ApplEnumerable< HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MEnumerable< Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            ApplHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Seq&lt;HashSet&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Seq<HashSet<C>> SelectMany< A, B, C>(
            this Seq<HashSet<A>> ma,
            Func<A, Seq<HashSet<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MSeq<HashSet<A>>, Seq<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MSeq<HashSet<C>>, Seq<HashSet<C>>, MHashSet<C>, HashSet<C>, C>(ma, a =>
                    SeqTrans<MSeq<HashSet<B>>, Seq<HashSet<B>>, MHashSet<B>, HashSet<B>, B>
                        .Inst.Bind<MSeq<HashSet<C>>, Seq<HashSet<C>>, MHashSet<C>, HashSet<C>, C>(bind(a), b =>
                            default(MHashSet<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;HashSet&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<HashSet<A>> Where< A>(this Seq<HashSet<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSeq<HashSet<A>>, Seq<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MSeq<HashSet<A>>, Seq<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<HashSet<B>> Select< A, B>(this Seq<HashSet<A>> ma, Func<A, B> f) =>
            SeqTrans<MSeq<HashSet<A>>, Seq<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MSeq<HashSet<B>>, Seq<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Seq&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;HashSet&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Seq&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Seq<HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MSeq<HashSet<A>>, Seq<HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Seq&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;HashSet&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Seq&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Seq<HashSet<A>> ma) =>
            SeqTrans<MSeq<HashSet<A>>, Seq<HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Seq&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<HashSet<B>> BindT< A, B>(this Seq<HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            SeqTrans<MSeq<HashSet<A>>, Seq<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MSeq<HashSet<B>>, Seq<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Seq&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<HashSet<B>> BindT< A, B>(this Seq<HashSet<A>> ma, Func<A, Seq<HashSet<B>>> f) =>
            SeqTrans<MSeq<HashSet<A>>, Seq<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MSeq<HashSet<B>>, Seq<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Seq&lt;HashSet&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `HashSet&lt;Seq&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;Seq&lt;B&gt;&gt;`</returns>
        [Pure]
        public static HashSet<Seq<B>> Traverse< A, B>(this Seq<HashSet<A>> ma, Func<A, B> f) =>
            SeqTrans<MSeq<HashSet<A>>, Seq<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<Seq<B>>, HashSet<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Seq&lt;HashSet&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `HashSet&lt;Seq&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static HashSet<Seq<A>> Sequence< A>(this Seq<HashSet<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<HashSet<B>> MapT< A, B>(this Seq<HashSet<A>> ma, Func<A, B> f) =>
            SeqTrans<MSeq<HashSet<A>>, Seq<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MSeq<HashSet<B>>, Seq<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Seq<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSeq<HashSet<A>>, Seq<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Seq<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSeq<HashSet<A>>, Seq<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Seq<HashSet<A>> ma, Func<A, bool> f) =>
            SeqTrans<MSeq<HashSet<A>>, Seq<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Seq<HashSet<A>> ma, Func<A, bool> f) =>
            SeqTrans<MSeq<HashSet<A>>, Seq<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Seq&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Seq<HashSet<A>> ma, Action<A> f) =>
            SeqTrans<MSeq<HashSet<A>>, Seq<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;HashSet&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<HashSet<A>> FilterT< A>(this Seq<HashSet<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSeq<HashSet<A>>, Seq<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MSeq<HashSet<A>>, Seq<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;HashSet&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Seq<HashSet<A>> PlusT<NUM,  A>(this Seq<HashSet<A>> x, Seq<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;HashSet&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Seq<HashSet<A>> SubtractT<NUM,  A>(this Seq<HashSet<A>> x, Seq<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Seq<HashSet<A>> ProductT<NUM,  A>(this Seq<HashSet<A>> x, Seq<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Seq<HashSet<A>> DivideT<NUM,  A>(this Seq<HashSet<A>> x, Seq<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Seq<HashSet<A>> AppendT<SEMI,  A>(this Seq<HashSet<A>> x, Seq<HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Seq<HashSet<A>> x, Seq<HashSet<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Seq<HashSet<A>> x, Seq<HashSet<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Seq&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <returns>`Seq&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Seq<HashSet<B>> ApplyT< A, B>(this Func<A, B> fab, Seq<HashSet<A>> fa) =>
            ApplSeq< HashSet<A>, HashSet<B>>.Inst.Apply(
                 MSeq< Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => ApplHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Seq&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Seq&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <returns>`Seq&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Seq<HashSet<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Seq<HashSet<A>> fa, Seq<HashSet<B>> fb) =>
            ApplSeq< HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MSeq< Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            ApplHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Set&lt;HashSet&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Set<HashSet<C>> SelectMany< A, B, C>(
            this Set<HashSet<A>> ma,
            Func<A, Set<HashSet<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MSet<HashSet<C>>, Set<HashSet<C>>, MHashSet<C>, HashSet<C>, C>(ma, a =>
                    SeqTrans<MSet<HashSet<B>>, Set<HashSet<B>>, MHashSet<B>, HashSet<B>, B>
                        .Inst.Bind<MSet<HashSet<C>>, Set<HashSet<C>>, MHashSet<C>, HashSet<C>, C>(bind(a), b =>
                            default(MHashSet<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;HashSet&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<HashSet<A>> Where< A>(this Set<HashSet<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<HashSet<B>> Select< A, B>(this Set<HashSet<A>> ma, Func<A, B> f) =>
            SeqTrans<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MSet<HashSet<B>>, Set<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Set&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;HashSet&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Set&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Set<HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Set&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;HashSet&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Set&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Set<HashSet<A>> ma) =>
            SeqTrans<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<HashSet<B>> BindT< A, B>(this Set<HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            SeqTrans<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MSet<HashSet<B>>, Set<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<HashSet<B>> BindT< A, B>(this Set<HashSet<A>> ma, Func<A, Set<HashSet<B>>> f) =>
            SeqTrans<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MSet<HashSet<B>>, Set<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Set&lt;HashSet&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `HashSet&lt;Set&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;Set&lt;B&gt;&gt;`</returns>
        [Pure]
        public static HashSet<Set<B>> Traverse< A, B>(this Set<HashSet<A>> ma, Func<A, B> f) =>
            SeqTrans<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<Set<B>>, HashSet<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Set&lt;HashSet&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `HashSet&lt;Set&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static HashSet<Set<A>> Sequence< A>(this Set<HashSet<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<HashSet<B>> MapT< A, B>(this Set<HashSet<A>> ma, Func<A, B> f) =>
            SeqTrans<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MSet<HashSet<B>>, Set<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Set<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Set<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Set<HashSet<A>> ma, Func<A, bool> f) =>
            SeqTrans<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Set<HashSet<A>> ma, Func<A, bool> f) =>
            SeqTrans<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Set&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Set<HashSet<A>> ma, Action<A> f) =>
            SeqTrans<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;HashSet&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<HashSet<A>> FilterT< A>(this Set<HashSet<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MSet<HashSet<A>>, Set<HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;HashSet&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Set<HashSet<A>> PlusT<NUM,  A>(this Set<HashSet<A>> x, Set<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;HashSet&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Set<HashSet<A>> SubtractT<NUM,  A>(this Set<HashSet<A>> x, Set<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Set<HashSet<A>> ProductT<NUM,  A>(this Set<HashSet<A>> x, Set<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Set<HashSet<A>> DivideT<NUM,  A>(this Set<HashSet<A>> x, Set<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Set<HashSet<A>> AppendT<SEMI,  A>(this Set<HashSet<A>> x, Set<HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Set<HashSet<A>> x, Set<HashSet<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Set<HashSet<A>> x, Set<HashSet<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Set&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <returns>`Set&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Set<HashSet<B>> ApplyT< A, B>(this Func<A, B> fab, Set<HashSet<A>> fa) =>
            ApplSet< HashSet<A>, HashSet<B>>.Inst.Apply(
                 MSet< Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => ApplHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Set&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Set&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <returns>`Set&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Set<HashSet<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Set<HashSet<A>> fa, Set<HashSet<B>> fb) =>
            ApplSet< HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MSet< Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            ApplHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Validation&lt;FAIL, HashSet&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Validation<FAIL, HashSet<C>> SelectMany<FAIL, A, B, C>(
            this Validation<FAIL, HashSet<A>> ma,
            Func<A, Validation<FAIL, HashSet<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MValidation<FAIL, HashSet<A>>, Validation<FAIL, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MValidation<FAIL, HashSet<C>>, Validation<FAIL, HashSet<C>>, MHashSet<C>, HashSet<C>, C>(ma, a =>
                    Trans<MValidation<FAIL, HashSet<B>>, Validation<FAIL, HashSet<B>>, MHashSet<B>, HashSet<B>, B>
                        .Inst.Bind<MValidation<FAIL, HashSet<C>>, Validation<FAIL, HashSet<C>>, MHashSet<C>, HashSet<C>, C>(bind(a), b =>
                            default(MHashSet<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, HashSet&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, HashSet<A>> Where<FAIL, A>(this Validation<FAIL, HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MValidation<FAIL, HashSet<A>>, Validation<FAIL, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MValidation<FAIL, HashSet<A>>, Validation<FAIL, HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, HashSet<B>> Select<FAIL, A, B>(this Validation<FAIL, HashSet<A>> ma, Func<A, B> f) =>
            Trans<MValidation<FAIL, HashSet<A>>, Validation<FAIL, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MValidation<FAIL, HashSet<B>>, Validation<FAIL, HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Validation&lt;FAIL, HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, HashSet&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Validation&lt;FAIL, HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, FAIL, A>(this Validation<FAIL, HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MValidation<FAIL, HashSet<A>>, Validation<FAIL, HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Validation&lt;FAIL, HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, HashSet&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Validation&lt;FAIL, HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<FAIL, A>(this Validation<FAIL, HashSet<A>> ma) =>
            Trans<MValidation<FAIL, HashSet<A>>, Validation<FAIL, HashSet<A>>, MHashSet<A>, HashSet<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Validation&lt;FAIL, HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, HashSet<B>> BindT<FAIL, A, B>(this Validation<FAIL, HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            Trans<MValidation<FAIL, HashSet<A>>, Validation<FAIL, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MValidation<FAIL, HashSet<B>>, Validation<FAIL, HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Validation&lt;FAIL, HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, HashSet<B>> BindT<FAIL, A, B>(this Validation<FAIL, HashSet<A>> ma, Func<A, Validation<FAIL, HashSet<B>>> f) =>
            Trans<MValidation<FAIL, HashSet<A>>, Validation<FAIL, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MValidation<FAIL, HashSet<B>>, Validation<FAIL, HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Validation&lt;FAIL, HashSet&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `HashSet&lt;Validation&lt;FAIL, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;Validation&lt;FAIL, B&gt;&gt;`</returns>
        [Pure]
        public static HashSet<Validation<FAIL, B>> Traverse<FAIL, A, B>(this Validation<FAIL, HashSet<A>> ma, Func<A, B> f) =>
            SeqTrans<MValidation<FAIL, HashSet<A>>, Validation<FAIL, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Traverse<MHashSet<Validation<FAIL, B>>, HashSet<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Validation&lt;FAIL, HashSet&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `HashSet&lt;Validation&lt;FAIL, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<FAIL, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static HashSet<Validation<FAIL, A>> Sequence<FAIL, A>(this Validation<FAIL, HashSet<A>> ma) =>
            ma.Traverse<FAIL, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, HashSet<B>> MapT<FAIL, A, B>(this Validation<FAIL, HashSet<A>> ma, Func<A, B> f) =>
            Trans<MValidation<FAIL, HashSet<A>>, Validation<FAIL, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Map<MValidation<FAIL, HashSet<B>>, Validation<FAIL, HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, FAIL, A>(this Validation<FAIL, HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MValidation<FAIL, HashSet<A>>, Validation<FAIL, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, FAIL, A>(this Validation<FAIL, HashSet<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MValidation<FAIL, HashSet<A>>, Validation<FAIL, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<FAIL, A>(this Validation<FAIL, HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MValidation<FAIL, HashSet<A>>, Validation<FAIL, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<FAIL, A>(this Validation<FAIL, HashSet<A>> ma, Func<A, bool> f) =>
            Trans<MValidation<FAIL, HashSet<A>>, Validation<FAIL, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Validation&lt;FAIL, HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<FAIL, A>(this Validation<FAIL, HashSet<A>> ma, Action<A> f) =>
            Trans<MValidation<FAIL, HashSet<A>>, Validation<FAIL, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, HashSet&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, HashSet<A>> FilterT<FAIL, A>(this Validation<FAIL, HashSet<A>> ma, Func<A, bool> pred) =>
            Trans<MValidation<FAIL, HashSet<A>>, Validation<FAIL, HashSet<A>>, MHashSet<A>, HashSet<A>, A>
                .Inst.Bind<MValidation<FAIL, HashSet<A>>, Validation<FAIL, HashSet<A>>, MHashSet<A>, HashSet<A>, A>(ma, 
                    a => pred(a)
                        ? default(MHashSet<A>).Return(a)
                        : default(MHashSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, HashSet&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Validation<FAIL, HashSet<A>> PlusT<NUM, FAIL, A>(this Validation<FAIL, HashSet<A>> x, Validation<FAIL, HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, HashSet&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Validation<FAIL, HashSet<A>> SubtractT<NUM, FAIL, A>(this Validation<FAIL, HashSet<A>> x, Validation<FAIL, HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, HashSet&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Validation<FAIL, HashSet<A>> ProductT<NUM, FAIL, A>(this Validation<FAIL, HashSet<A>> x, Validation<FAIL, HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, HashSet&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Validation<FAIL, HashSet<A>> DivideT<NUM, FAIL, A>(this Validation<FAIL, HashSet<A>> x, Validation<FAIL, HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, HashSet&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Validation<FAIL, HashSet<A>> AppendT<SEMI, FAIL, A>(this Validation<FAIL, HashSet<A>> x, Validation<FAIL, HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, FAIL, A>(this Validation<FAIL, HashSet<A>> x, Validation<FAIL, HashSet<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, HashSet&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, FAIL, A>(this Validation<FAIL, HashSet<A>> x, Validation<FAIL, HashSet<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Validation&lt;FAIL, HashSet&lt;A&gt;&gt;`</param>
        /// <returns>`Validation&lt;FAIL, HashSet&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Validation<FAIL, HashSet<B>> ApplyT<FAIL, A, B>(this Func<A, B> fab, Validation<FAIL, HashSet<A>> fa) =>
            ApplValidation<FAIL, HashSet<A>, HashSet<B>>.Inst.Apply(
                 MValidation<FAIL, Func<HashSet<A>, HashSet<B>>>.Inst.Return((HashSet<A> a) => ApplHashSet< A, B>.Inst.Apply(
                     MHashSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Validation&lt;FAIL, HashSet&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Validation&lt;FAIL, HashSet&lt;A&gt;&gt;`</param>
        /// <returns>`Validation&lt;FAIL, HashSet&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Validation<FAIL, HashSet<C>> ApplyT<FAIL, A, B, C>(this Func<A, B, C> fabc, Validation<FAIL, HashSet<A>> fa, Validation<FAIL, HashSet<B>> fb) =>
            ApplValidation<FAIL, HashSet<A>, HashSet<B>, HashSet<C>>.Inst.Apply(
                MValidation<FAIL, Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>.Inst.Return(
                    (HashSet<A> a) =>
                        (HashSet<B> b) =>
                            ApplHashSet< A, B, C>.Inst.Apply(
                                MHashSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    /// <summary>
    /// Monad transformer for Lst, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class LstT_Extensions
    {
        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Arr&lt;Lst&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<Lst<C>> SelectMany< A, B, C>(
            this Arr<Lst<A>> ma,
            Func<A, Arr<Lst<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MArr<Lst<C>>, Arr<Lst<C>>, MLst<C>, Lst<C>, C>(ma, a =>
                    SeqTrans<MArr<Lst<B>>, Arr<Lst<B>>, MLst<B>, Lst<B>, B>
                        .Inst.Bind<MArr<Lst<C>>, Arr<Lst<C>>, MLst<C>, Lst<C>, C>(bind(a), b =>
                            default(MLst<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;Lst&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<Lst<A>> Where< A>(this Arr<Lst<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Lst<B>> Select< A, B>(this Arr<Lst<A>> ma, Func<A, B> f) =>
            SeqTrans<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MArr<Lst<B>>, Arr<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Arr&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Lst&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Arr&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Arr<Lst<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Arr&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Lst&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Arr&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Arr<Lst<A>> ma) =>
            SeqTrans<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Lst<B>> BindT< A, B>(this Arr<Lst<A>> ma, Func<A, Lst<B>> f) =>
            SeqTrans<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MArr<Lst<B>>, Arr<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Lst<B>> BindT< A, B>(this Arr<Lst<A>> ma, Func<A, Arr<Lst<B>>> f) =>
            SeqTrans<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MArr<Lst<B>>, Arr<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Arr&lt;Lst&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Lst&lt;Arr&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;Arr&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Lst<Arr<B>> Traverse< A, B>(this Arr<Lst<A>> ma, Func<A, B> f) =>
            SeqTrans<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<Arr<B>>, Lst<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Arr&lt;Lst&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Lst&lt;Arr&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Lst<Arr<A>> Sequence< A>(this Arr<Lst<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Lst<B>> MapT< A, B>(this Arr<Lst<A>> ma, Func<A, B> f) =>
            SeqTrans<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MArr<Lst<B>>, Arr<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Arr<Lst<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Arr<Lst<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Arr<Lst<A>> ma, Func<A, bool> f) =>
            SeqTrans<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Arr<Lst<A>> ma, Func<A, bool> f) =>
            SeqTrans<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Arr&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Arr<Lst<A>> ma, Action<A> f) =>
            SeqTrans<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;Lst&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<Lst<A>> FilterT< A>(this Arr<Lst<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MArr<Lst<A>>, Arr<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Lst&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Arr<Lst<A>> PlusT<NUM,  A>(this Arr<Lst<A>> x, Arr<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Lst&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Arr<Lst<A>> SubtractT<NUM,  A>(this Arr<Lst<A>> x, Arr<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Arr<Lst<A>> ProductT<NUM,  A>(this Arr<Lst<A>> x, Arr<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Arr<Lst<A>> DivideT<NUM,  A>(this Arr<Lst<A>> x, Arr<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Arr<Lst<A>> AppendT<SEMI,  A>(this Arr<Lst<A>> x, Arr<Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Arr<Lst<A>> x, Arr<Lst<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Arr<Lst<A>> x, Arr<Lst<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Arr&lt;Lst&lt;A&gt;&gt;`</param>
        /// <returns>`Arr&lt;Lst&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Arr<Lst<B>> ApplyT< A, B>(this Func<A, B> fab, Arr<Lst<A>> fa) =>
            ApplArr< Lst<A>, Lst<B>>.Inst.Apply(
                 MArr< Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => ApplLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Arr&lt;Lst&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Arr&lt;Lst&lt;A&gt;&gt;`</param>
        /// <returns>`Arr&lt;Lst&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Arr<Lst<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Arr<Lst<A>> fa, Arr<Lst<B>> fb) =>
            ApplArr< Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MArr< Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            ApplLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`HashSet&lt;Lst&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<Lst<C>> SelectMany< A, B, C>(
            this HashSet<Lst<A>> ma,
            Func<A, HashSet<Lst<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MHashSet<Lst<C>>, HashSet<Lst<C>>, MLst<C>, Lst<C>, C>(ma, a =>
                    SeqTrans<MHashSet<Lst<B>>, HashSet<Lst<B>>, MLst<B>, Lst<B>, B>
                        .Inst.Bind<MHashSet<Lst<C>>, HashSet<Lst<C>>, MLst<C>, Lst<C>, C>(bind(a), b =>
                            default(MLst<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;Lst&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<Lst<A>> Where< A>(this HashSet<Lst<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Lst<B>> Select< A, B>(this HashSet<Lst<A>> ma, Func<A, B> f) =>
            SeqTrans<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MHashSet<Lst<B>>, HashSet<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `HashSet&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Lst&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `HashSet&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this HashSet<Lst<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `HashSet&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Lst&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `HashSet&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this HashSet<Lst<A>> ma) =>
            SeqTrans<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Lst<B>> BindT< A, B>(this HashSet<Lst<A>> ma, Func<A, Lst<B>> f) =>
            SeqTrans<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MHashSet<Lst<B>>, HashSet<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Lst<B>> BindT< A, B>(this HashSet<Lst<A>> ma, Func<A, HashSet<Lst<B>>> f) =>
            SeqTrans<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MHashSet<Lst<B>>, HashSet<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `HashSet&lt;Lst&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Lst&lt;HashSet&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;HashSet&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Lst<HashSet<B>> Traverse< A, B>(this HashSet<Lst<A>> ma, Func<A, B> f) =>
            SeqTrans<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<HashSet<B>>, Lst<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `HashSet&lt;Lst&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Lst&lt;HashSet&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Lst<HashSet<A>> Sequence< A>(this HashSet<Lst<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Lst<B>> MapT< A, B>(this HashSet<Lst<A>> ma, Func<A, B> f) =>
            SeqTrans<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MHashSet<Lst<B>>, HashSet<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this HashSet<Lst<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this HashSet<Lst<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this HashSet<Lst<A>> ma, Func<A, bool> f) =>
            SeqTrans<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this HashSet<Lst<A>> ma, Func<A, bool> f) =>
            SeqTrans<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `HashSet&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this HashSet<Lst<A>> ma, Action<A> f) =>
            SeqTrans<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;Lst&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<Lst<A>> FilterT< A>(this HashSet<Lst<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MHashSet<Lst<A>>, HashSet<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Lst&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<Lst<A>> PlusT<NUM,  A>(this HashSet<Lst<A>> x, HashSet<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Lst&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<Lst<A>> SubtractT<NUM,  A>(this HashSet<Lst<A>> x, HashSet<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static HashSet<Lst<A>> ProductT<NUM,  A>(this HashSet<Lst<A>> x, HashSet<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static HashSet<Lst<A>> DivideT<NUM,  A>(this HashSet<Lst<A>> x, HashSet<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static HashSet<Lst<A>> AppendT<SEMI,  A>(this HashSet<Lst<A>> x, HashSet<Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this HashSet<Lst<A>> x, HashSet<Lst<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this HashSet<Lst<A>> x, HashSet<Lst<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `HashSet&lt;Lst&lt;A&gt;&gt;`</param>
        /// <returns>`HashSet&lt;Lst&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static HashSet<Lst<B>> ApplyT< A, B>(this Func<A, B> fab, HashSet<Lst<A>> fa) =>
            ApplHashSet< Lst<A>, Lst<B>>.Inst.Apply(
                 MHashSet< Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => ApplLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `HashSet&lt;Lst&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `HashSet&lt;Lst&lt;A&gt;&gt;`</param>
        /// <returns>`HashSet&lt;Lst&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static HashSet<Lst<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, HashSet<Lst<A>> fa, HashSet<Lst<B>> fb) =>
            ApplHashSet< Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MHashSet< Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            ApplLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Lst&lt;Lst&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<Lst<C>> SelectMany< A, B, C>(
            this Lst<Lst<A>> ma,
            Func<A, Lst<Lst<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MLst<Lst<C>>, Lst<Lst<C>>, MLst<C>, Lst<C>, C>(ma, a =>
                    SeqTrans<MLst<Lst<B>>, Lst<Lst<B>>, MLst<B>, Lst<B>, B>
                        .Inst.Bind<MLst<Lst<C>>, Lst<Lst<C>>, MLst<C>, Lst<C>, C>(bind(a), b =>
                            default(MLst<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;Lst&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<Lst<A>> Where< A>(this Lst<Lst<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Lst<B>> Select< A, B>(this Lst<Lst<A>> ma, Func<A, B> f) =>
            SeqTrans<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MLst<Lst<B>>, Lst<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Lst&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Lst&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Lst&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Lst<Lst<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Lst&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Lst&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Lst&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Lst<Lst<A>> ma) =>
            SeqTrans<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Lst<B>> BindT< A, B>(this Lst<Lst<A>> ma, Func<A, Lst<B>> f) =>
            SeqTrans<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MLst<Lst<B>>, Lst<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Lst<B>> BindT< A, B>(this Lst<Lst<A>> ma, Func<A, Lst<Lst<B>>> f) =>
            SeqTrans<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MLst<Lst<B>>, Lst<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Lst&lt;Lst&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Lst&lt;Lst&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;Lst&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Lst<Lst<B>> Traverse< A, B>(this Lst<Lst<A>> ma, Func<A, B> f) =>
            SeqTrans<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<Lst<B>>, Lst<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Lst&lt;Lst&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Lst&lt;Lst&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Lst<Lst<A>> Sequence< A>(this Lst<Lst<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Lst<B>> MapT< A, B>(this Lst<Lst<A>> ma, Func<A, B> f) =>
            SeqTrans<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MLst<Lst<B>>, Lst<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Lst<Lst<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Lst<Lst<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Lst<Lst<A>> ma, Func<A, bool> f) =>
            SeqTrans<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Lst<Lst<A>> ma, Func<A, bool> f) =>
            SeqTrans<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Lst&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Lst<Lst<A>> ma, Action<A> f) =>
            SeqTrans<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;Lst&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<Lst<A>> FilterT< A>(this Lst<Lst<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MLst<Lst<A>>, Lst<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Lst&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Lst<Lst<A>> PlusT<NUM,  A>(this Lst<Lst<A>> x, Lst<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Lst&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Lst<Lst<A>> SubtractT<NUM,  A>(this Lst<Lst<A>> x, Lst<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Lst<Lst<A>> ProductT<NUM,  A>(this Lst<Lst<A>> x, Lst<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Lst<Lst<A>> DivideT<NUM,  A>(this Lst<Lst<A>> x, Lst<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Lst<Lst<A>> AppendT<SEMI,  A>(this Lst<Lst<A>> x, Lst<Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Lst<Lst<A>> x, Lst<Lst<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Lst<Lst<A>> x, Lst<Lst<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Lst&lt;Lst&lt;A&gt;&gt;`</param>
        /// <returns>`Lst&lt;Lst&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Lst<Lst<B>> ApplyT< A, B>(this Func<A, B> fab, Lst<Lst<A>> fa) =>
            ApplLst< Lst<A>, Lst<B>>.Inst.Apply(
                 MLst< Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => ApplLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Lst&lt;Lst&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Lst&lt;Lst&lt;A&gt;&gt;`</param>
        /// <returns>`Lst&lt;Lst&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Lst<Lst<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Lst<Lst<A>> fa, Lst<Lst<B>> fb) =>
            ApplLst< Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MLst< Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            ApplLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Option&lt;Lst&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Option<Lst<C>> SelectMany< A, B, C>(
            this Option<Lst<A>> ma,
            Func<A, Option<Lst<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MOption<Lst<C>>, Option<Lst<C>>, MLst<C>, Lst<C>, C>(ma, a =>
                    Trans<MOption<Lst<B>>, Option<Lst<B>>, MLst<B>, Lst<B>, B>
                        .Inst.Bind<MOption<Lst<C>>, Option<Lst<C>>, MLst<C>, Lst<C>, C>(bind(a), b =>
                            default(MLst<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;Lst&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<Lst<A>> Where< A>(this Option<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Lst<B>> Select< A, B>(this Option<Lst<A>> ma, Func<A, B> f) =>
            Trans<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MOption<Lst<B>>, Option<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Option&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Lst&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Option&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Option<Lst<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Option&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Lst&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Option&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Option<Lst<A>> ma) =>
            Trans<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Lst<B>> BindT< A, B>(this Option<Lst<A>> ma, Func<A, Lst<B>> f) =>
            Trans<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MOption<Lst<B>>, Option<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Lst<B>> BindT< A, B>(this Option<Lst<A>> ma, Func<A, Option<Lst<B>>> f) =>
            Trans<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MOption<Lst<B>>, Option<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Option&lt;Lst&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Lst&lt;Option&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;Option&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Lst<Option<B>> Traverse< A, B>(this Option<Lst<A>> ma, Func<A, B> f) =>
            SeqTrans<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<Option<B>>, Lst<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Option&lt;Lst&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Lst&lt;Option&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Lst<Option<A>> Sequence< A>(this Option<Lst<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Lst<B>> MapT< A, B>(this Option<Lst<A>> ma, Func<A, B> f) =>
            Trans<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MOption<Lst<B>>, Option<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Option<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Option<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Option<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Option<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Option&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Option<Lst<A>> ma, Action<A> f) =>
            Trans<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;Lst&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<Lst<A>> FilterT< A>(this Option<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MOption<Lst<A>>, Option<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Lst&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Option<Lst<A>> PlusT<NUM,  A>(this Option<Lst<A>> x, Option<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Lst&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Option<Lst<A>> SubtractT<NUM,  A>(this Option<Lst<A>> x, Option<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Option<Lst<A>> ProductT<NUM,  A>(this Option<Lst<A>> x, Option<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Option<Lst<A>> DivideT<NUM,  A>(this Option<Lst<A>> x, Option<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Option<Lst<A>> AppendT<SEMI,  A>(this Option<Lst<A>> x, Option<Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Option<Lst<A>> x, Option<Lst<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Option<Lst<A>> x, Option<Lst<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Option&lt;Lst&lt;A&gt;&gt;`</param>
        /// <returns>`Option&lt;Lst&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Option<Lst<B>> ApplyT< A, B>(this Func<A, B> fab, Option<Lst<A>> fa) =>
            ApplOption< Lst<A>, Lst<B>>.Inst.Apply(
                 MOption< Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => ApplLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Option&lt;Lst&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Option&lt;Lst&lt;A&gt;&gt;`</param>
        /// <returns>`Option&lt;Lst&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Option<Lst<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Option<Lst<A>> fa, Option<Lst<B>> fb) =>
            ApplOption< Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MOption< Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            ApplLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionUnsafe&lt;Lst&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<Lst<C>> SelectMany< A, B, C>(
            this OptionUnsafe<Lst<A>> ma,
            Func<A, OptionUnsafe<Lst<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MOptionUnsafe<Lst<C>>, OptionUnsafe<Lst<C>>, MLst<C>, Lst<C>, C>(ma, a =>
                    Trans<MOptionUnsafe<Lst<B>>, OptionUnsafe<Lst<B>>, MLst<B>, Lst<B>, B>
                        .Inst.Bind<MOptionUnsafe<Lst<C>>, OptionUnsafe<Lst<C>>, MLst<C>, Lst<C>, C>(bind(a), b =>
                            default(MLst<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;Lst&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<Lst<A>> Where< A>(this OptionUnsafe<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Lst<B>> Select< A, B>(this OptionUnsafe<Lst<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MOptionUnsafe<Lst<B>>, OptionUnsafe<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionUnsafe&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Lst&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionUnsafe&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this OptionUnsafe<Lst<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionUnsafe&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Lst&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionUnsafe&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this OptionUnsafe<Lst<A>> ma) =>
            Trans<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Lst<B>> BindT< A, B>(this OptionUnsafe<Lst<A>> ma, Func<A, Lst<B>> f) =>
            Trans<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MOptionUnsafe<Lst<B>>, OptionUnsafe<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Lst<B>> BindT< A, B>(this OptionUnsafe<Lst<A>> ma, Func<A, OptionUnsafe<Lst<B>>> f) =>
            Trans<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MOptionUnsafe<Lst<B>>, OptionUnsafe<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionUnsafe&lt;Lst&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Lst&lt;OptionUnsafe&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;OptionUnsafe&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Lst<OptionUnsafe<B>> Traverse< A, B>(this OptionUnsafe<Lst<A>> ma, Func<A, B> f) =>
            SeqTrans<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<OptionUnsafe<B>>, Lst<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionUnsafe&lt;Lst&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Lst&lt;OptionUnsafe&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Lst<OptionUnsafe<A>> Sequence< A>(this OptionUnsafe<Lst<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Lst<B>> MapT< A, B>(this OptionUnsafe<Lst<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MOptionUnsafe<Lst<B>>, OptionUnsafe<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this OptionUnsafe<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this OptionUnsafe<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this OptionUnsafe<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this OptionUnsafe<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionUnsafe&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this OptionUnsafe<Lst<A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;Lst&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<Lst<A>> FilterT< A>(this OptionUnsafe<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MOptionUnsafe<Lst<A>>, OptionUnsafe<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Lst&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<Lst<A>> PlusT<NUM,  A>(this OptionUnsafe<Lst<A>> x, OptionUnsafe<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Lst&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<Lst<A>> SubtractT<NUM,  A>(this OptionUnsafe<Lst<A>> x, OptionUnsafe<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionUnsafe<Lst<A>> ProductT<NUM,  A>(this OptionUnsafe<Lst<A>> x, OptionUnsafe<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionUnsafe<Lst<A>> DivideT<NUM,  A>(this OptionUnsafe<Lst<A>> x, OptionUnsafe<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionUnsafe<Lst<A>> AppendT<SEMI,  A>(this OptionUnsafe<Lst<A>> x, OptionUnsafe<Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this OptionUnsafe<Lst<A>> x, OptionUnsafe<Lst<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this OptionUnsafe<Lst<A>> x, OptionUnsafe<Lst<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe&lt;Lst&lt;A&gt;&gt;`</param>
        /// <returns>`OptionUnsafe&lt;Lst&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionUnsafe<Lst<B>> ApplyT< A, B>(this Func<A, B> fab, OptionUnsafe<Lst<A>> fa) =>
            ApplOptionUnsafe< Lst<A>, Lst<B>>.Inst.Apply(
                 MOptionUnsafe< Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => ApplLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe&lt;Lst&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `OptionUnsafe&lt;Lst&lt;A&gt;&gt;`</param>
        /// <returns>`OptionUnsafe&lt;Lst&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionUnsafe<Lst<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, OptionUnsafe<Lst<A>> fa, OptionUnsafe<Lst<B>> fb) =>
            ApplOptionUnsafe< Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MOptionUnsafe< Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            ApplLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Either&lt;L, Lst&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, Lst<C>> SelectMany<L, A, B, C>(
            this Either<L, Lst<A>> ma,
            Func<A, Either<L, Lst<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MEither<L, Lst<C>>, Either<L, Lst<C>>, MLst<C>, Lst<C>, C>(ma, a =>
                    Trans<MEither<L, Lst<B>>, Either<L, Lst<B>>, MLst<B>, Lst<B>, B>
                        .Inst.Bind<MEither<L, Lst<C>>, Either<L, Lst<C>>, MLst<C>, Lst<C>, C>(bind(a), b =>
                            default(MLst<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, Lst&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, Lst<A>> Where<L, A>(this Either<L, Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Lst<B>> Select<L, A, B>(this Either<L, Lst<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MEither<L, Lst<B>>, Either<L, Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Either&lt;L, Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Lst&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Either&lt;L, Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Either<L, Lst<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Either&lt;L, Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Lst&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Either&lt;L, Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this Either<L, Lst<A>> ma) =>
            Trans<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either&lt;L, Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Lst<B>> BindT<L, A, B>(this Either<L, Lst<A>> ma, Func<A, Lst<B>> f) =>
            Trans<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MEither<L, Lst<B>>, Either<L, Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either&lt;L, Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Lst<B>> BindT<L, A, B>(this Either<L, Lst<A>> ma, Func<A, Either<L, Lst<B>>> f) =>
            Trans<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MEither<L, Lst<B>>, Either<L, Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Either&lt;L, Lst&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Lst&lt;Either&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;Either&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static Lst<Either<L, B>> Traverse<L, A, B>(this Either<L, Lst<A>> ma, Func<A, B> f) =>
            SeqTrans<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<Either<L, B>>, Lst<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Either&lt;L, Lst&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Lst&lt;Either&lt;L, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static Lst<Either<L, A>> Sequence<L, A>(this Either<L, Lst<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Lst<B>> MapT<L, A, B>(this Either<L, Lst<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MEither<L, Lst<B>>, Either<L, Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Either<L, Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Either<L, Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Either<L, Lst<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Either<L, Lst<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Either&lt;L, Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Either<L, Lst<A>> ma, Action<A> f) =>
            Trans<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, Lst&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, Lst<A>> FilterT<L, A>(this Either<L, Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MEither<L, Lst<A>>, Either<L, Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Lst&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, Lst<A>> PlusT<NUM, L, A>(this Either<L, Lst<A>> x, Either<L, Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Lst&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, Lst<A>> SubtractT<NUM, L, A>(this Either<L, Lst<A>> x, Either<L, Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Lst&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Either<L, Lst<A>> ProductT<NUM, L, A>(this Either<L, Lst<A>> x, Either<L, Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Lst&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Either<L, Lst<A>> DivideT<NUM, L, A>(this Either<L, Lst<A>> x, Either<L, Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Lst&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Either<L, Lst<A>> AppendT<SEMI, L, A>(this Either<L, Lst<A>> x, Either<L, Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Either<L, Lst<A>> x, Either<L, Lst<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Lst&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Either<L, Lst<A>> x, Either<L, Lst<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Either&lt;L, Lst&lt;A&gt;&gt;`</param>
        /// <returns>`Either&lt;L, Lst&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Either<L, Lst<B>> ApplyT<L, A, B>(this Func<A, B> fab, Either<L, Lst<A>> fa) =>
            ApplEither<L, Lst<A>, Lst<B>>.Inst.Apply(
                 MEither<L, Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => ApplLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Either&lt;L, Lst&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Either&lt;L, Lst&lt;A&gt;&gt;`</param>
        /// <returns>`Either&lt;L, Lst&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Either<L, Lst<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Either<L, Lst<A>> fa, Either<L, Lst<B>> fb) =>
            ApplEither<L, Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MEither<L, Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            ApplLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`EitherUnsafe&lt;L, Lst&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, Lst<A>> ma,
            Func<A, EitherUnsafe<L, Lst<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Lst<C>>, EitherUnsafe<L, Lst<C>>, MLst<C>, Lst<C>, C>(ma, a =>
                    Trans<MEitherUnsafe<L, Lst<B>>, EitherUnsafe<L, Lst<B>>, MLst<B>, Lst<B>, B>
                        .Inst.Bind<MEitherUnsafe<L, Lst<C>>, EitherUnsafe<L, Lst<C>>, MLst<C>, Lst<C>, C>(bind(a), b =>
                            default(MLst<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, Lst&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<A>> Where<L, A>(this EitherUnsafe<L, Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<B>> Select<L, A, B>(this EitherUnsafe<L, Lst<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MEitherUnsafe<L, Lst<B>>, EitherUnsafe<L, Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherUnsafe&lt;L, Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Lst&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherUnsafe&lt;L, Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this EitherUnsafe<L, Lst<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherUnsafe&lt;L, Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Lst&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherUnsafe&lt;L, Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this EitherUnsafe<L, Lst<A>> ma) =>
            Trans<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<B>> BindT<L, A, B>(this EitherUnsafe<L, Lst<A>> ma, Func<A, Lst<B>> f) =>
            Trans<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Lst<B>>, EitherUnsafe<L, Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<B>> BindT<L, A, B>(this EitherUnsafe<L, Lst<A>> ma, Func<A, EitherUnsafe<L, Lst<B>>> f) =>
            Trans<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Lst<B>>, EitherUnsafe<L, Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `EitherUnsafe&lt;L, Lst&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Lst&lt;EitherUnsafe&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;EitherUnsafe&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, B>> Traverse<L, A, B>(this EitherUnsafe<L, Lst<A>> ma, Func<A, B> f) =>
            SeqTrans<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<EitherUnsafe<L, B>>, Lst<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `EitherUnsafe&lt;L, Lst&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Lst&lt;EitherUnsafe&lt;L, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, A>> Sequence<L, A>(this EitherUnsafe<L, Lst<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<B>> MapT<L, A, B>(this EitherUnsafe<L, Lst<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MEitherUnsafe<L, Lst<B>>, EitherUnsafe<L, Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this EitherUnsafe<L, Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this EitherUnsafe<L, Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this EitherUnsafe<L, Lst<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this EitherUnsafe<L, Lst<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherUnsafe&lt;L, Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this EitherUnsafe<L, Lst<A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, Lst&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<A>> FilterT<L, A>(this EitherUnsafe<L, Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Lst<A>>, EitherUnsafe<L, Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Lst&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<A>> PlusT<NUM, L, A>(this EitherUnsafe<L, Lst<A>> x, EitherUnsafe<L, Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Lst&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<A>> SubtractT<NUM, L, A>(this EitherUnsafe<L, Lst<A>> x, EitherUnsafe<L, Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Lst&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<A>> ProductT<NUM, L, A>(this EitherUnsafe<L, Lst<A>> x, EitherUnsafe<L, Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Lst&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<A>> DivideT<NUM, L, A>(this EitherUnsafe<L, Lst<A>> x, EitherUnsafe<L, Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Lst&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<A>> AppendT<SEMI, L, A>(this EitherUnsafe<L, Lst<A>> x, EitherUnsafe<L, Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this EitherUnsafe<L, Lst<A>> x, EitherUnsafe<L, Lst<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Lst&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this EitherUnsafe<L, Lst<A>> x, EitherUnsafe<L, Lst<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe&lt;L, Lst&lt;A&gt;&gt;`</param>
        /// <returns>`EitherUnsafe&lt;L, Lst&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherUnsafe<L, Lst<A>> fa) =>
            ApplEitherUnsafe<L, Lst<A>, Lst<B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => ApplLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe&lt;L, Lst&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `EitherUnsafe&lt;L, Lst&lt;A&gt;&gt;`</param>
        /// <returns>`EitherUnsafe&lt;L, Lst&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherUnsafe<L, Lst<A>> fa, EitherUnsafe<L, Lst<B>> fb) =>
            ApplEitherUnsafe<L, Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MEitherUnsafe<L, Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            ApplLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Try&lt;Lst&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Try<Lst<C>> SelectMany< A, B, C>(
            this Try<Lst<A>> ma,
            Func<A, Try<Lst<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MTry<Lst<C>>, Try<Lst<C>>, MLst<C>, Lst<C>, C>(ma, a =>
                    Trans<MTry<Lst<B>>, Try<Lst<B>>, MLst<B>, Lst<B>, B>
                        .Inst.Bind<MTry<Lst<C>>, Try<Lst<C>>, MLst<C>, Lst<C>, C>(bind(a), b =>
                            default(MLst<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;Lst&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<Lst<A>> Where< A>(this Try<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Lst<B>> Select< A, B>(this Try<Lst<A>> ma, Func<A, B> f) =>
            Trans<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MTry<Lst<B>>, Try<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Try&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Lst&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Try&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Try<Lst<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Try&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Lst&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Try&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Try<Lst<A>> ma) =>
            Trans<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Lst<B>> BindT< A, B>(this Try<Lst<A>> ma, Func<A, Lst<B>> f) =>
            Trans<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MTry<Lst<B>>, Try<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Lst<B>> BindT< A, B>(this Try<Lst<A>> ma, Func<A, Try<Lst<B>>> f) =>
            Trans<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MTry<Lst<B>>, Try<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Try&lt;Lst&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Lst&lt;Try&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;Try&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Lst<Try<B>> Traverse< A, B>(this Try<Lst<A>> ma, Func<A, B> f) =>
            SeqTrans<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<Try<B>>, Lst<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Try&lt;Lst&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Lst&lt;Try&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Lst<Try<A>> Sequence< A>(this Try<Lst<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Lst<B>> MapT< A, B>(this Try<Lst<A>> ma, Func<A, B> f) =>
            Trans<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MTry<Lst<B>>, Try<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Try<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Try<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Try<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Try<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Try&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Try<Lst<A>> ma, Action<A> f) =>
            Trans<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;Lst&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<Lst<A>> FilterT< A>(this Try<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MTry<Lst<A>>, Try<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Lst&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Try<Lst<A>> PlusT<NUM,  A>(this Try<Lst<A>> x, Try<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Lst&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Try<Lst<A>> SubtractT<NUM,  A>(this Try<Lst<A>> x, Try<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Try<Lst<A>> ProductT<NUM,  A>(this Try<Lst<A>> x, Try<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Try<Lst<A>> DivideT<NUM,  A>(this Try<Lst<A>> x, Try<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Try<Lst<A>> AppendT<SEMI,  A>(this Try<Lst<A>> x, Try<Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Try<Lst<A>> x, Try<Lst<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Try<Lst<A>> x, Try<Lst<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Try&lt;Lst&lt;A&gt;&gt;`</param>
        /// <returns>`Try&lt;Lst&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Try<Lst<B>> ApplyT< A, B>(this Func<A, B> fab, Try<Lst<A>> fa) =>
            ApplTry< Lst<A>, Lst<B>>.Inst.Apply(
                 MTry< Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => ApplLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Try&lt;Lst&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Try&lt;Lst&lt;A&gt;&gt;`</param>
        /// <returns>`Try&lt;Lst&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Try<Lst<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Try<Lst<A>> fa, Try<Lst<B>> fb) =>
            ApplTry< Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MTry< Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            ApplLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOption&lt;Lst&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<Lst<C>> SelectMany< A, B, C>(
            this TryOption<Lst<A>> ma,
            Func<A, TryOption<Lst<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MTryOption<Lst<C>>, TryOption<Lst<C>>, MLst<C>, Lst<C>, C>(ma, a =>
                    Trans<MTryOption<Lst<B>>, TryOption<Lst<B>>, MLst<B>, Lst<B>, B>
                        .Inst.Bind<MTryOption<Lst<C>>, TryOption<Lst<C>>, MLst<C>, Lst<C>, C>(bind(a), b =>
                            default(MLst<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;Lst&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<Lst<A>> Where< A>(this TryOption<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Lst<B>> Select< A, B>(this TryOption<Lst<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MTryOption<Lst<B>>, TryOption<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOption&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Lst&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOption&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryOption<Lst<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOption&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Lst&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOption&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this TryOption<Lst<A>> ma) =>
            Trans<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Lst<B>> BindT< A, B>(this TryOption<Lst<A>> ma, Func<A, Lst<B>> f) =>
            Trans<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MTryOption<Lst<B>>, TryOption<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Lst<B>> BindT< A, B>(this TryOption<Lst<A>> ma, Func<A, TryOption<Lst<B>>> f) =>
            Trans<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MTryOption<Lst<B>>, TryOption<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOption&lt;Lst&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Lst&lt;TryOption&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;TryOption&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Lst<TryOption<B>> Traverse< A, B>(this TryOption<Lst<A>> ma, Func<A, B> f) =>
            SeqTrans<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<TryOption<B>>, Lst<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOption&lt;Lst&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Lst&lt;TryOption&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Lst<TryOption<A>> Sequence< A>(this TryOption<Lst<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Lst<B>> MapT< A, B>(this TryOption<Lst<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MTryOption<Lst<B>>, TryOption<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryOption<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryOption<Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryOption<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryOption<Lst<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOption&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryOption<Lst<A>> ma, Action<A> f) =>
            Trans<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;Lst&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<Lst<A>> FilterT< A>(this TryOption<Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MTryOption<Lst<A>>, TryOption<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Lst&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<Lst<A>> PlusT<NUM,  A>(this TryOption<Lst<A>> x, TryOption<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Lst&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<Lst<A>> SubtractT<NUM,  A>(this TryOption<Lst<A>> x, TryOption<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOption<Lst<A>> ProductT<NUM,  A>(this TryOption<Lst<A>> x, TryOption<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOption<Lst<A>> DivideT<NUM,  A>(this TryOption<Lst<A>> x, TryOption<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOption<Lst<A>> AppendT<SEMI,  A>(this TryOption<Lst<A>> x, TryOption<Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryOption<Lst<A>> x, TryOption<Lst<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryOption<Lst<A>> x, TryOption<Lst<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOption&lt;Lst&lt;A&gt;&gt;`</param>
        /// <returns>`TryOption&lt;Lst&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOption<Lst<B>> ApplyT< A, B>(this Func<A, B> fab, TryOption<Lst<A>> fa) =>
            ApplTryOption< Lst<A>, Lst<B>>.Inst.Apply(
                 MTryOption< Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => ApplLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOption&lt;Lst&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryOption&lt;Lst&lt;A&gt;&gt;`</param>
        /// <returns>`TryOption&lt;Lst&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOption<Lst<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOption<Lst<A>> fa, TryOption<Lst<B>> fb) =>
            ApplTryOption< Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MTryOption< Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            ApplLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`IEnumerable&lt;Lst&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<Lst<C>> SelectMany< A, B, C>(
            this IEnumerable<Lst<A>> ma,
            Func<A, IEnumerable<Lst<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MEnumerable<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MEnumerable<Lst<C>>, IEnumerable<Lst<C>>, MLst<C>, Lst<C>, C>(ma, a =>
                    SeqTrans<MEnumerable<Lst<B>>, IEnumerable<Lst<B>>, MLst<B>, Lst<B>, B>
                        .Inst.Bind<MEnumerable<Lst<C>>, IEnumerable<Lst<C>>, MLst<C>, Lst<C>, C>(bind(a), b =>
                            default(MLst<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;Lst&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<Lst<A>> Where< A>(this IEnumerable<Lst<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MEnumerable<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MEnumerable<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Lst<B>> Select< A, B>(this IEnumerable<Lst<A>> ma, Func<A, B> f) =>
            SeqTrans<MEnumerable<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MEnumerable<Lst<B>>, IEnumerable<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `IEnumerable&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Lst&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `IEnumerable&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this IEnumerable<Lst<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MEnumerable<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `IEnumerable&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Lst&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `IEnumerable&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this IEnumerable<Lst<A>> ma) =>
            SeqTrans<MEnumerable<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Lst<B>> BindT< A, B>(this IEnumerable<Lst<A>> ma, Func<A, Lst<B>> f) =>
            SeqTrans<MEnumerable<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MEnumerable<Lst<B>>, IEnumerable<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Lst<B>> BindT< A, B>(this IEnumerable<Lst<A>> ma, Func<A, IEnumerable<Lst<B>>> f) =>
            SeqTrans<MEnumerable<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MEnumerable<Lst<B>>, IEnumerable<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `IEnumerable&lt;Lst&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Lst&lt;IEnumerable&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;IEnumerable&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Lst<IEnumerable<B>> Traverse< A, B>(this IEnumerable<Lst<A>> ma, Func<A, B> f) =>
            SeqTrans<MEnumerable<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<IEnumerable<B>>, Lst<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `IEnumerable&lt;Lst&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Lst&lt;IEnumerable&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Lst<IEnumerable<A>> Sequence< A>(this IEnumerable<Lst<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Lst<B>> MapT< A, B>(this IEnumerable<Lst<A>> ma, Func<A, B> f) =>
            SeqTrans<MEnumerable<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MEnumerable<Lst<B>>, IEnumerable<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this IEnumerable<Lst<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MEnumerable<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this IEnumerable<Lst<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MEnumerable<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this IEnumerable<Lst<A>> ma, Func<A, bool> f) =>
            SeqTrans<MEnumerable<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this IEnumerable<Lst<A>> ma, Func<A, bool> f) =>
            SeqTrans<MEnumerable<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `IEnumerable&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this IEnumerable<Lst<A>> ma, Action<A> f) =>
            SeqTrans<MEnumerable<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;Lst&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<Lst<A>> FilterT< A>(this IEnumerable<Lst<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MEnumerable<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MEnumerable<Lst<A>>, IEnumerable<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Lst&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<Lst<A>> PlusT<NUM,  A>(this IEnumerable<Lst<A>> x, IEnumerable<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Lst&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<Lst<A>> SubtractT<NUM,  A>(this IEnumerable<Lst<A>> x, IEnumerable<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static IEnumerable<Lst<A>> ProductT<NUM,  A>(this IEnumerable<Lst<A>> x, IEnumerable<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static IEnumerable<Lst<A>> DivideT<NUM,  A>(this IEnumerable<Lst<A>> x, IEnumerable<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static IEnumerable<Lst<A>> AppendT<SEMI,  A>(this IEnumerable<Lst<A>> x, IEnumerable<Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this IEnumerable<Lst<A>> x, IEnumerable<Lst<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this IEnumerable<Lst<A>> x, IEnumerable<Lst<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `IEnumerable&lt;Lst&lt;A&gt;&gt;`</param>
        /// <returns>`IEnumerable&lt;Lst&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static IEnumerable<Lst<B>> ApplyT< A, B>(this Func<A, B> fab, IEnumerable<Lst<A>> fa) =>
            ApplEnumerable< Lst<A>, Lst<B>>.Inst.Apply(
                 MEnumerable< Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => ApplLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `IEnumerable&lt;Lst&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `IEnumerable&lt;Lst&lt;A&gt;&gt;`</param>
        /// <returns>`IEnumerable&lt;Lst&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static IEnumerable<Lst<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, IEnumerable<Lst<A>> fa, IEnumerable<Lst<B>> fb) =>
            ApplEnumerable< Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MEnumerable< Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            ApplLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Seq&lt;Lst&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Seq<Lst<C>> SelectMany< A, B, C>(
            this Seq<Lst<A>> ma,
            Func<A, Seq<Lst<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MSeq<Lst<A>>, Seq<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MSeq<Lst<C>>, Seq<Lst<C>>, MLst<C>, Lst<C>, C>(ma, a =>
                    SeqTrans<MSeq<Lst<B>>, Seq<Lst<B>>, MLst<B>, Lst<B>, B>
                        .Inst.Bind<MSeq<Lst<C>>, Seq<Lst<C>>, MLst<C>, Lst<C>, C>(bind(a), b =>
                            default(MLst<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;Lst&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<Lst<A>> Where< A>(this Seq<Lst<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSeq<Lst<A>>, Seq<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MSeq<Lst<A>>, Seq<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<Lst<B>> Select< A, B>(this Seq<Lst<A>> ma, Func<A, B> f) =>
            SeqTrans<MSeq<Lst<A>>, Seq<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MSeq<Lst<B>>, Seq<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Seq&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Lst&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Seq&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Seq<Lst<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MSeq<Lst<A>>, Seq<Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Seq&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Lst&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Seq&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Seq<Lst<A>> ma) =>
            SeqTrans<MSeq<Lst<A>>, Seq<Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Seq&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<Lst<B>> BindT< A, B>(this Seq<Lst<A>> ma, Func<A, Lst<B>> f) =>
            SeqTrans<MSeq<Lst<A>>, Seq<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MSeq<Lst<B>>, Seq<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Seq&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<Lst<B>> BindT< A, B>(this Seq<Lst<A>> ma, Func<A, Seq<Lst<B>>> f) =>
            SeqTrans<MSeq<Lst<A>>, Seq<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MSeq<Lst<B>>, Seq<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Seq&lt;Lst&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Lst&lt;Seq&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;Seq&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Lst<Seq<B>> Traverse< A, B>(this Seq<Lst<A>> ma, Func<A, B> f) =>
            SeqTrans<MSeq<Lst<A>>, Seq<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<Seq<B>>, Lst<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Seq&lt;Lst&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Lst&lt;Seq&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Lst<Seq<A>> Sequence< A>(this Seq<Lst<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<Lst<B>> MapT< A, B>(this Seq<Lst<A>> ma, Func<A, B> f) =>
            SeqTrans<MSeq<Lst<A>>, Seq<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MSeq<Lst<B>>, Seq<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Seq<Lst<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSeq<Lst<A>>, Seq<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Seq<Lst<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSeq<Lst<A>>, Seq<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Seq<Lst<A>> ma, Func<A, bool> f) =>
            SeqTrans<MSeq<Lst<A>>, Seq<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Seq<Lst<A>> ma, Func<A, bool> f) =>
            SeqTrans<MSeq<Lst<A>>, Seq<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Seq&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Seq<Lst<A>> ma, Action<A> f) =>
            SeqTrans<MSeq<Lst<A>>, Seq<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;Lst&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<Lst<A>> FilterT< A>(this Seq<Lst<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSeq<Lst<A>>, Seq<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MSeq<Lst<A>>, Seq<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Lst&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Seq<Lst<A>> PlusT<NUM,  A>(this Seq<Lst<A>> x, Seq<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Lst&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Seq<Lst<A>> SubtractT<NUM,  A>(this Seq<Lst<A>> x, Seq<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Seq<Lst<A>> ProductT<NUM,  A>(this Seq<Lst<A>> x, Seq<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Seq<Lst<A>> DivideT<NUM,  A>(this Seq<Lst<A>> x, Seq<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Seq<Lst<A>> AppendT<SEMI,  A>(this Seq<Lst<A>> x, Seq<Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Seq<Lst<A>> x, Seq<Lst<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Seq<Lst<A>> x, Seq<Lst<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Seq&lt;Lst&lt;A&gt;&gt;`</param>
        /// <returns>`Seq&lt;Lst&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Seq<Lst<B>> ApplyT< A, B>(this Func<A, B> fab, Seq<Lst<A>> fa) =>
            ApplSeq< Lst<A>, Lst<B>>.Inst.Apply(
                 MSeq< Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => ApplLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Seq&lt;Lst&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Seq&lt;Lst&lt;A&gt;&gt;`</param>
        /// <returns>`Seq&lt;Lst&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Seq<Lst<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Seq<Lst<A>> fa, Seq<Lst<B>> fb) =>
            ApplSeq< Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MSeq< Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            ApplLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Set&lt;Lst&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Set<Lst<C>> SelectMany< A, B, C>(
            this Set<Lst<A>> ma,
            Func<A, Set<Lst<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MSet<Lst<C>>, Set<Lst<C>>, MLst<C>, Lst<C>, C>(ma, a =>
                    SeqTrans<MSet<Lst<B>>, Set<Lst<B>>, MLst<B>, Lst<B>, B>
                        .Inst.Bind<MSet<Lst<C>>, Set<Lst<C>>, MLst<C>, Lst<C>, C>(bind(a), b =>
                            default(MLst<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;Lst&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<Lst<A>> Where< A>(this Set<Lst<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Lst<B>> Select< A, B>(this Set<Lst<A>> ma, Func<A, B> f) =>
            SeqTrans<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MSet<Lst<B>>, Set<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Set&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Lst&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Set&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Set<Lst<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Set&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Lst&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Set&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Set<Lst<A>> ma) =>
            SeqTrans<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Lst<B>> BindT< A, B>(this Set<Lst<A>> ma, Func<A, Lst<B>> f) =>
            SeqTrans<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MSet<Lst<B>>, Set<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Lst<B>> BindT< A, B>(this Set<Lst<A>> ma, Func<A, Set<Lst<B>>> f) =>
            SeqTrans<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MSet<Lst<B>>, Set<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Set&lt;Lst&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Lst&lt;Set&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;Set&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Lst<Set<B>> Traverse< A, B>(this Set<Lst<A>> ma, Func<A, B> f) =>
            SeqTrans<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<Set<B>>, Lst<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Set&lt;Lst&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Lst&lt;Set&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Lst<Set<A>> Sequence< A>(this Set<Lst<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Lst<B>> MapT< A, B>(this Set<Lst<A>> ma, Func<A, B> f) =>
            SeqTrans<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MSet<Lst<B>>, Set<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Set<Lst<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Set<Lst<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Set<Lst<A>> ma, Func<A, bool> f) =>
            SeqTrans<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Set<Lst<A>> ma, Func<A, bool> f) =>
            SeqTrans<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Set&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Set<Lst<A>> ma, Action<A> f) =>
            SeqTrans<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;Lst&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<Lst<A>> FilterT< A>(this Set<Lst<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MSet<Lst<A>>, Set<Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Lst&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Set<Lst<A>> PlusT<NUM,  A>(this Set<Lst<A>> x, Set<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Lst&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Set<Lst<A>> SubtractT<NUM,  A>(this Set<Lst<A>> x, Set<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Set<Lst<A>> ProductT<NUM,  A>(this Set<Lst<A>> x, Set<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Set<Lst<A>> DivideT<NUM,  A>(this Set<Lst<A>> x, Set<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Set<Lst<A>> AppendT<SEMI,  A>(this Set<Lst<A>> x, Set<Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Set<Lst<A>> x, Set<Lst<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Set<Lst<A>> x, Set<Lst<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Set&lt;Lst&lt;A&gt;&gt;`</param>
        /// <returns>`Set&lt;Lst&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Set<Lst<B>> ApplyT< A, B>(this Func<A, B> fab, Set<Lst<A>> fa) =>
            ApplSet< Lst<A>, Lst<B>>.Inst.Apply(
                 MSet< Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => ApplLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Set&lt;Lst&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Set&lt;Lst&lt;A&gt;&gt;`</param>
        /// <returns>`Set&lt;Lst&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Set<Lst<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Set<Lst<A>> fa, Set<Lst<B>> fb) =>
            ApplSet< Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MSet< Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            ApplLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Validation&lt;FAIL, Lst&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Validation<FAIL, Lst<C>> SelectMany<FAIL, A, B, C>(
            this Validation<FAIL, Lst<A>> ma,
            Func<A, Validation<FAIL, Lst<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MValidation<FAIL, Lst<A>>, Validation<FAIL, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MValidation<FAIL, Lst<C>>, Validation<FAIL, Lst<C>>, MLst<C>, Lst<C>, C>(ma, a =>
                    Trans<MValidation<FAIL, Lst<B>>, Validation<FAIL, Lst<B>>, MLst<B>, Lst<B>, B>
                        .Inst.Bind<MValidation<FAIL, Lst<C>>, Validation<FAIL, Lst<C>>, MLst<C>, Lst<C>, C>(bind(a), b =>
                            default(MLst<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, Lst&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, Lst<A>> Where<FAIL, A>(this Validation<FAIL, Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MValidation<FAIL, Lst<A>>, Validation<FAIL, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MValidation<FAIL, Lst<A>>, Validation<FAIL, Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, Lst<B>> Select<FAIL, A, B>(this Validation<FAIL, Lst<A>> ma, Func<A, B> f) =>
            Trans<MValidation<FAIL, Lst<A>>, Validation<FAIL, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MValidation<FAIL, Lst<B>>, Validation<FAIL, Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Validation&lt;FAIL, Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Lst&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Validation&lt;FAIL, Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, FAIL, A>(this Validation<FAIL, Lst<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MValidation<FAIL, Lst<A>>, Validation<FAIL, Lst<A>>, MLst<A>, Lst<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Validation&lt;FAIL, Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Lst&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Validation&lt;FAIL, Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<FAIL, A>(this Validation<FAIL, Lst<A>> ma) =>
            Trans<MValidation<FAIL, Lst<A>>, Validation<FAIL, Lst<A>>, MLst<A>, Lst<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Validation&lt;FAIL, Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, Lst<B>> BindT<FAIL, A, B>(this Validation<FAIL, Lst<A>> ma, Func<A, Lst<B>> f) =>
            Trans<MValidation<FAIL, Lst<A>>, Validation<FAIL, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MValidation<FAIL, Lst<B>>, Validation<FAIL, Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Validation&lt;FAIL, Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, Lst<B>> BindT<FAIL, A, B>(this Validation<FAIL, Lst<A>> ma, Func<A, Validation<FAIL, Lst<B>>> f) =>
            Trans<MValidation<FAIL, Lst<A>>, Validation<FAIL, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MValidation<FAIL, Lst<B>>, Validation<FAIL, Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Validation&lt;FAIL, Lst&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Lst&lt;Validation&lt;FAIL, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;Validation&lt;FAIL, B&gt;&gt;`</returns>
        [Pure]
        public static Lst<Validation<FAIL, B>> Traverse<FAIL, A, B>(this Validation<FAIL, Lst<A>> ma, Func<A, B> f) =>
            SeqTrans<MValidation<FAIL, Lst<A>>, Validation<FAIL, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Traverse<MLst<Validation<FAIL, B>>, Lst<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Validation&lt;FAIL, Lst&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Lst&lt;Validation&lt;FAIL, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<FAIL, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static Lst<Validation<FAIL, A>> Sequence<FAIL, A>(this Validation<FAIL, Lst<A>> ma) =>
            ma.Traverse<FAIL, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, Lst<B>> MapT<FAIL, A, B>(this Validation<FAIL, Lst<A>> ma, Func<A, B> f) =>
            Trans<MValidation<FAIL, Lst<A>>, Validation<FAIL, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Map<MValidation<FAIL, Lst<B>>, Validation<FAIL, Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, FAIL, A>(this Validation<FAIL, Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MValidation<FAIL, Lst<A>>, Validation<FAIL, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, FAIL, A>(this Validation<FAIL, Lst<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MValidation<FAIL, Lst<A>>, Validation<FAIL, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<FAIL, A>(this Validation<FAIL, Lst<A>> ma, Func<A, bool> f) =>
            Trans<MValidation<FAIL, Lst<A>>, Validation<FAIL, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<FAIL, A>(this Validation<FAIL, Lst<A>> ma, Func<A, bool> f) =>
            Trans<MValidation<FAIL, Lst<A>>, Validation<FAIL, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Validation&lt;FAIL, Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<FAIL, A>(this Validation<FAIL, Lst<A>> ma, Action<A> f) =>
            Trans<MValidation<FAIL, Lst<A>>, Validation<FAIL, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, Lst&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, Lst<A>> FilterT<FAIL, A>(this Validation<FAIL, Lst<A>> ma, Func<A, bool> pred) =>
            Trans<MValidation<FAIL, Lst<A>>, Validation<FAIL, Lst<A>>, MLst<A>, Lst<A>, A>
                .Inst.Bind<MValidation<FAIL, Lst<A>>, Validation<FAIL, Lst<A>>, MLst<A>, Lst<A>, A>(ma, 
                    a => pred(a)
                        ? default(MLst<A>).Return(a)
                        : default(MLst<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Lst&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Validation<FAIL, Lst<A>> PlusT<NUM, FAIL, A>(this Validation<FAIL, Lst<A>> x, Validation<FAIL, Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Lst&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Validation<FAIL, Lst<A>> SubtractT<NUM, FAIL, A>(this Validation<FAIL, Lst<A>> x, Validation<FAIL, Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Lst&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Validation<FAIL, Lst<A>> ProductT<NUM, FAIL, A>(this Validation<FAIL, Lst<A>> x, Validation<FAIL, Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Lst&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Validation<FAIL, Lst<A>> DivideT<NUM, FAIL, A>(this Validation<FAIL, Lst<A>> x, Validation<FAIL, Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Lst&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Validation<FAIL, Lst<A>> AppendT<SEMI, FAIL, A>(this Validation<FAIL, Lst<A>> x, Validation<FAIL, Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, FAIL, A>(this Validation<FAIL, Lst<A>> x, Validation<FAIL, Lst<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Lst&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, FAIL, A>(this Validation<FAIL, Lst<A>> x, Validation<FAIL, Lst<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Validation&lt;FAIL, Lst&lt;A&gt;&gt;`</param>
        /// <returns>`Validation&lt;FAIL, Lst&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Validation<FAIL, Lst<B>> ApplyT<FAIL, A, B>(this Func<A, B> fab, Validation<FAIL, Lst<A>> fa) =>
            ApplValidation<FAIL, Lst<A>, Lst<B>>.Inst.Apply(
                 MValidation<FAIL, Func<Lst<A>, Lst<B>>>.Inst.Return((Lst<A> a) => ApplLst< A, B>.Inst.Apply(
                     MLst< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Validation&lt;FAIL, Lst&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Validation&lt;FAIL, Lst&lt;A&gt;&gt;`</param>
        /// <returns>`Validation&lt;FAIL, Lst&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Validation<FAIL, Lst<C>> ApplyT<FAIL, A, B, C>(this Func<A, B, C> fabc, Validation<FAIL, Lst<A>> fa, Validation<FAIL, Lst<B>> fb) =>
            ApplValidation<FAIL, Lst<A>, Lst<B>, Lst<C>>.Inst.Apply(
                MValidation<FAIL, Func<Lst<A>, Func<Lst<B>, Lst<C>>>>.Inst.Return(
                    (Lst<A> a) =>
                        (Lst<B> b) =>
                            ApplLst< A, B, C>.Inst.Apply(
                                MLst< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    /// <summary>
    /// Monad transformer for Option, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class OptionT_Extensions
    {
        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Arr&lt;Option&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<Option<C>> SelectMany< A, B, C>(
            this Arr<Option<A>> ma,
            Func<A, Arr<Option<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MArr<Option<C>>, Arr<Option<C>>, MOption<C>, Option<C>, C>(ma, a =>
                    SeqTrans<MArr<Option<B>>, Arr<Option<B>>, MOption<B>, Option<B>, B>
                        .Inst.Bind<MArr<Option<C>>, Arr<Option<C>>, MOption<C>, Option<C>, C>(bind(a), b =>
                            default(MOption<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;Option&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<Option<A>> Where< A>(this Arr<Option<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Option<B>> Select< A, B>(this Arr<Option<A>> ma, Func<A, B> f) =>
            SeqTrans<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MArr<Option<B>>, Arr<Option<B>>, MOption<B>, Option<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Arr&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Option&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Arr&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Arr<Option<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Arr&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Option&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Arr&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Arr<Option<A>> ma) =>
            SeqTrans<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Option<B>> BindT< A, B>(this Arr<Option<A>> ma, Func<A, Option<B>> f) =>
            SeqTrans<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MArr<Option<B>>, Arr<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Option<B>> BindT< A, B>(this Arr<Option<A>> ma, Func<A, Arr<Option<B>>> f) =>
            SeqTrans<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MArr<Option<B>>, Arr<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Arr&lt;Option&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Option&lt;Arr&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;Arr&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Option<Arr<B>> Traverse< A, B>(this Arr<Option<A>> ma, Func<A, B> f) =>
            Trans<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<Arr<B>>, Option<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Arr&lt;Option&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Option&lt;Arr&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Option<Arr<A>> Sequence< A>(this Arr<Option<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Option<B>> MapT< A, B>(this Arr<Option<A>> ma, Func<A, B> f) =>
            SeqTrans<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MArr<Option<B>>, Arr<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Arr<Option<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Arr<Option<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Arr<Option<A>> ma, Func<A, bool> f) =>
            SeqTrans<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Arr<Option<A>> ma, Func<A, bool> f) =>
            SeqTrans<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Arr&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Arr<Option<A>> ma, Action<A> f) =>
            SeqTrans<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;Option&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<Option<A>> FilterT< A>(this Arr<Option<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MArr<Option<A>>, Arr<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Option&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Arr<Option<A>> PlusT<NUM,  A>(this Arr<Option<A>> x, Arr<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Option&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Arr<Option<A>> SubtractT<NUM,  A>(this Arr<Option<A>> x, Arr<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Option&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Arr<Option<A>> ProductT<NUM,  A>(this Arr<Option<A>> x, Arr<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Option&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Arr<Option<A>> DivideT<NUM,  A>(this Arr<Option<A>> x, Arr<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Option&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Arr<Option<A>> AppendT<SEMI,  A>(this Arr<Option<A>> x, Arr<Option<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Arr<Option<A>> x, Arr<Option<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Option&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Arr<Option<A>> x, Arr<Option<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Arr&lt;Option&lt;A&gt;&gt;`</param>
        /// <returns>`Arr&lt;Option&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Arr<Option<B>> ApplyT< A, B>(this Func<A, B> fab, Arr<Option<A>> fa) =>
            ApplArr< Option<A>, Option<B>>.Inst.Apply(
                 MArr< Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => ApplOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Arr&lt;Option&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Arr&lt;Option&lt;A&gt;&gt;`</param>
        /// <returns>`Arr&lt;Option&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Arr<Option<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Arr<Option<A>> fa, Arr<Option<B>> fb) =>
            ApplArr< Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MArr< Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            ApplOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`HashSet&lt;Option&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<Option<C>> SelectMany< A, B, C>(
            this HashSet<Option<A>> ma,
            Func<A, HashSet<Option<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MHashSet<Option<C>>, HashSet<Option<C>>, MOption<C>, Option<C>, C>(ma, a =>
                    SeqTrans<MHashSet<Option<B>>, HashSet<Option<B>>, MOption<B>, Option<B>, B>
                        .Inst.Bind<MHashSet<Option<C>>, HashSet<Option<C>>, MOption<C>, Option<C>, C>(bind(a), b =>
                            default(MOption<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;Option&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<Option<A>> Where< A>(this HashSet<Option<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Option<B>> Select< A, B>(this HashSet<Option<A>> ma, Func<A, B> f) =>
            SeqTrans<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MHashSet<Option<B>>, HashSet<Option<B>>, MOption<B>, Option<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `HashSet&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Option&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `HashSet&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this HashSet<Option<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `HashSet&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Option&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `HashSet&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this HashSet<Option<A>> ma) =>
            SeqTrans<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Option<B>> BindT< A, B>(this HashSet<Option<A>> ma, Func<A, Option<B>> f) =>
            SeqTrans<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MHashSet<Option<B>>, HashSet<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Option<B>> BindT< A, B>(this HashSet<Option<A>> ma, Func<A, HashSet<Option<B>>> f) =>
            SeqTrans<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MHashSet<Option<B>>, HashSet<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `HashSet&lt;Option&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Option&lt;HashSet&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;HashSet&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Option<HashSet<B>> Traverse< A, B>(this HashSet<Option<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<HashSet<B>>, Option<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `HashSet&lt;Option&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Option&lt;HashSet&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Option<HashSet<A>> Sequence< A>(this HashSet<Option<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Option<B>> MapT< A, B>(this HashSet<Option<A>> ma, Func<A, B> f) =>
            SeqTrans<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MHashSet<Option<B>>, HashSet<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this HashSet<Option<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this HashSet<Option<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this HashSet<Option<A>> ma, Func<A, bool> f) =>
            SeqTrans<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this HashSet<Option<A>> ma, Func<A, bool> f) =>
            SeqTrans<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `HashSet&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this HashSet<Option<A>> ma, Action<A> f) =>
            SeqTrans<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;Option&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<Option<A>> FilterT< A>(this HashSet<Option<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MHashSet<Option<A>>, HashSet<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Option&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<Option<A>> PlusT<NUM,  A>(this HashSet<Option<A>> x, HashSet<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Option&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<Option<A>> SubtractT<NUM,  A>(this HashSet<Option<A>> x, HashSet<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Option&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static HashSet<Option<A>> ProductT<NUM,  A>(this HashSet<Option<A>> x, HashSet<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Option&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static HashSet<Option<A>> DivideT<NUM,  A>(this HashSet<Option<A>> x, HashSet<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Option&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static HashSet<Option<A>> AppendT<SEMI,  A>(this HashSet<Option<A>> x, HashSet<Option<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this HashSet<Option<A>> x, HashSet<Option<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Option&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this HashSet<Option<A>> x, HashSet<Option<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `HashSet&lt;Option&lt;A&gt;&gt;`</param>
        /// <returns>`HashSet&lt;Option&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static HashSet<Option<B>> ApplyT< A, B>(this Func<A, B> fab, HashSet<Option<A>> fa) =>
            ApplHashSet< Option<A>, Option<B>>.Inst.Apply(
                 MHashSet< Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => ApplOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `HashSet&lt;Option&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `HashSet&lt;Option&lt;A&gt;&gt;`</param>
        /// <returns>`HashSet&lt;Option&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static HashSet<Option<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, HashSet<Option<A>> fa, HashSet<Option<B>> fb) =>
            ApplHashSet< Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MHashSet< Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            ApplOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Lst&lt;Option&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<Option<C>> SelectMany< A, B, C>(
            this Lst<Option<A>> ma,
            Func<A, Lst<Option<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MLst<Option<C>>, Lst<Option<C>>, MOption<C>, Option<C>, C>(ma, a =>
                    SeqTrans<MLst<Option<B>>, Lst<Option<B>>, MOption<B>, Option<B>, B>
                        .Inst.Bind<MLst<Option<C>>, Lst<Option<C>>, MOption<C>, Option<C>, C>(bind(a), b =>
                            default(MOption<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;Option&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<Option<A>> Where< A>(this Lst<Option<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Option<B>> Select< A, B>(this Lst<Option<A>> ma, Func<A, B> f) =>
            SeqTrans<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MLst<Option<B>>, Lst<Option<B>>, MOption<B>, Option<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Lst&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Option&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Lst&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Lst<Option<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Lst&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Option&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Lst&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Lst<Option<A>> ma) =>
            SeqTrans<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Option<B>> BindT< A, B>(this Lst<Option<A>> ma, Func<A, Option<B>> f) =>
            SeqTrans<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MLst<Option<B>>, Lst<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Option<B>> BindT< A, B>(this Lst<Option<A>> ma, Func<A, Lst<Option<B>>> f) =>
            SeqTrans<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MLst<Option<B>>, Lst<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Lst&lt;Option&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Option&lt;Lst&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;Lst&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Option<Lst<B>> Traverse< A, B>(this Lst<Option<A>> ma, Func<A, B> f) =>
            Trans<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<Lst<B>>, Option<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Lst&lt;Option&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Option&lt;Lst&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Option<Lst<A>> Sequence< A>(this Lst<Option<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Option<B>> MapT< A, B>(this Lst<Option<A>> ma, Func<A, B> f) =>
            SeqTrans<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MLst<Option<B>>, Lst<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Lst<Option<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Lst<Option<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Lst<Option<A>> ma, Func<A, bool> f) =>
            SeqTrans<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Lst<Option<A>> ma, Func<A, bool> f) =>
            SeqTrans<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Lst&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Lst<Option<A>> ma, Action<A> f) =>
            SeqTrans<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;Option&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<Option<A>> FilterT< A>(this Lst<Option<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MLst<Option<A>>, Lst<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Option&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Lst<Option<A>> PlusT<NUM,  A>(this Lst<Option<A>> x, Lst<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Option&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Lst<Option<A>> SubtractT<NUM,  A>(this Lst<Option<A>> x, Lst<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Option&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Lst<Option<A>> ProductT<NUM,  A>(this Lst<Option<A>> x, Lst<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Option&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Lst<Option<A>> DivideT<NUM,  A>(this Lst<Option<A>> x, Lst<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Option&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Lst<Option<A>> AppendT<SEMI,  A>(this Lst<Option<A>> x, Lst<Option<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Lst<Option<A>> x, Lst<Option<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Option&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Lst<Option<A>> x, Lst<Option<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Lst&lt;Option&lt;A&gt;&gt;`</param>
        /// <returns>`Lst&lt;Option&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Lst<Option<B>> ApplyT< A, B>(this Func<A, B> fab, Lst<Option<A>> fa) =>
            ApplLst< Option<A>, Option<B>>.Inst.Apply(
                 MLst< Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => ApplOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Lst&lt;Option&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Lst&lt;Option&lt;A&gt;&gt;`</param>
        /// <returns>`Lst&lt;Option&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Lst<Option<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Lst<Option<A>> fa, Lst<Option<B>> fb) =>
            ApplLst< Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MLst< Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            ApplOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Option&lt;Option&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Option<Option<C>> SelectMany< A, B, C>(
            this Option<Option<A>> ma,
            Func<A, Option<Option<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MOption<Option<C>>, Option<Option<C>>, MOption<C>, Option<C>, C>(ma, a =>
                    Trans<MOption<Option<B>>, Option<Option<B>>, MOption<B>, Option<B>, B>
                        .Inst.Bind<MOption<Option<C>>, Option<Option<C>>, MOption<C>, Option<C>, C>(bind(a), b =>
                            default(MOption<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;Option&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<Option<A>> Where< A>(this Option<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Option<B>> Select< A, B>(this Option<Option<A>> ma, Func<A, B> f) =>
            Trans<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MOption<Option<B>>, Option<Option<B>>, MOption<B>, Option<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Option&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Option&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Option&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Option<Option<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Option&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Option&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Option&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Option<Option<A>> ma) =>
            Trans<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Option<B>> BindT< A, B>(this Option<Option<A>> ma, Func<A, Option<B>> f) =>
            Trans<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MOption<Option<B>>, Option<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Option<B>> BindT< A, B>(this Option<Option<A>> ma, Func<A, Option<Option<B>>> f) =>
            Trans<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MOption<Option<B>>, Option<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Option&lt;Option&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Option&lt;Option&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;Option&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Option<Option<B>> Traverse< A, B>(this Option<Option<A>> ma, Func<A, B> f) =>
            Trans<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<Option<B>>, Option<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Option&lt;Option&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Option&lt;Option&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Option<Option<A>> Sequence< A>(this Option<Option<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Option<B>> MapT< A, B>(this Option<Option<A>> ma, Func<A, B> f) =>
            Trans<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MOption<Option<B>>, Option<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Option<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Option<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Option<Option<A>> ma, Func<A, bool> f) =>
            Trans<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Option<Option<A>> ma, Func<A, bool> f) =>
            Trans<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Option&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Option<Option<A>> ma, Action<A> f) =>
            Trans<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;Option&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<Option<A>> FilterT< A>(this Option<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MOption<Option<A>>, Option<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Option&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Option<Option<A>> PlusT<NUM,  A>(this Option<Option<A>> x, Option<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Option&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Option<Option<A>> SubtractT<NUM,  A>(this Option<Option<A>> x, Option<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Option&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Option<Option<A>> ProductT<NUM,  A>(this Option<Option<A>> x, Option<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Option&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Option<Option<A>> DivideT<NUM,  A>(this Option<Option<A>> x, Option<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Option&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Option<Option<A>> AppendT<SEMI,  A>(this Option<Option<A>> x, Option<Option<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Option<Option<A>> x, Option<Option<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Option&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Option<Option<A>> x, Option<Option<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Option&lt;Option&lt;A&gt;&gt;`</param>
        /// <returns>`Option&lt;Option&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Option<Option<B>> ApplyT< A, B>(this Func<A, B> fab, Option<Option<A>> fa) =>
            ApplOption< Option<A>, Option<B>>.Inst.Apply(
                 MOption< Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => ApplOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Option&lt;Option&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Option&lt;Option&lt;A&gt;&gt;`</param>
        /// <returns>`Option&lt;Option&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Option<Option<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Option<Option<A>> fa, Option<Option<B>> fb) =>
            ApplOption< Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MOption< Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            ApplOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionUnsafe&lt;Option&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<Option<C>> SelectMany< A, B, C>(
            this OptionUnsafe<Option<A>> ma,
            Func<A, OptionUnsafe<Option<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MOptionUnsafe<Option<C>>, OptionUnsafe<Option<C>>, MOption<C>, Option<C>, C>(ma, a =>
                    Trans<MOptionUnsafe<Option<B>>, OptionUnsafe<Option<B>>, MOption<B>, Option<B>, B>
                        .Inst.Bind<MOptionUnsafe<Option<C>>, OptionUnsafe<Option<C>>, MOption<C>, Option<C>, C>(bind(a), b =>
                            default(MOption<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;Option&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<Option<A>> Where< A>(this OptionUnsafe<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Option<B>> Select< A, B>(this OptionUnsafe<Option<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MOptionUnsafe<Option<B>>, OptionUnsafe<Option<B>>, MOption<B>, Option<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionUnsafe&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Option&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionUnsafe&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this OptionUnsafe<Option<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionUnsafe&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Option&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionUnsafe&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this OptionUnsafe<Option<A>> ma) =>
            Trans<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Option<B>> BindT< A, B>(this OptionUnsafe<Option<A>> ma, Func<A, Option<B>> f) =>
            Trans<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MOptionUnsafe<Option<B>>, OptionUnsafe<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Option<B>> BindT< A, B>(this OptionUnsafe<Option<A>> ma, Func<A, OptionUnsafe<Option<B>>> f) =>
            Trans<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MOptionUnsafe<Option<B>>, OptionUnsafe<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionUnsafe&lt;Option&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Option&lt;OptionUnsafe&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;OptionUnsafe&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Option<OptionUnsafe<B>> Traverse< A, B>(this OptionUnsafe<Option<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<OptionUnsafe<B>>, Option<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionUnsafe&lt;Option&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Option&lt;OptionUnsafe&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Option<OptionUnsafe<A>> Sequence< A>(this OptionUnsafe<Option<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Option<B>> MapT< A, B>(this OptionUnsafe<Option<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MOptionUnsafe<Option<B>>, OptionUnsafe<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this OptionUnsafe<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this OptionUnsafe<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this OptionUnsafe<Option<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this OptionUnsafe<Option<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionUnsafe&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this OptionUnsafe<Option<A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;Option&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<Option<A>> FilterT< A>(this OptionUnsafe<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MOptionUnsafe<Option<A>>, OptionUnsafe<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Option&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<Option<A>> PlusT<NUM,  A>(this OptionUnsafe<Option<A>> x, OptionUnsafe<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Option&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<Option<A>> SubtractT<NUM,  A>(this OptionUnsafe<Option<A>> x, OptionUnsafe<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Option&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionUnsafe<Option<A>> ProductT<NUM,  A>(this OptionUnsafe<Option<A>> x, OptionUnsafe<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Option&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionUnsafe<Option<A>> DivideT<NUM,  A>(this OptionUnsafe<Option<A>> x, OptionUnsafe<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Option&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionUnsafe<Option<A>> AppendT<SEMI,  A>(this OptionUnsafe<Option<A>> x, OptionUnsafe<Option<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this OptionUnsafe<Option<A>> x, OptionUnsafe<Option<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Option&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this OptionUnsafe<Option<A>> x, OptionUnsafe<Option<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe&lt;Option&lt;A&gt;&gt;`</param>
        /// <returns>`OptionUnsafe&lt;Option&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionUnsafe<Option<B>> ApplyT< A, B>(this Func<A, B> fab, OptionUnsafe<Option<A>> fa) =>
            ApplOptionUnsafe< Option<A>, Option<B>>.Inst.Apply(
                 MOptionUnsafe< Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => ApplOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe&lt;Option&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `OptionUnsafe&lt;Option&lt;A&gt;&gt;`</param>
        /// <returns>`OptionUnsafe&lt;Option&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionUnsafe<Option<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, OptionUnsafe<Option<A>> fa, OptionUnsafe<Option<B>> fb) =>
            ApplOptionUnsafe< Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MOptionUnsafe< Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            ApplOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Either&lt;L, Option&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, Option<C>> SelectMany<L, A, B, C>(
            this Either<L, Option<A>> ma,
            Func<A, Either<L, Option<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MEither<L, Option<C>>, Either<L, Option<C>>, MOption<C>, Option<C>, C>(ma, a =>
                    Trans<MEither<L, Option<B>>, Either<L, Option<B>>, MOption<B>, Option<B>, B>
                        .Inst.Bind<MEither<L, Option<C>>, Either<L, Option<C>>, MOption<C>, Option<C>, C>(bind(a), b =>
                            default(MOption<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, Option&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, Option<A>> Where<L, A>(this Either<L, Option<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Option<B>> Select<L, A, B>(this Either<L, Option<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MEither<L, Option<B>>, Either<L, Option<B>>, MOption<B>, Option<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Either&lt;L, Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Option&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Either&lt;L, Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Either<L, Option<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Either&lt;L, Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Option&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Either&lt;L, Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this Either<L, Option<A>> ma) =>
            Trans<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either&lt;L, Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Option<B>> BindT<L, A, B>(this Either<L, Option<A>> ma, Func<A, Option<B>> f) =>
            Trans<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MEither<L, Option<B>>, Either<L, Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either&lt;L, Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Option<B>> BindT<L, A, B>(this Either<L, Option<A>> ma, Func<A, Either<L, Option<B>>> f) =>
            Trans<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MEither<L, Option<B>>, Either<L, Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Either&lt;L, Option&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Option&lt;Either&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;Either&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static Option<Either<L, B>> Traverse<L, A, B>(this Either<L, Option<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<Either<L, B>>, Option<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Either&lt;L, Option&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Option&lt;Either&lt;L, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static Option<Either<L, A>> Sequence<L, A>(this Either<L, Option<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Option<B>> MapT<L, A, B>(this Either<L, Option<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MEither<L, Option<B>>, Either<L, Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Either<L, Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Either<L, Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Either<L, Option<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Either<L, Option<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Either&lt;L, Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Either<L, Option<A>> ma, Action<A> f) =>
            Trans<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, Option&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, Option<A>> FilterT<L, A>(this Either<L, Option<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MEither<L, Option<A>>, Either<L, Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Option&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, Option<A>> PlusT<NUM, L, A>(this Either<L, Option<A>> x, Either<L, Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Option&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, Option<A>> SubtractT<NUM, L, A>(this Either<L, Option<A>> x, Either<L, Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Option&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Either<L, Option<A>> ProductT<NUM, L, A>(this Either<L, Option<A>> x, Either<L, Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Option&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Either<L, Option<A>> DivideT<NUM, L, A>(this Either<L, Option<A>> x, Either<L, Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Option&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Either<L, Option<A>> AppendT<SEMI, L, A>(this Either<L, Option<A>> x, Either<L, Option<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Either<L, Option<A>> x, Either<L, Option<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Option&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Either<L, Option<A>> x, Either<L, Option<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Either&lt;L, Option&lt;A&gt;&gt;`</param>
        /// <returns>`Either&lt;L, Option&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Either<L, Option<B>> ApplyT<L, A, B>(this Func<A, B> fab, Either<L, Option<A>> fa) =>
            ApplEither<L, Option<A>, Option<B>>.Inst.Apply(
                 MEither<L, Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => ApplOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Either&lt;L, Option&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Either&lt;L, Option&lt;A&gt;&gt;`</param>
        /// <returns>`Either&lt;L, Option&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Either<L, Option<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Either<L, Option<A>> fa, Either<L, Option<B>> fb) =>
            ApplEither<L, Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MEither<L, Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            ApplOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`EitherUnsafe&lt;L, Option&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, Option<C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, Option<A>> ma,
            Func<A, EitherUnsafe<L, Option<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Option<C>>, EitherUnsafe<L, Option<C>>, MOption<C>, Option<C>, C>(ma, a =>
                    Trans<MEitherUnsafe<L, Option<B>>, EitherUnsafe<L, Option<B>>, MOption<B>, Option<B>, B>
                        .Inst.Bind<MEitherUnsafe<L, Option<C>>, EitherUnsafe<L, Option<C>>, MOption<C>, Option<C>, C>(bind(a), b =>
                            default(MOption<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, Option&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, Option<A>> Where<L, A>(this EitherUnsafe<L, Option<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Option<B>> Select<L, A, B>(this EitherUnsafe<L, Option<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MEitherUnsafe<L, Option<B>>, EitherUnsafe<L, Option<B>>, MOption<B>, Option<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherUnsafe&lt;L, Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Option&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherUnsafe&lt;L, Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this EitherUnsafe<L, Option<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherUnsafe&lt;L, Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Option&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherUnsafe&lt;L, Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this EitherUnsafe<L, Option<A>> ma) =>
            Trans<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Option<B>> BindT<L, A, B>(this EitherUnsafe<L, Option<A>> ma, Func<A, Option<B>> f) =>
            Trans<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Option<B>>, EitherUnsafe<L, Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Option<B>> BindT<L, A, B>(this EitherUnsafe<L, Option<A>> ma, Func<A, EitherUnsafe<L, Option<B>>> f) =>
            Trans<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Option<B>>, EitherUnsafe<L, Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `EitherUnsafe&lt;L, Option&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Option&lt;EitherUnsafe&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;EitherUnsafe&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static Option<EitherUnsafe<L, B>> Traverse<L, A, B>(this EitherUnsafe<L, Option<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<EitherUnsafe<L, B>>, Option<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `EitherUnsafe&lt;L, Option&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Option&lt;EitherUnsafe&lt;L, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static Option<EitherUnsafe<L, A>> Sequence<L, A>(this EitherUnsafe<L, Option<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Option<B>> MapT<L, A, B>(this EitherUnsafe<L, Option<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MEitherUnsafe<L, Option<B>>, EitherUnsafe<L, Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this EitherUnsafe<L, Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this EitherUnsafe<L, Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this EitherUnsafe<L, Option<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this EitherUnsafe<L, Option<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherUnsafe&lt;L, Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this EitherUnsafe<L, Option<A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, Option&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, Option<A>> FilterT<L, A>(this EitherUnsafe<L, Option<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Option<A>>, EitherUnsafe<L, Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Option&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, Option<A>> PlusT<NUM, L, A>(this EitherUnsafe<L, Option<A>> x, EitherUnsafe<L, Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Option&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, Option<A>> SubtractT<NUM, L, A>(this EitherUnsafe<L, Option<A>> x, EitherUnsafe<L, Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Option&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherUnsafe<L, Option<A>> ProductT<NUM, L, A>(this EitherUnsafe<L, Option<A>> x, EitherUnsafe<L, Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Option&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherUnsafe<L, Option<A>> DivideT<NUM, L, A>(this EitherUnsafe<L, Option<A>> x, EitherUnsafe<L, Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Option&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherUnsafe<L, Option<A>> AppendT<SEMI, L, A>(this EitherUnsafe<L, Option<A>> x, EitherUnsafe<L, Option<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this EitherUnsafe<L, Option<A>> x, EitherUnsafe<L, Option<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Option&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this EitherUnsafe<L, Option<A>> x, EitherUnsafe<L, Option<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe&lt;L, Option&lt;A&gt;&gt;`</param>
        /// <returns>`EitherUnsafe&lt;L, Option&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherUnsafe<L, Option<B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherUnsafe<L, Option<A>> fa) =>
            ApplEitherUnsafe<L, Option<A>, Option<B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => ApplOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe&lt;L, Option&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `EitherUnsafe&lt;L, Option&lt;A&gt;&gt;`</param>
        /// <returns>`EitherUnsafe&lt;L, Option&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherUnsafe<L, Option<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherUnsafe<L, Option<A>> fa, EitherUnsafe<L, Option<B>> fb) =>
            ApplEitherUnsafe<L, Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MEitherUnsafe<L, Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            ApplOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Try&lt;Option&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Try<Option<C>> SelectMany< A, B, C>(
            this Try<Option<A>> ma,
            Func<A, Try<Option<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MTry<Option<C>>, Try<Option<C>>, MOption<C>, Option<C>, C>(ma, a =>
                    Trans<MTry<Option<B>>, Try<Option<B>>, MOption<B>, Option<B>, B>
                        .Inst.Bind<MTry<Option<C>>, Try<Option<C>>, MOption<C>, Option<C>, C>(bind(a), b =>
                            default(MOption<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;Option&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<Option<A>> Where< A>(this Try<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Option<B>> Select< A, B>(this Try<Option<A>> ma, Func<A, B> f) =>
            Trans<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MTry<Option<B>>, Try<Option<B>>, MOption<B>, Option<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Try&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Option&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Try&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Try<Option<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Try&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Option&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Try&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Try<Option<A>> ma) =>
            Trans<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Option<B>> BindT< A, B>(this Try<Option<A>> ma, Func<A, Option<B>> f) =>
            Trans<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MTry<Option<B>>, Try<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Option<B>> BindT< A, B>(this Try<Option<A>> ma, Func<A, Try<Option<B>>> f) =>
            Trans<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MTry<Option<B>>, Try<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Try&lt;Option&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Option&lt;Try&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;Try&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Option<Try<B>> Traverse< A, B>(this Try<Option<A>> ma, Func<A, B> f) =>
            Trans<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<Try<B>>, Option<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Try&lt;Option&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Option&lt;Try&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Option<Try<A>> Sequence< A>(this Try<Option<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Option<B>> MapT< A, B>(this Try<Option<A>> ma, Func<A, B> f) =>
            Trans<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MTry<Option<B>>, Try<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Try<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Try<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Try<Option<A>> ma, Func<A, bool> f) =>
            Trans<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Try<Option<A>> ma, Func<A, bool> f) =>
            Trans<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Try&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Try<Option<A>> ma, Action<A> f) =>
            Trans<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;Option&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<Option<A>> FilterT< A>(this Try<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MTry<Option<A>>, Try<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Option&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Try<Option<A>> PlusT<NUM,  A>(this Try<Option<A>> x, Try<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Option&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Try<Option<A>> SubtractT<NUM,  A>(this Try<Option<A>> x, Try<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Option&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Try<Option<A>> ProductT<NUM,  A>(this Try<Option<A>> x, Try<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Option&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Try<Option<A>> DivideT<NUM,  A>(this Try<Option<A>> x, Try<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Option&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Try<Option<A>> AppendT<SEMI,  A>(this Try<Option<A>> x, Try<Option<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Try<Option<A>> x, Try<Option<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Option&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Try<Option<A>> x, Try<Option<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Try&lt;Option&lt;A&gt;&gt;`</param>
        /// <returns>`Try&lt;Option&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Try<Option<B>> ApplyT< A, B>(this Func<A, B> fab, Try<Option<A>> fa) =>
            ApplTry< Option<A>, Option<B>>.Inst.Apply(
                 MTry< Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => ApplOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Try&lt;Option&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Try&lt;Option&lt;A&gt;&gt;`</param>
        /// <returns>`Try&lt;Option&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Try<Option<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Try<Option<A>> fa, Try<Option<B>> fb) =>
            ApplTry< Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MTry< Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            ApplOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOption&lt;Option&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<Option<C>> SelectMany< A, B, C>(
            this TryOption<Option<A>> ma,
            Func<A, TryOption<Option<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MTryOption<Option<C>>, TryOption<Option<C>>, MOption<C>, Option<C>, C>(ma, a =>
                    Trans<MTryOption<Option<B>>, TryOption<Option<B>>, MOption<B>, Option<B>, B>
                        .Inst.Bind<MTryOption<Option<C>>, TryOption<Option<C>>, MOption<C>, Option<C>, C>(bind(a), b =>
                            default(MOption<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;Option&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<Option<A>> Where< A>(this TryOption<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Option<B>> Select< A, B>(this TryOption<Option<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MTryOption<Option<B>>, TryOption<Option<B>>, MOption<B>, Option<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOption&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Option&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOption&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryOption<Option<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOption&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Option&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOption&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this TryOption<Option<A>> ma) =>
            Trans<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Option<B>> BindT< A, B>(this TryOption<Option<A>> ma, Func<A, Option<B>> f) =>
            Trans<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MTryOption<Option<B>>, TryOption<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Option<B>> BindT< A, B>(this TryOption<Option<A>> ma, Func<A, TryOption<Option<B>>> f) =>
            Trans<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MTryOption<Option<B>>, TryOption<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOption&lt;Option&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Option&lt;TryOption&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;TryOption&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Option<TryOption<B>> Traverse< A, B>(this TryOption<Option<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<TryOption<B>>, Option<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOption&lt;Option&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Option&lt;TryOption&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Option<TryOption<A>> Sequence< A>(this TryOption<Option<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Option<B>> MapT< A, B>(this TryOption<Option<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MTryOption<Option<B>>, TryOption<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryOption<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryOption<Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryOption<Option<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryOption<Option<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOption&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryOption<Option<A>> ma, Action<A> f) =>
            Trans<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;Option&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<Option<A>> FilterT< A>(this TryOption<Option<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MTryOption<Option<A>>, TryOption<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Option&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<Option<A>> PlusT<NUM,  A>(this TryOption<Option<A>> x, TryOption<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Option&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<Option<A>> SubtractT<NUM,  A>(this TryOption<Option<A>> x, TryOption<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Option&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOption<Option<A>> ProductT<NUM,  A>(this TryOption<Option<A>> x, TryOption<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Option&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOption<Option<A>> DivideT<NUM,  A>(this TryOption<Option<A>> x, TryOption<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Option&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOption<Option<A>> AppendT<SEMI,  A>(this TryOption<Option<A>> x, TryOption<Option<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryOption<Option<A>> x, TryOption<Option<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Option&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryOption<Option<A>> x, TryOption<Option<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOption&lt;Option&lt;A&gt;&gt;`</param>
        /// <returns>`TryOption&lt;Option&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOption<Option<B>> ApplyT< A, B>(this Func<A, B> fab, TryOption<Option<A>> fa) =>
            ApplTryOption< Option<A>, Option<B>>.Inst.Apply(
                 MTryOption< Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => ApplOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOption&lt;Option&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryOption&lt;Option&lt;A&gt;&gt;`</param>
        /// <returns>`TryOption&lt;Option&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOption<Option<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOption<Option<A>> fa, TryOption<Option<B>> fb) =>
            ApplTryOption< Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MTryOption< Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            ApplOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`IEnumerable&lt;Option&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<Option<C>> SelectMany< A, B, C>(
            this IEnumerable<Option<A>> ma,
            Func<A, IEnumerable<Option<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MEnumerable<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MEnumerable<Option<C>>, IEnumerable<Option<C>>, MOption<C>, Option<C>, C>(ma, a =>
                    SeqTrans<MEnumerable<Option<B>>, IEnumerable<Option<B>>, MOption<B>, Option<B>, B>
                        .Inst.Bind<MEnumerable<Option<C>>, IEnumerable<Option<C>>, MOption<C>, Option<C>, C>(bind(a), b =>
                            default(MOption<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;Option&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<Option<A>> Where< A>(this IEnumerable<Option<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MEnumerable<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MEnumerable<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Option<B>> Select< A, B>(this IEnumerable<Option<A>> ma, Func<A, B> f) =>
            SeqTrans<MEnumerable<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MEnumerable<Option<B>>, IEnumerable<Option<B>>, MOption<B>, Option<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `IEnumerable&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Option&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `IEnumerable&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this IEnumerable<Option<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MEnumerable<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `IEnumerable&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Option&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `IEnumerable&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this IEnumerable<Option<A>> ma) =>
            SeqTrans<MEnumerable<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Option<B>> BindT< A, B>(this IEnumerable<Option<A>> ma, Func<A, Option<B>> f) =>
            SeqTrans<MEnumerable<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MEnumerable<Option<B>>, IEnumerable<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Option<B>> BindT< A, B>(this IEnumerable<Option<A>> ma, Func<A, IEnumerable<Option<B>>> f) =>
            SeqTrans<MEnumerable<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MEnumerable<Option<B>>, IEnumerable<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `IEnumerable&lt;Option&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Option&lt;IEnumerable&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;IEnumerable&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Option<IEnumerable<B>> Traverse< A, B>(this IEnumerable<Option<A>> ma, Func<A, B> f) =>
            Trans<MEnumerable<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<IEnumerable<B>>, Option<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `IEnumerable&lt;Option&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Option&lt;IEnumerable&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Option<IEnumerable<A>> Sequence< A>(this IEnumerable<Option<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Option<B>> MapT< A, B>(this IEnumerable<Option<A>> ma, Func<A, B> f) =>
            SeqTrans<MEnumerable<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MEnumerable<Option<B>>, IEnumerable<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this IEnumerable<Option<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MEnumerable<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this IEnumerable<Option<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MEnumerable<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this IEnumerable<Option<A>> ma, Func<A, bool> f) =>
            SeqTrans<MEnumerable<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this IEnumerable<Option<A>> ma, Func<A, bool> f) =>
            SeqTrans<MEnumerable<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `IEnumerable&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this IEnumerable<Option<A>> ma, Action<A> f) =>
            SeqTrans<MEnumerable<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;Option&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<Option<A>> FilterT< A>(this IEnumerable<Option<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MEnumerable<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MEnumerable<Option<A>>, IEnumerable<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Option&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<Option<A>> PlusT<NUM,  A>(this IEnumerable<Option<A>> x, IEnumerable<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Option&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<Option<A>> SubtractT<NUM,  A>(this IEnumerable<Option<A>> x, IEnumerable<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Option&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static IEnumerable<Option<A>> ProductT<NUM,  A>(this IEnumerable<Option<A>> x, IEnumerable<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Option&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static IEnumerable<Option<A>> DivideT<NUM,  A>(this IEnumerable<Option<A>> x, IEnumerable<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Option&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static IEnumerable<Option<A>> AppendT<SEMI,  A>(this IEnumerable<Option<A>> x, IEnumerable<Option<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this IEnumerable<Option<A>> x, IEnumerable<Option<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Option&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this IEnumerable<Option<A>> x, IEnumerable<Option<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `IEnumerable&lt;Option&lt;A&gt;&gt;`</param>
        /// <returns>`IEnumerable&lt;Option&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static IEnumerable<Option<B>> ApplyT< A, B>(this Func<A, B> fab, IEnumerable<Option<A>> fa) =>
            ApplEnumerable< Option<A>, Option<B>>.Inst.Apply(
                 MEnumerable< Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => ApplOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `IEnumerable&lt;Option&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `IEnumerable&lt;Option&lt;A&gt;&gt;`</param>
        /// <returns>`IEnumerable&lt;Option&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static IEnumerable<Option<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, IEnumerable<Option<A>> fa, IEnumerable<Option<B>> fb) =>
            ApplEnumerable< Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MEnumerable< Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            ApplOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Seq&lt;Option&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Seq<Option<C>> SelectMany< A, B, C>(
            this Seq<Option<A>> ma,
            Func<A, Seq<Option<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MSeq<Option<A>>, Seq<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MSeq<Option<C>>, Seq<Option<C>>, MOption<C>, Option<C>, C>(ma, a =>
                    SeqTrans<MSeq<Option<B>>, Seq<Option<B>>, MOption<B>, Option<B>, B>
                        .Inst.Bind<MSeq<Option<C>>, Seq<Option<C>>, MOption<C>, Option<C>, C>(bind(a), b =>
                            default(MOption<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;Option&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<Option<A>> Where< A>(this Seq<Option<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSeq<Option<A>>, Seq<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MSeq<Option<A>>, Seq<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<Option<B>> Select< A, B>(this Seq<Option<A>> ma, Func<A, B> f) =>
            SeqTrans<MSeq<Option<A>>, Seq<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MSeq<Option<B>>, Seq<Option<B>>, MOption<B>, Option<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Seq&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Option&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Seq&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Seq<Option<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MSeq<Option<A>>, Seq<Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Seq&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Option&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Seq&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Seq<Option<A>> ma) =>
            SeqTrans<MSeq<Option<A>>, Seq<Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Seq&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<Option<B>> BindT< A, B>(this Seq<Option<A>> ma, Func<A, Option<B>> f) =>
            SeqTrans<MSeq<Option<A>>, Seq<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MSeq<Option<B>>, Seq<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Seq&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<Option<B>> BindT< A, B>(this Seq<Option<A>> ma, Func<A, Seq<Option<B>>> f) =>
            SeqTrans<MSeq<Option<A>>, Seq<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MSeq<Option<B>>, Seq<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Seq&lt;Option&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Option&lt;Seq&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;Seq&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Option<Seq<B>> Traverse< A, B>(this Seq<Option<A>> ma, Func<A, B> f) =>
            Trans<MSeq<Option<A>>, Seq<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<Seq<B>>, Option<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Seq&lt;Option&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Option&lt;Seq&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Option<Seq<A>> Sequence< A>(this Seq<Option<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<Option<B>> MapT< A, B>(this Seq<Option<A>> ma, Func<A, B> f) =>
            SeqTrans<MSeq<Option<A>>, Seq<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MSeq<Option<B>>, Seq<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Seq<Option<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSeq<Option<A>>, Seq<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Seq<Option<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSeq<Option<A>>, Seq<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Seq<Option<A>> ma, Func<A, bool> f) =>
            SeqTrans<MSeq<Option<A>>, Seq<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Seq<Option<A>> ma, Func<A, bool> f) =>
            SeqTrans<MSeq<Option<A>>, Seq<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Seq&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Seq<Option<A>> ma, Action<A> f) =>
            SeqTrans<MSeq<Option<A>>, Seq<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;Option&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<Option<A>> FilterT< A>(this Seq<Option<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSeq<Option<A>>, Seq<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MSeq<Option<A>>, Seq<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Option&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Seq<Option<A>> PlusT<NUM,  A>(this Seq<Option<A>> x, Seq<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Option&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Seq<Option<A>> SubtractT<NUM,  A>(this Seq<Option<A>> x, Seq<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Option&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Seq<Option<A>> ProductT<NUM,  A>(this Seq<Option<A>> x, Seq<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Option&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Seq<Option<A>> DivideT<NUM,  A>(this Seq<Option<A>> x, Seq<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Option&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Seq<Option<A>> AppendT<SEMI,  A>(this Seq<Option<A>> x, Seq<Option<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Seq<Option<A>> x, Seq<Option<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Option&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Seq<Option<A>> x, Seq<Option<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Seq&lt;Option&lt;A&gt;&gt;`</param>
        /// <returns>`Seq&lt;Option&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Seq<Option<B>> ApplyT< A, B>(this Func<A, B> fab, Seq<Option<A>> fa) =>
            ApplSeq< Option<A>, Option<B>>.Inst.Apply(
                 MSeq< Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => ApplOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Seq&lt;Option&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Seq&lt;Option&lt;A&gt;&gt;`</param>
        /// <returns>`Seq&lt;Option&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Seq<Option<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Seq<Option<A>> fa, Seq<Option<B>> fb) =>
            ApplSeq< Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MSeq< Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            ApplOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Set&lt;Option&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Set<Option<C>> SelectMany< A, B, C>(
            this Set<Option<A>> ma,
            Func<A, Set<Option<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MSet<Option<C>>, Set<Option<C>>, MOption<C>, Option<C>, C>(ma, a =>
                    SeqTrans<MSet<Option<B>>, Set<Option<B>>, MOption<B>, Option<B>, B>
                        .Inst.Bind<MSet<Option<C>>, Set<Option<C>>, MOption<C>, Option<C>, C>(bind(a), b =>
                            default(MOption<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;Option&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<Option<A>> Where< A>(this Set<Option<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Option<B>> Select< A, B>(this Set<Option<A>> ma, Func<A, B> f) =>
            SeqTrans<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MSet<Option<B>>, Set<Option<B>>, MOption<B>, Option<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Set&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Option&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Set&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Set<Option<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Set&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Option&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Set&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Set<Option<A>> ma) =>
            SeqTrans<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Option<B>> BindT< A, B>(this Set<Option<A>> ma, Func<A, Option<B>> f) =>
            SeqTrans<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MSet<Option<B>>, Set<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Option<B>> BindT< A, B>(this Set<Option<A>> ma, Func<A, Set<Option<B>>> f) =>
            SeqTrans<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MSet<Option<B>>, Set<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Set&lt;Option&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Option&lt;Set&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;Set&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Option<Set<B>> Traverse< A, B>(this Set<Option<A>> ma, Func<A, B> f) =>
            Trans<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<Set<B>>, Option<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Set&lt;Option&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Option&lt;Set&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Option<Set<A>> Sequence< A>(this Set<Option<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Option<B>> MapT< A, B>(this Set<Option<A>> ma, Func<A, B> f) =>
            SeqTrans<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MSet<Option<B>>, Set<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Set<Option<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Set<Option<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Set<Option<A>> ma, Func<A, bool> f) =>
            SeqTrans<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Set<Option<A>> ma, Func<A, bool> f) =>
            SeqTrans<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Set&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Set<Option<A>> ma, Action<A> f) =>
            SeqTrans<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;Option&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<Option<A>> FilterT< A>(this Set<Option<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MSet<Option<A>>, Set<Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Option&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Set<Option<A>> PlusT<NUM,  A>(this Set<Option<A>> x, Set<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Option&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Set<Option<A>> SubtractT<NUM,  A>(this Set<Option<A>> x, Set<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Option&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Set<Option<A>> ProductT<NUM,  A>(this Set<Option<A>> x, Set<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Option&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Set<Option<A>> DivideT<NUM,  A>(this Set<Option<A>> x, Set<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Option&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Set<Option<A>> AppendT<SEMI,  A>(this Set<Option<A>> x, Set<Option<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Set<Option<A>> x, Set<Option<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Option&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Set<Option<A>> x, Set<Option<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Set&lt;Option&lt;A&gt;&gt;`</param>
        /// <returns>`Set&lt;Option&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Set<Option<B>> ApplyT< A, B>(this Func<A, B> fab, Set<Option<A>> fa) =>
            ApplSet< Option<A>, Option<B>>.Inst.Apply(
                 MSet< Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => ApplOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Set&lt;Option&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Set&lt;Option&lt;A&gt;&gt;`</param>
        /// <returns>`Set&lt;Option&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Set<Option<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Set<Option<A>> fa, Set<Option<B>> fb) =>
            ApplSet< Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MSet< Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            ApplOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Validation&lt;FAIL, Option&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Validation<FAIL, Option<C>> SelectMany<FAIL, A, B, C>(
            this Validation<FAIL, Option<A>> ma,
            Func<A, Validation<FAIL, Option<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MValidation<FAIL, Option<A>>, Validation<FAIL, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MValidation<FAIL, Option<C>>, Validation<FAIL, Option<C>>, MOption<C>, Option<C>, C>(ma, a =>
                    Trans<MValidation<FAIL, Option<B>>, Validation<FAIL, Option<B>>, MOption<B>, Option<B>, B>
                        .Inst.Bind<MValidation<FAIL, Option<C>>, Validation<FAIL, Option<C>>, MOption<C>, Option<C>, C>(bind(a), b =>
                            default(MOption<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, Option&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, Option<A>> Where<FAIL, A>(this Validation<FAIL, Option<A>> ma, Func<A, bool> pred) =>
            Trans<MValidation<FAIL, Option<A>>, Validation<FAIL, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MValidation<FAIL, Option<A>>, Validation<FAIL, Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, Option<B>> Select<FAIL, A, B>(this Validation<FAIL, Option<A>> ma, Func<A, B> f) =>
            Trans<MValidation<FAIL, Option<A>>, Validation<FAIL, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MValidation<FAIL, Option<B>>, Validation<FAIL, Option<B>>, MOption<B>, Option<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Validation&lt;FAIL, Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Option&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Validation&lt;FAIL, Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, FAIL, A>(this Validation<FAIL, Option<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MValidation<FAIL, Option<A>>, Validation<FAIL, Option<A>>, MOption<A>, Option<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Validation&lt;FAIL, Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Option&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Validation&lt;FAIL, Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<FAIL, A>(this Validation<FAIL, Option<A>> ma) =>
            Trans<MValidation<FAIL, Option<A>>, Validation<FAIL, Option<A>>, MOption<A>, Option<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Validation&lt;FAIL, Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, Option<B>> BindT<FAIL, A, B>(this Validation<FAIL, Option<A>> ma, Func<A, Option<B>> f) =>
            Trans<MValidation<FAIL, Option<A>>, Validation<FAIL, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MValidation<FAIL, Option<B>>, Validation<FAIL, Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Validation&lt;FAIL, Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, Option<B>> BindT<FAIL, A, B>(this Validation<FAIL, Option<A>> ma, Func<A, Validation<FAIL, Option<B>>> f) =>
            Trans<MValidation<FAIL, Option<A>>, Validation<FAIL, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MValidation<FAIL, Option<B>>, Validation<FAIL, Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Validation&lt;FAIL, Option&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Option&lt;Validation&lt;FAIL, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;Validation&lt;FAIL, B&gt;&gt;`</returns>
        [Pure]
        public static Option<Validation<FAIL, B>> Traverse<FAIL, A, B>(this Validation<FAIL, Option<A>> ma, Func<A, B> f) =>
            Trans<MValidation<FAIL, Option<A>>, Validation<FAIL, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Traverse<MOption<Validation<FAIL, B>>, Option<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Validation&lt;FAIL, Option&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Option&lt;Validation&lt;FAIL, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<FAIL, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static Option<Validation<FAIL, A>> Sequence<FAIL, A>(this Validation<FAIL, Option<A>> ma) =>
            ma.Traverse<FAIL, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, Option<B>> MapT<FAIL, A, B>(this Validation<FAIL, Option<A>> ma, Func<A, B> f) =>
            Trans<MValidation<FAIL, Option<A>>, Validation<FAIL, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Map<MValidation<FAIL, Option<B>>, Validation<FAIL, Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, FAIL, A>(this Validation<FAIL, Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MValidation<FAIL, Option<A>>, Validation<FAIL, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, FAIL, A>(this Validation<FAIL, Option<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MValidation<FAIL, Option<A>>, Validation<FAIL, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<FAIL, A>(this Validation<FAIL, Option<A>> ma, Func<A, bool> f) =>
            Trans<MValidation<FAIL, Option<A>>, Validation<FAIL, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<FAIL, A>(this Validation<FAIL, Option<A>> ma, Func<A, bool> f) =>
            Trans<MValidation<FAIL, Option<A>>, Validation<FAIL, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Validation&lt;FAIL, Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<FAIL, A>(this Validation<FAIL, Option<A>> ma, Action<A> f) =>
            Trans<MValidation<FAIL, Option<A>>, Validation<FAIL, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, Option&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, Option<A>> FilterT<FAIL, A>(this Validation<FAIL, Option<A>> ma, Func<A, bool> pred) =>
            Trans<MValidation<FAIL, Option<A>>, Validation<FAIL, Option<A>>, MOption<A>, Option<A>, A>
                .Inst.Bind<MValidation<FAIL, Option<A>>, Validation<FAIL, Option<A>>, MOption<A>, Option<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOption<A>).Return(a)
                        : default(MOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Option&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Validation<FAIL, Option<A>> PlusT<NUM, FAIL, A>(this Validation<FAIL, Option<A>> x, Validation<FAIL, Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Option&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Validation<FAIL, Option<A>> SubtractT<NUM, FAIL, A>(this Validation<FAIL, Option<A>> x, Validation<FAIL, Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Option&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Validation<FAIL, Option<A>> ProductT<NUM, FAIL, A>(this Validation<FAIL, Option<A>> x, Validation<FAIL, Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Option&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Validation<FAIL, Option<A>> DivideT<NUM, FAIL, A>(this Validation<FAIL, Option<A>> x, Validation<FAIL, Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Option&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Validation<FAIL, Option<A>> AppendT<SEMI, FAIL, A>(this Validation<FAIL, Option<A>> x, Validation<FAIL, Option<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, FAIL, A>(this Validation<FAIL, Option<A>> x, Validation<FAIL, Option<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Option&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, FAIL, A>(this Validation<FAIL, Option<A>> x, Validation<FAIL, Option<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Validation&lt;FAIL, Option&lt;A&gt;&gt;`</param>
        /// <returns>`Validation&lt;FAIL, Option&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Validation<FAIL, Option<B>> ApplyT<FAIL, A, B>(this Func<A, B> fab, Validation<FAIL, Option<A>> fa) =>
            ApplValidation<FAIL, Option<A>, Option<B>>.Inst.Apply(
                 MValidation<FAIL, Func<Option<A>, Option<B>>>.Inst.Return((Option<A> a) => ApplOption< A, B>.Inst.Apply(
                     MOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Validation&lt;FAIL, Option&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Validation&lt;FAIL, Option&lt;A&gt;&gt;`</param>
        /// <returns>`Validation&lt;FAIL, Option&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Validation<FAIL, Option<C>> ApplyT<FAIL, A, B, C>(this Func<A, B, C> fabc, Validation<FAIL, Option<A>> fa, Validation<FAIL, Option<B>> fb) =>
            ApplValidation<FAIL, Option<A>, Option<B>, Option<C>>.Inst.Apply(
                MValidation<FAIL, Func<Option<A>, Func<Option<B>, Option<C>>>>.Inst.Return(
                    (Option<A> a) =>
                        (Option<B> b) =>
                            ApplOption< A, B, C>.Inst.Apply(
                                MOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    /// <summary>
    /// Monad transformer for OptionUnsafe, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class OptionUnsafeT_Extensions
    {
        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Arr&lt;OptionUnsafe&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<OptionUnsafe<C>> SelectMany< A, B, C>(
            this Arr<OptionUnsafe<A>> ma,
            Func<A, Arr<OptionUnsafe<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MArr<OptionUnsafe<C>>, Arr<OptionUnsafe<C>>, MOptionUnsafe<C>, OptionUnsafe<C>, C>(ma, a =>
                    SeqTrans<MArr<OptionUnsafe<B>>, Arr<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>
                        .Inst.Bind<MArr<OptionUnsafe<C>>, Arr<OptionUnsafe<C>>, MOptionUnsafe<C>, OptionUnsafe<C>, C>(bind(a), b =>
                            default(MOptionUnsafe<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;OptionUnsafe&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<OptionUnsafe<A>> Where< A>(this Arr<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<OptionUnsafe<B>> Select< A, B>(this Arr<OptionUnsafe<A>> ma, Func<A, B> f) =>
            SeqTrans<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MArr<OptionUnsafe<B>>, Arr<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Arr&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Arr&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Arr<OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Arr&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Arr&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Arr<OptionUnsafe<A>> ma) =>
            SeqTrans<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<OptionUnsafe<B>> BindT< A, B>(this Arr<OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            SeqTrans<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MArr<OptionUnsafe<B>>, Arr<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<OptionUnsafe<B>> BindT< A, B>(this Arr<OptionUnsafe<A>> ma, Func<A, Arr<OptionUnsafe<B>>> f) =>
            SeqTrans<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MArr<OptionUnsafe<B>>, Arr<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Arr&lt;OptionUnsafe&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe&lt;Arr&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;Arr&lt;B&gt;&gt;`</returns>
        [Pure]
        public static OptionUnsafe<Arr<B>> Traverse< A, B>(this Arr<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<Arr<B>>, OptionUnsafe<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Arr&lt;OptionUnsafe&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe&lt;Arr&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static OptionUnsafe<Arr<A>> Sequence< A>(this Arr<OptionUnsafe<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<OptionUnsafe<B>> MapT< A, B>(this Arr<OptionUnsafe<A>> ma, Func<A, B> f) =>
            SeqTrans<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MArr<OptionUnsafe<B>>, Arr<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Arr<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Arr<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Arr<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            SeqTrans<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Arr<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            SeqTrans<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Arr&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Arr<OptionUnsafe<A>> ma, Action<A> f) =>
            SeqTrans<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;OptionUnsafe&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<OptionUnsafe<A>> FilterT< A>(this Arr<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MArr<OptionUnsafe<A>>, Arr<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Arr<OptionUnsafe<A>> PlusT<NUM,  A>(this Arr<OptionUnsafe<A>> x, Arr<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Arr<OptionUnsafe<A>> SubtractT<NUM,  A>(this Arr<OptionUnsafe<A>> x, Arr<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Arr<OptionUnsafe<A>> ProductT<NUM,  A>(this Arr<OptionUnsafe<A>> x, Arr<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Arr<OptionUnsafe<A>> DivideT<NUM,  A>(this Arr<OptionUnsafe<A>> x, Arr<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Arr<OptionUnsafe<A>> AppendT<SEMI,  A>(this Arr<OptionUnsafe<A>> x, Arr<OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Arr<OptionUnsafe<A>> x, Arr<OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Arr<OptionUnsafe<A>> x, Arr<OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Arr&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <returns>`Arr&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Arr<OptionUnsafe<B>> ApplyT< A, B>(this Func<A, B> fab, Arr<OptionUnsafe<A>> fa) =>
            ApplArr< OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MArr< Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => ApplOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Arr&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Arr&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <returns>`Arr&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Arr<OptionUnsafe<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Arr<OptionUnsafe<A>> fa, Arr<OptionUnsafe<B>> fb) =>
            ApplArr< OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MArr< Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            ApplOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`HashSet&lt;OptionUnsafe&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<OptionUnsafe<C>> SelectMany< A, B, C>(
            this HashSet<OptionUnsafe<A>> ma,
            Func<A, HashSet<OptionUnsafe<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MHashSet<OptionUnsafe<C>>, HashSet<OptionUnsafe<C>>, MOptionUnsafe<C>, OptionUnsafe<C>, C>(ma, a =>
                    SeqTrans<MHashSet<OptionUnsafe<B>>, HashSet<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>
                        .Inst.Bind<MHashSet<OptionUnsafe<C>>, HashSet<OptionUnsafe<C>>, MOptionUnsafe<C>, OptionUnsafe<C>, C>(bind(a), b =>
                            default(MOptionUnsafe<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;OptionUnsafe&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<OptionUnsafe<A>> Where< A>(this HashSet<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<OptionUnsafe<B>> Select< A, B>(this HashSet<OptionUnsafe<A>> ma, Func<A, B> f) =>
            SeqTrans<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MHashSet<OptionUnsafe<B>>, HashSet<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `HashSet&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `HashSet&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this HashSet<OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `HashSet&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `HashSet&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this HashSet<OptionUnsafe<A>> ma) =>
            SeqTrans<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<OptionUnsafe<B>> BindT< A, B>(this HashSet<OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            SeqTrans<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MHashSet<OptionUnsafe<B>>, HashSet<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<OptionUnsafe<B>> BindT< A, B>(this HashSet<OptionUnsafe<A>> ma, Func<A, HashSet<OptionUnsafe<B>>> f) =>
            SeqTrans<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MHashSet<OptionUnsafe<B>>, HashSet<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `HashSet&lt;OptionUnsafe&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe&lt;HashSet&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;HashSet&lt;B&gt;&gt;`</returns>
        [Pure]
        public static OptionUnsafe<HashSet<B>> Traverse< A, B>(this HashSet<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<HashSet<B>>, OptionUnsafe<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `HashSet&lt;OptionUnsafe&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe&lt;HashSet&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static OptionUnsafe<HashSet<A>> Sequence< A>(this HashSet<OptionUnsafe<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<OptionUnsafe<B>> MapT< A, B>(this HashSet<OptionUnsafe<A>> ma, Func<A, B> f) =>
            SeqTrans<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MHashSet<OptionUnsafe<B>>, HashSet<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this HashSet<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this HashSet<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this HashSet<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            SeqTrans<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this HashSet<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            SeqTrans<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `HashSet&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this HashSet<OptionUnsafe<A>> ma, Action<A> f) =>
            SeqTrans<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;OptionUnsafe&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<OptionUnsafe<A>> FilterT< A>(this HashSet<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MHashSet<OptionUnsafe<A>>, HashSet<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<OptionUnsafe<A>> PlusT<NUM,  A>(this HashSet<OptionUnsafe<A>> x, HashSet<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<OptionUnsafe<A>> SubtractT<NUM,  A>(this HashSet<OptionUnsafe<A>> x, HashSet<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static HashSet<OptionUnsafe<A>> ProductT<NUM,  A>(this HashSet<OptionUnsafe<A>> x, HashSet<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static HashSet<OptionUnsafe<A>> DivideT<NUM,  A>(this HashSet<OptionUnsafe<A>> x, HashSet<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static HashSet<OptionUnsafe<A>> AppendT<SEMI,  A>(this HashSet<OptionUnsafe<A>> x, HashSet<OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this HashSet<OptionUnsafe<A>> x, HashSet<OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this HashSet<OptionUnsafe<A>> x, HashSet<OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `HashSet&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <returns>`HashSet&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static HashSet<OptionUnsafe<B>> ApplyT< A, B>(this Func<A, B> fab, HashSet<OptionUnsafe<A>> fa) =>
            ApplHashSet< OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MHashSet< Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => ApplOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `HashSet&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `HashSet&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <returns>`HashSet&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static HashSet<OptionUnsafe<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, HashSet<OptionUnsafe<A>> fa, HashSet<OptionUnsafe<B>> fb) =>
            ApplHashSet< OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MHashSet< Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            ApplOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Lst&lt;OptionUnsafe&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<OptionUnsafe<C>> SelectMany< A, B, C>(
            this Lst<OptionUnsafe<A>> ma,
            Func<A, Lst<OptionUnsafe<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MLst<OptionUnsafe<C>>, Lst<OptionUnsafe<C>>, MOptionUnsafe<C>, OptionUnsafe<C>, C>(ma, a =>
                    SeqTrans<MLst<OptionUnsafe<B>>, Lst<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>
                        .Inst.Bind<MLst<OptionUnsafe<C>>, Lst<OptionUnsafe<C>>, MOptionUnsafe<C>, OptionUnsafe<C>, C>(bind(a), b =>
                            default(MOptionUnsafe<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;OptionUnsafe&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<OptionUnsafe<A>> Where< A>(this Lst<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<OptionUnsafe<B>> Select< A, B>(this Lst<OptionUnsafe<A>> ma, Func<A, B> f) =>
            SeqTrans<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MLst<OptionUnsafe<B>>, Lst<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Lst&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Lst&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Lst<OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Lst&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Lst&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Lst<OptionUnsafe<A>> ma) =>
            SeqTrans<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<OptionUnsafe<B>> BindT< A, B>(this Lst<OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            SeqTrans<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MLst<OptionUnsafe<B>>, Lst<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<OptionUnsafe<B>> BindT< A, B>(this Lst<OptionUnsafe<A>> ma, Func<A, Lst<OptionUnsafe<B>>> f) =>
            SeqTrans<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MLst<OptionUnsafe<B>>, Lst<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Lst&lt;OptionUnsafe&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe&lt;Lst&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;Lst&lt;B&gt;&gt;`</returns>
        [Pure]
        public static OptionUnsafe<Lst<B>> Traverse< A, B>(this Lst<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<Lst<B>>, OptionUnsafe<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Lst&lt;OptionUnsafe&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe&lt;Lst&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static OptionUnsafe<Lst<A>> Sequence< A>(this Lst<OptionUnsafe<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<OptionUnsafe<B>> MapT< A, B>(this Lst<OptionUnsafe<A>> ma, Func<A, B> f) =>
            SeqTrans<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MLst<OptionUnsafe<B>>, Lst<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Lst<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Lst<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Lst<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            SeqTrans<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Lst<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            SeqTrans<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Lst&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Lst<OptionUnsafe<A>> ma, Action<A> f) =>
            SeqTrans<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;OptionUnsafe&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<OptionUnsafe<A>> FilterT< A>(this Lst<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MLst<OptionUnsafe<A>>, Lst<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Lst<OptionUnsafe<A>> PlusT<NUM,  A>(this Lst<OptionUnsafe<A>> x, Lst<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Lst<OptionUnsafe<A>> SubtractT<NUM,  A>(this Lst<OptionUnsafe<A>> x, Lst<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Lst<OptionUnsafe<A>> ProductT<NUM,  A>(this Lst<OptionUnsafe<A>> x, Lst<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Lst<OptionUnsafe<A>> DivideT<NUM,  A>(this Lst<OptionUnsafe<A>> x, Lst<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Lst<OptionUnsafe<A>> AppendT<SEMI,  A>(this Lst<OptionUnsafe<A>> x, Lst<OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Lst<OptionUnsafe<A>> x, Lst<OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Lst<OptionUnsafe<A>> x, Lst<OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Lst&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <returns>`Lst&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Lst<OptionUnsafe<B>> ApplyT< A, B>(this Func<A, B> fab, Lst<OptionUnsafe<A>> fa) =>
            ApplLst< OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MLst< Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => ApplOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Lst&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Lst&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <returns>`Lst&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Lst<OptionUnsafe<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Lst<OptionUnsafe<A>> fa, Lst<OptionUnsafe<B>> fb) =>
            ApplLst< OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MLst< Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            ApplOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Option&lt;OptionUnsafe&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Option<OptionUnsafe<C>> SelectMany< A, B, C>(
            this Option<OptionUnsafe<A>> ma,
            Func<A, Option<OptionUnsafe<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MOption<OptionUnsafe<C>>, Option<OptionUnsafe<C>>, MOptionUnsafe<C>, OptionUnsafe<C>, C>(ma, a =>
                    Trans<MOption<OptionUnsafe<B>>, Option<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>
                        .Inst.Bind<MOption<OptionUnsafe<C>>, Option<OptionUnsafe<C>>, MOptionUnsafe<C>, OptionUnsafe<C>, C>(bind(a), b =>
                            default(MOptionUnsafe<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;OptionUnsafe&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<OptionUnsafe<A>> Where< A>(this Option<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<OptionUnsafe<B>> Select< A, B>(this Option<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MOption<OptionUnsafe<B>>, Option<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Option&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Option&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Option<OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Option&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Option&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Option<OptionUnsafe<A>> ma) =>
            Trans<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<OptionUnsafe<B>> BindT< A, B>(this Option<OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            Trans<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MOption<OptionUnsafe<B>>, Option<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<OptionUnsafe<B>> BindT< A, B>(this Option<OptionUnsafe<A>> ma, Func<A, Option<OptionUnsafe<B>>> f) =>
            Trans<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MOption<OptionUnsafe<B>>, Option<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Option&lt;OptionUnsafe&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe&lt;Option&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;Option&lt;B&gt;&gt;`</returns>
        [Pure]
        public static OptionUnsafe<Option<B>> Traverse< A, B>(this Option<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<Option<B>>, OptionUnsafe<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Option&lt;OptionUnsafe&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe&lt;Option&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static OptionUnsafe<Option<A>> Sequence< A>(this Option<OptionUnsafe<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<OptionUnsafe<B>> MapT< A, B>(this Option<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MOption<OptionUnsafe<B>>, Option<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Option<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Option<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Option<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Option<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Option&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Option<OptionUnsafe<A>> ma, Action<A> f) =>
            Trans<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;OptionUnsafe&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<OptionUnsafe<A>> FilterT< A>(this Option<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MOption<OptionUnsafe<A>>, Option<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Option<OptionUnsafe<A>> PlusT<NUM,  A>(this Option<OptionUnsafe<A>> x, Option<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Option<OptionUnsafe<A>> SubtractT<NUM,  A>(this Option<OptionUnsafe<A>> x, Option<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Option<OptionUnsafe<A>> ProductT<NUM,  A>(this Option<OptionUnsafe<A>> x, Option<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Option<OptionUnsafe<A>> DivideT<NUM,  A>(this Option<OptionUnsafe<A>> x, Option<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Option<OptionUnsafe<A>> AppendT<SEMI,  A>(this Option<OptionUnsafe<A>> x, Option<OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Option<OptionUnsafe<A>> x, Option<OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Option<OptionUnsafe<A>> x, Option<OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Option&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <returns>`Option&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Option<OptionUnsafe<B>> ApplyT< A, B>(this Func<A, B> fab, Option<OptionUnsafe<A>> fa) =>
            ApplOption< OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MOption< Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => ApplOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Option&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Option&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <returns>`Option&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Option<OptionUnsafe<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Option<OptionUnsafe<A>> fa, Option<OptionUnsafe<B>> fb) =>
            ApplOption< OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MOption< Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            ApplOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionUnsafe&lt;OptionUnsafe&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<C>> SelectMany< A, B, C>(
            this OptionUnsafe<OptionUnsafe<A>> ma,
            Func<A, OptionUnsafe<OptionUnsafe<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MOptionUnsafe<OptionUnsafe<C>>, OptionUnsafe<OptionUnsafe<C>>, MOptionUnsafe<C>, OptionUnsafe<C>, C>(ma, a =>
                    Trans<MOptionUnsafe<OptionUnsafe<B>>, OptionUnsafe<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>
                        .Inst.Bind<MOptionUnsafe<OptionUnsafe<C>>, OptionUnsafe<OptionUnsafe<C>>, MOptionUnsafe<C>, OptionUnsafe<C>, C>(bind(a), b =>
                            default(MOptionUnsafe<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;OptionUnsafe&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<A>> Where< A>(this OptionUnsafe<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<B>> Select< A, B>(this OptionUnsafe<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MOptionUnsafe<OptionUnsafe<B>>, OptionUnsafe<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionUnsafe&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionUnsafe&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this OptionUnsafe<OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionUnsafe&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionUnsafe&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this OptionUnsafe<OptionUnsafe<A>> ma) =>
            Trans<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<B>> BindT< A, B>(this OptionUnsafe<OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            Trans<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MOptionUnsafe<OptionUnsafe<B>>, OptionUnsafe<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<B>> BindT< A, B>(this OptionUnsafe<OptionUnsafe<A>> ma, Func<A, OptionUnsafe<OptionUnsafe<B>>> f) =>
            Trans<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MOptionUnsafe<OptionUnsafe<B>>, OptionUnsafe<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionUnsafe&lt;OptionUnsafe&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe&lt;OptionUnsafe&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;OptionUnsafe&lt;B&gt;&gt;`</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<B>> Traverse< A, B>(this OptionUnsafe<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<OptionUnsafe<B>>, OptionUnsafe<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionUnsafe&lt;OptionUnsafe&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe&lt;OptionUnsafe&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<A>> Sequence< A>(this OptionUnsafe<OptionUnsafe<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<B>> MapT< A, B>(this OptionUnsafe<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MOptionUnsafe<OptionUnsafe<B>>, OptionUnsafe<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this OptionUnsafe<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this OptionUnsafe<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this OptionUnsafe<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this OptionUnsafe<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionUnsafe&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this OptionUnsafe<OptionUnsafe<A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;OptionUnsafe&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<A>> FilterT< A>(this OptionUnsafe<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MOptionUnsafe<OptionUnsafe<A>>, OptionUnsafe<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<A>> PlusT<NUM,  A>(this OptionUnsafe<OptionUnsafe<A>> x, OptionUnsafe<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<A>> SubtractT<NUM,  A>(this OptionUnsafe<OptionUnsafe<A>> x, OptionUnsafe<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<A>> ProductT<NUM,  A>(this OptionUnsafe<OptionUnsafe<A>> x, OptionUnsafe<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<A>> DivideT<NUM,  A>(this OptionUnsafe<OptionUnsafe<A>> x, OptionUnsafe<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<A>> AppendT<SEMI,  A>(this OptionUnsafe<OptionUnsafe<A>> x, OptionUnsafe<OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this OptionUnsafe<OptionUnsafe<A>> x, OptionUnsafe<OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this OptionUnsafe<OptionUnsafe<A>> x, OptionUnsafe<OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <returns>`OptionUnsafe&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<B>> ApplyT< A, B>(this Func<A, B> fab, OptionUnsafe<OptionUnsafe<A>> fa) =>
            ApplOptionUnsafe< OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MOptionUnsafe< Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => ApplOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `OptionUnsafe&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <returns>`OptionUnsafe&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionUnsafe<OptionUnsafe<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, OptionUnsafe<OptionUnsafe<A>> fa, OptionUnsafe<OptionUnsafe<B>> fb) =>
            ApplOptionUnsafe< OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MOptionUnsafe< Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            ApplOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Either&lt;L, OptionUnsafe&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, OptionUnsafe<C>> SelectMany<L, A, B, C>(
            this Either<L, OptionUnsafe<A>> ma,
            Func<A, Either<L, OptionUnsafe<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MEither<L, OptionUnsafe<C>>, Either<L, OptionUnsafe<C>>, MOptionUnsafe<C>, OptionUnsafe<C>, C>(ma, a =>
                    Trans<MEither<L, OptionUnsafe<B>>, Either<L, OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>
                        .Inst.Bind<MEither<L, OptionUnsafe<C>>, Either<L, OptionUnsafe<C>>, MOptionUnsafe<C>, OptionUnsafe<C>, C>(bind(a), b =>
                            default(MOptionUnsafe<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, OptionUnsafe&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, OptionUnsafe<A>> Where<L, A>(this Either<L, OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, OptionUnsafe<B>> Select<L, A, B>(this Either<L, OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MEither<L, OptionUnsafe<B>>, Either<L, OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Either&lt;L, OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Either&lt;L, OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Either<L, OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Either&lt;L, OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Either&lt;L, OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this Either<L, OptionUnsafe<A>> ma) =>
            Trans<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either&lt;L, OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, OptionUnsafe<B>> BindT<L, A, B>(this Either<L, OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            Trans<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MEither<L, OptionUnsafe<B>>, Either<L, OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either&lt;L, OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, OptionUnsafe<B>> BindT<L, A, B>(this Either<L, OptionUnsafe<A>> ma, Func<A, Either<L, OptionUnsafe<B>>> f) =>
            Trans<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MEither<L, OptionUnsafe<B>>, Either<L, OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Either&lt;L, OptionUnsafe&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe&lt;Either&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;Either&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static OptionUnsafe<Either<L, B>> Traverse<L, A, B>(this Either<L, OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<Either<L, B>>, OptionUnsafe<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Either&lt;L, OptionUnsafe&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe&lt;Either&lt;L, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static OptionUnsafe<Either<L, A>> Sequence<L, A>(this Either<L, OptionUnsafe<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, OptionUnsafe<B>> MapT<L, A, B>(this Either<L, OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MEither<L, OptionUnsafe<B>>, Either<L, OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Either<L, OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Either<L, OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Either<L, OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Either<L, OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Either&lt;L, OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Either<L, OptionUnsafe<A>> ma, Action<A> f) =>
            Trans<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, OptionUnsafe&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, OptionUnsafe<A>> FilterT<L, A>(this Either<L, OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MEither<L, OptionUnsafe<A>>, Either<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, OptionUnsafe&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, OptionUnsafe<A>> PlusT<NUM, L, A>(this Either<L, OptionUnsafe<A>> x, Either<L, OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, OptionUnsafe&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, OptionUnsafe<A>> SubtractT<NUM, L, A>(this Either<L, OptionUnsafe<A>> x, Either<L, OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Either<L, OptionUnsafe<A>> ProductT<NUM, L, A>(this Either<L, OptionUnsafe<A>> x, Either<L, OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Either<L, OptionUnsafe<A>> DivideT<NUM, L, A>(this Either<L, OptionUnsafe<A>> x, Either<L, OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Either<L, OptionUnsafe<A>> AppendT<SEMI, L, A>(this Either<L, OptionUnsafe<A>> x, Either<L, OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Either<L, OptionUnsafe<A>> x, Either<L, OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Either<L, OptionUnsafe<A>> x, Either<L, OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Either&lt;L, OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <returns>`Either&lt;L, OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Either<L, OptionUnsafe<B>> ApplyT<L, A, B>(this Func<A, B> fab, Either<L, OptionUnsafe<A>> fa) =>
            ApplEither<L, OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MEither<L, Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => ApplOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Either&lt;L, OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Either&lt;L, OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <returns>`Either&lt;L, OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Either<L, OptionUnsafe<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Either<L, OptionUnsafe<A>> fa, Either<L, OptionUnsafe<B>> fb) =>
            ApplEither<L, OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MEither<L, Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            ApplOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`EitherUnsafe&lt;L, OptionUnsafe&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, OptionUnsafe<A>> ma,
            Func<A, EitherUnsafe<L, OptionUnsafe<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MEitherUnsafe<L, OptionUnsafe<C>>, EitherUnsafe<L, OptionUnsafe<C>>, MOptionUnsafe<C>, OptionUnsafe<C>, C>(ma, a =>
                    Trans<MEitherUnsafe<L, OptionUnsafe<B>>, EitherUnsafe<L, OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>
                        .Inst.Bind<MEitherUnsafe<L, OptionUnsafe<C>>, EitherUnsafe<L, OptionUnsafe<C>>, MOptionUnsafe<C>, OptionUnsafe<C>, C>(bind(a), b =>
                            default(MOptionUnsafe<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, OptionUnsafe&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<A>> Where<L, A>(this EitherUnsafe<L, OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<B>> Select<L, A, B>(this EitherUnsafe<L, OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MEitherUnsafe<L, OptionUnsafe<B>>, EitherUnsafe<L, OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherUnsafe&lt;L, OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherUnsafe&lt;L, OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this EitherUnsafe<L, OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherUnsafe&lt;L, OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherUnsafe&lt;L, OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this EitherUnsafe<L, OptionUnsafe<A>> ma) =>
            Trans<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<B>> BindT<L, A, B>(this EitherUnsafe<L, OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            Trans<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MEitherUnsafe<L, OptionUnsafe<B>>, EitherUnsafe<L, OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<B>> BindT<L, A, B>(this EitherUnsafe<L, OptionUnsafe<A>> ma, Func<A, EitherUnsafe<L, OptionUnsafe<B>>> f) =>
            Trans<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MEitherUnsafe<L, OptionUnsafe<B>>, EitherUnsafe<L, OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `EitherUnsafe&lt;L, OptionUnsafe&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe&lt;EitherUnsafe&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;EitherUnsafe&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, B>> Traverse<L, A, B>(this EitherUnsafe<L, OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<EitherUnsafe<L, B>>, OptionUnsafe<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `EitherUnsafe&lt;L, OptionUnsafe&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe&lt;EitherUnsafe&lt;L, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, A>> Sequence<L, A>(this EitherUnsafe<L, OptionUnsafe<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<B>> MapT<L, A, B>(this EitherUnsafe<L, OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MEitherUnsafe<L, OptionUnsafe<B>>, EitherUnsafe<L, OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this EitherUnsafe<L, OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this EitherUnsafe<L, OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this EitherUnsafe<L, OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this EitherUnsafe<L, OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherUnsafe&lt;L, OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this EitherUnsafe<L, OptionUnsafe<A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, OptionUnsafe&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<A>> FilterT<L, A>(this EitherUnsafe<L, OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MEitherUnsafe<L, OptionUnsafe<A>>, EitherUnsafe<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, OptionUnsafe&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<A>> PlusT<NUM, L, A>(this EitherUnsafe<L, OptionUnsafe<A>> x, EitherUnsafe<L, OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, OptionUnsafe&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<A>> SubtractT<NUM, L, A>(this EitherUnsafe<L, OptionUnsafe<A>> x, EitherUnsafe<L, OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<A>> ProductT<NUM, L, A>(this EitherUnsafe<L, OptionUnsafe<A>> x, EitherUnsafe<L, OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<A>> DivideT<NUM, L, A>(this EitherUnsafe<L, OptionUnsafe<A>> x, EitherUnsafe<L, OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<A>> AppendT<SEMI, L, A>(this EitherUnsafe<L, OptionUnsafe<A>> x, EitherUnsafe<L, OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this EitherUnsafe<L, OptionUnsafe<A>> x, EitherUnsafe<L, OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this EitherUnsafe<L, OptionUnsafe<A>> x, EitherUnsafe<L, OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe&lt;L, OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <returns>`EitherUnsafe&lt;L, OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherUnsafe<L, OptionUnsafe<A>> fa) =>
            ApplEitherUnsafe<L, OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => ApplOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe&lt;L, OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `EitherUnsafe&lt;L, OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <returns>`EitherUnsafe&lt;L, OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherUnsafe<L, OptionUnsafe<A>> fa, EitherUnsafe<L, OptionUnsafe<B>> fb) =>
            ApplEitherUnsafe<L, OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MEitherUnsafe<L, Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            ApplOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Try&lt;OptionUnsafe&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Try<OptionUnsafe<C>> SelectMany< A, B, C>(
            this Try<OptionUnsafe<A>> ma,
            Func<A, Try<OptionUnsafe<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MTry<OptionUnsafe<C>>, Try<OptionUnsafe<C>>, MOptionUnsafe<C>, OptionUnsafe<C>, C>(ma, a =>
                    Trans<MTry<OptionUnsafe<B>>, Try<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>
                        .Inst.Bind<MTry<OptionUnsafe<C>>, Try<OptionUnsafe<C>>, MOptionUnsafe<C>, OptionUnsafe<C>, C>(bind(a), b =>
                            default(MOptionUnsafe<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;OptionUnsafe&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<OptionUnsafe<A>> Where< A>(this Try<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<OptionUnsafe<B>> Select< A, B>(this Try<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MTry<OptionUnsafe<B>>, Try<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Try&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Try&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Try<OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Try&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Try&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Try<OptionUnsafe<A>> ma) =>
            Trans<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<OptionUnsafe<B>> BindT< A, B>(this Try<OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            Trans<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MTry<OptionUnsafe<B>>, Try<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<OptionUnsafe<B>> BindT< A, B>(this Try<OptionUnsafe<A>> ma, Func<A, Try<OptionUnsafe<B>>> f) =>
            Trans<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MTry<OptionUnsafe<B>>, Try<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Try&lt;OptionUnsafe&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe&lt;Try&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;Try&lt;B&gt;&gt;`</returns>
        [Pure]
        public static OptionUnsafe<Try<B>> Traverse< A, B>(this Try<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<Try<B>>, OptionUnsafe<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Try&lt;OptionUnsafe&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe&lt;Try&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static OptionUnsafe<Try<A>> Sequence< A>(this Try<OptionUnsafe<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<OptionUnsafe<B>> MapT< A, B>(this Try<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MTry<OptionUnsafe<B>>, Try<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Try<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Try<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Try<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Try<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Try&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Try<OptionUnsafe<A>> ma, Action<A> f) =>
            Trans<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;OptionUnsafe&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<OptionUnsafe<A>> FilterT< A>(this Try<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MTry<OptionUnsafe<A>>, Try<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Try<OptionUnsafe<A>> PlusT<NUM,  A>(this Try<OptionUnsafe<A>> x, Try<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Try<OptionUnsafe<A>> SubtractT<NUM,  A>(this Try<OptionUnsafe<A>> x, Try<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Try<OptionUnsafe<A>> ProductT<NUM,  A>(this Try<OptionUnsafe<A>> x, Try<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Try<OptionUnsafe<A>> DivideT<NUM,  A>(this Try<OptionUnsafe<A>> x, Try<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Try<OptionUnsafe<A>> AppendT<SEMI,  A>(this Try<OptionUnsafe<A>> x, Try<OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Try<OptionUnsafe<A>> x, Try<OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Try<OptionUnsafe<A>> x, Try<OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Try&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <returns>`Try&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Try<OptionUnsafe<B>> ApplyT< A, B>(this Func<A, B> fab, Try<OptionUnsafe<A>> fa) =>
            ApplTry< OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MTry< Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => ApplOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Try&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Try&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <returns>`Try&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Try<OptionUnsafe<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Try<OptionUnsafe<A>> fa, Try<OptionUnsafe<B>> fb) =>
            ApplTry< OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MTry< Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            ApplOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOption&lt;OptionUnsafe&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<OptionUnsafe<C>> SelectMany< A, B, C>(
            this TryOption<OptionUnsafe<A>> ma,
            Func<A, TryOption<OptionUnsafe<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MTryOption<OptionUnsafe<C>>, TryOption<OptionUnsafe<C>>, MOptionUnsafe<C>, OptionUnsafe<C>, C>(ma, a =>
                    Trans<MTryOption<OptionUnsafe<B>>, TryOption<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>
                        .Inst.Bind<MTryOption<OptionUnsafe<C>>, TryOption<OptionUnsafe<C>>, MOptionUnsafe<C>, OptionUnsafe<C>, C>(bind(a), b =>
                            default(MOptionUnsafe<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;OptionUnsafe&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<OptionUnsafe<A>> Where< A>(this TryOption<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<OptionUnsafe<B>> Select< A, B>(this TryOption<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MTryOption<OptionUnsafe<B>>, TryOption<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOption&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOption&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryOption<OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOption&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOption&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this TryOption<OptionUnsafe<A>> ma) =>
            Trans<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<OptionUnsafe<B>> BindT< A, B>(this TryOption<OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            Trans<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MTryOption<OptionUnsafe<B>>, TryOption<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<OptionUnsafe<B>> BindT< A, B>(this TryOption<OptionUnsafe<A>> ma, Func<A, TryOption<OptionUnsafe<B>>> f) =>
            Trans<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MTryOption<OptionUnsafe<B>>, TryOption<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOption&lt;OptionUnsafe&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe&lt;TryOption&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;TryOption&lt;B&gt;&gt;`</returns>
        [Pure]
        public static OptionUnsafe<TryOption<B>> Traverse< A, B>(this TryOption<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<TryOption<B>>, OptionUnsafe<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOption&lt;OptionUnsafe&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe&lt;TryOption&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static OptionUnsafe<TryOption<A>> Sequence< A>(this TryOption<OptionUnsafe<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<OptionUnsafe<B>> MapT< A, B>(this TryOption<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MTryOption<OptionUnsafe<B>>, TryOption<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryOption<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryOption<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryOption<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryOption<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOption&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryOption<OptionUnsafe<A>> ma, Action<A> f) =>
            Trans<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;OptionUnsafe&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<OptionUnsafe<A>> FilterT< A>(this TryOption<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MTryOption<OptionUnsafe<A>>, TryOption<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<OptionUnsafe<A>> PlusT<NUM,  A>(this TryOption<OptionUnsafe<A>> x, TryOption<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<OptionUnsafe<A>> SubtractT<NUM,  A>(this TryOption<OptionUnsafe<A>> x, TryOption<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOption<OptionUnsafe<A>> ProductT<NUM,  A>(this TryOption<OptionUnsafe<A>> x, TryOption<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOption<OptionUnsafe<A>> DivideT<NUM,  A>(this TryOption<OptionUnsafe<A>> x, TryOption<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOption<OptionUnsafe<A>> AppendT<SEMI,  A>(this TryOption<OptionUnsafe<A>> x, TryOption<OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryOption<OptionUnsafe<A>> x, TryOption<OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryOption<OptionUnsafe<A>> x, TryOption<OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOption&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <returns>`TryOption&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOption<OptionUnsafe<B>> ApplyT< A, B>(this Func<A, B> fab, TryOption<OptionUnsafe<A>> fa) =>
            ApplTryOption< OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MTryOption< Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => ApplOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOption&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryOption&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <returns>`TryOption&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOption<OptionUnsafe<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOption<OptionUnsafe<A>> fa, TryOption<OptionUnsafe<B>> fb) =>
            ApplTryOption< OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MTryOption< Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            ApplOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`IEnumerable&lt;OptionUnsafe&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<C>> SelectMany< A, B, C>(
            this IEnumerable<OptionUnsafe<A>> ma,
            Func<A, IEnumerable<OptionUnsafe<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MEnumerable<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MEnumerable<OptionUnsafe<C>>, IEnumerable<OptionUnsafe<C>>, MOptionUnsafe<C>, OptionUnsafe<C>, C>(ma, a =>
                    SeqTrans<MEnumerable<OptionUnsafe<B>>, IEnumerable<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>
                        .Inst.Bind<MEnumerable<OptionUnsafe<C>>, IEnumerable<OptionUnsafe<C>>, MOptionUnsafe<C>, OptionUnsafe<C>, C>(bind(a), b =>
                            default(MOptionUnsafe<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;OptionUnsafe&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<A>> Where< A>(this IEnumerable<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MEnumerable<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MEnumerable<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<B>> Select< A, B>(this IEnumerable<OptionUnsafe<A>> ma, Func<A, B> f) =>
            SeqTrans<MEnumerable<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MEnumerable<OptionUnsafe<B>>, IEnumerable<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `IEnumerable&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `IEnumerable&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this IEnumerable<OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MEnumerable<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `IEnumerable&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `IEnumerable&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this IEnumerable<OptionUnsafe<A>> ma) =>
            SeqTrans<MEnumerable<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<B>> BindT< A, B>(this IEnumerable<OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            SeqTrans<MEnumerable<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MEnumerable<OptionUnsafe<B>>, IEnumerable<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<B>> BindT< A, B>(this IEnumerable<OptionUnsafe<A>> ma, Func<A, IEnumerable<OptionUnsafe<B>>> f) =>
            SeqTrans<MEnumerable<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MEnumerable<OptionUnsafe<B>>, IEnumerable<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `IEnumerable&lt;OptionUnsafe&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe&lt;IEnumerable&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;IEnumerable&lt;B&gt;&gt;`</returns>
        [Pure]
        public static OptionUnsafe<IEnumerable<B>> Traverse< A, B>(this IEnumerable<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MEnumerable<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<IEnumerable<B>>, OptionUnsafe<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `IEnumerable&lt;OptionUnsafe&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe&lt;IEnumerable&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static OptionUnsafe<IEnumerable<A>> Sequence< A>(this IEnumerable<OptionUnsafe<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<B>> MapT< A, B>(this IEnumerable<OptionUnsafe<A>> ma, Func<A, B> f) =>
            SeqTrans<MEnumerable<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MEnumerable<OptionUnsafe<B>>, IEnumerable<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this IEnumerable<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MEnumerable<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this IEnumerable<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MEnumerable<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this IEnumerable<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            SeqTrans<MEnumerable<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this IEnumerable<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            SeqTrans<MEnumerable<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `IEnumerable&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this IEnumerable<OptionUnsafe<A>> ma, Action<A> f) =>
            SeqTrans<MEnumerable<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;OptionUnsafe&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<A>> FilterT< A>(this IEnumerable<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MEnumerable<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MEnumerable<OptionUnsafe<A>>, IEnumerable<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<A>> PlusT<NUM,  A>(this IEnumerable<OptionUnsafe<A>> x, IEnumerable<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<A>> SubtractT<NUM,  A>(this IEnumerable<OptionUnsafe<A>> x, IEnumerable<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<A>> ProductT<NUM,  A>(this IEnumerable<OptionUnsafe<A>> x, IEnumerable<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<A>> DivideT<NUM,  A>(this IEnumerable<OptionUnsafe<A>> x, IEnumerable<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<A>> AppendT<SEMI,  A>(this IEnumerable<OptionUnsafe<A>> x, IEnumerable<OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this IEnumerable<OptionUnsafe<A>> x, IEnumerable<OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this IEnumerable<OptionUnsafe<A>> x, IEnumerable<OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `IEnumerable&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <returns>`IEnumerable&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<B>> ApplyT< A, B>(this Func<A, B> fab, IEnumerable<OptionUnsafe<A>> fa) =>
            ApplEnumerable< OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MEnumerable< Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => ApplOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `IEnumerable&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `IEnumerable&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <returns>`IEnumerable&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, IEnumerable<OptionUnsafe<A>> fa, IEnumerable<OptionUnsafe<B>> fb) =>
            ApplEnumerable< OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MEnumerable< Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            ApplOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Seq&lt;OptionUnsafe&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Seq<OptionUnsafe<C>> SelectMany< A, B, C>(
            this Seq<OptionUnsafe<A>> ma,
            Func<A, Seq<OptionUnsafe<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MSeq<OptionUnsafe<A>>, Seq<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MSeq<OptionUnsafe<C>>, Seq<OptionUnsafe<C>>, MOptionUnsafe<C>, OptionUnsafe<C>, C>(ma, a =>
                    SeqTrans<MSeq<OptionUnsafe<B>>, Seq<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>
                        .Inst.Bind<MSeq<OptionUnsafe<C>>, Seq<OptionUnsafe<C>>, MOptionUnsafe<C>, OptionUnsafe<C>, C>(bind(a), b =>
                            default(MOptionUnsafe<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;OptionUnsafe&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<OptionUnsafe<A>> Where< A>(this Seq<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSeq<OptionUnsafe<A>>, Seq<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MSeq<OptionUnsafe<A>>, Seq<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<OptionUnsafe<B>> Select< A, B>(this Seq<OptionUnsafe<A>> ma, Func<A, B> f) =>
            SeqTrans<MSeq<OptionUnsafe<A>>, Seq<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MSeq<OptionUnsafe<B>>, Seq<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Seq&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Seq&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Seq<OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MSeq<OptionUnsafe<A>>, Seq<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Seq&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Seq&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Seq<OptionUnsafe<A>> ma) =>
            SeqTrans<MSeq<OptionUnsafe<A>>, Seq<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Seq&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<OptionUnsafe<B>> BindT< A, B>(this Seq<OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            SeqTrans<MSeq<OptionUnsafe<A>>, Seq<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MSeq<OptionUnsafe<B>>, Seq<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Seq&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<OptionUnsafe<B>> BindT< A, B>(this Seq<OptionUnsafe<A>> ma, Func<A, Seq<OptionUnsafe<B>>> f) =>
            SeqTrans<MSeq<OptionUnsafe<A>>, Seq<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MSeq<OptionUnsafe<B>>, Seq<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Seq&lt;OptionUnsafe&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe&lt;Seq&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;Seq&lt;B&gt;&gt;`</returns>
        [Pure]
        public static OptionUnsafe<Seq<B>> Traverse< A, B>(this Seq<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MSeq<OptionUnsafe<A>>, Seq<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<Seq<B>>, OptionUnsafe<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Seq&lt;OptionUnsafe&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe&lt;Seq&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static OptionUnsafe<Seq<A>> Sequence< A>(this Seq<OptionUnsafe<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<OptionUnsafe<B>> MapT< A, B>(this Seq<OptionUnsafe<A>> ma, Func<A, B> f) =>
            SeqTrans<MSeq<OptionUnsafe<A>>, Seq<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MSeq<OptionUnsafe<B>>, Seq<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Seq<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSeq<OptionUnsafe<A>>, Seq<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Seq<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSeq<OptionUnsafe<A>>, Seq<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Seq<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            SeqTrans<MSeq<OptionUnsafe<A>>, Seq<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Seq<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            SeqTrans<MSeq<OptionUnsafe<A>>, Seq<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Seq&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Seq<OptionUnsafe<A>> ma, Action<A> f) =>
            SeqTrans<MSeq<OptionUnsafe<A>>, Seq<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;OptionUnsafe&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<OptionUnsafe<A>> FilterT< A>(this Seq<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSeq<OptionUnsafe<A>>, Seq<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MSeq<OptionUnsafe<A>>, Seq<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Seq<OptionUnsafe<A>> PlusT<NUM,  A>(this Seq<OptionUnsafe<A>> x, Seq<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Seq<OptionUnsafe<A>> SubtractT<NUM,  A>(this Seq<OptionUnsafe<A>> x, Seq<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Seq<OptionUnsafe<A>> ProductT<NUM,  A>(this Seq<OptionUnsafe<A>> x, Seq<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Seq<OptionUnsafe<A>> DivideT<NUM,  A>(this Seq<OptionUnsafe<A>> x, Seq<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Seq<OptionUnsafe<A>> AppendT<SEMI,  A>(this Seq<OptionUnsafe<A>> x, Seq<OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Seq<OptionUnsafe<A>> x, Seq<OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Seq<OptionUnsafe<A>> x, Seq<OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Seq&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <returns>`Seq&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Seq<OptionUnsafe<B>> ApplyT< A, B>(this Func<A, B> fab, Seq<OptionUnsafe<A>> fa) =>
            ApplSeq< OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MSeq< Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => ApplOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Seq&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Seq&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <returns>`Seq&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Seq<OptionUnsafe<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Seq<OptionUnsafe<A>> fa, Seq<OptionUnsafe<B>> fb) =>
            ApplSeq< OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MSeq< Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            ApplOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Set&lt;OptionUnsafe&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Set<OptionUnsafe<C>> SelectMany< A, B, C>(
            this Set<OptionUnsafe<A>> ma,
            Func<A, Set<OptionUnsafe<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MSet<OptionUnsafe<C>>, Set<OptionUnsafe<C>>, MOptionUnsafe<C>, OptionUnsafe<C>, C>(ma, a =>
                    SeqTrans<MSet<OptionUnsafe<B>>, Set<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>
                        .Inst.Bind<MSet<OptionUnsafe<C>>, Set<OptionUnsafe<C>>, MOptionUnsafe<C>, OptionUnsafe<C>, C>(bind(a), b =>
                            default(MOptionUnsafe<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;OptionUnsafe&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<OptionUnsafe<A>> Where< A>(this Set<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<OptionUnsafe<B>> Select< A, B>(this Set<OptionUnsafe<A>> ma, Func<A, B> f) =>
            SeqTrans<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MSet<OptionUnsafe<B>>, Set<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Set&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Set&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Set<OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Set&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Set&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Set<OptionUnsafe<A>> ma) =>
            SeqTrans<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<OptionUnsafe<B>> BindT< A, B>(this Set<OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            SeqTrans<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MSet<OptionUnsafe<B>>, Set<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<OptionUnsafe<B>> BindT< A, B>(this Set<OptionUnsafe<A>> ma, Func<A, Set<OptionUnsafe<B>>> f) =>
            SeqTrans<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MSet<OptionUnsafe<B>>, Set<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Set&lt;OptionUnsafe&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe&lt;Set&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;Set&lt;B&gt;&gt;`</returns>
        [Pure]
        public static OptionUnsafe<Set<B>> Traverse< A, B>(this Set<OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<Set<B>>, OptionUnsafe<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Set&lt;OptionUnsafe&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe&lt;Set&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static OptionUnsafe<Set<A>> Sequence< A>(this Set<OptionUnsafe<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<OptionUnsafe<B>> MapT< A, B>(this Set<OptionUnsafe<A>> ma, Func<A, B> f) =>
            SeqTrans<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MSet<OptionUnsafe<B>>, Set<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Set<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Set<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Set<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            SeqTrans<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Set<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            SeqTrans<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Set&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Set<OptionUnsafe<A>> ma, Action<A> f) =>
            SeqTrans<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;OptionUnsafe&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<OptionUnsafe<A>> FilterT< A>(this Set<OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MSet<OptionUnsafe<A>>, Set<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Set<OptionUnsafe<A>> PlusT<NUM,  A>(this Set<OptionUnsafe<A>> x, Set<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Set<OptionUnsafe<A>> SubtractT<NUM,  A>(this Set<OptionUnsafe<A>> x, Set<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Set<OptionUnsafe<A>> ProductT<NUM,  A>(this Set<OptionUnsafe<A>> x, Set<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Set<OptionUnsafe<A>> DivideT<NUM,  A>(this Set<OptionUnsafe<A>> x, Set<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Set<OptionUnsafe<A>> AppendT<SEMI,  A>(this Set<OptionUnsafe<A>> x, Set<OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Set<OptionUnsafe<A>> x, Set<OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Set<OptionUnsafe<A>> x, Set<OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Set&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <returns>`Set&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Set<OptionUnsafe<B>> ApplyT< A, B>(this Func<A, B> fab, Set<OptionUnsafe<A>> fa) =>
            ApplSet< OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MSet< Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => ApplOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Set&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Set&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <returns>`Set&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Set<OptionUnsafe<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Set<OptionUnsafe<A>> fa, Set<OptionUnsafe<B>> fb) =>
            ApplSet< OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MSet< Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            ApplOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Validation&lt;FAIL, OptionUnsafe&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Validation<FAIL, OptionUnsafe<C>> SelectMany<FAIL, A, B, C>(
            this Validation<FAIL, OptionUnsafe<A>> ma,
            Func<A, Validation<FAIL, OptionUnsafe<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MValidation<FAIL, OptionUnsafe<A>>, Validation<FAIL, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MValidation<FAIL, OptionUnsafe<C>>, Validation<FAIL, OptionUnsafe<C>>, MOptionUnsafe<C>, OptionUnsafe<C>, C>(ma, a =>
                    Trans<MValidation<FAIL, OptionUnsafe<B>>, Validation<FAIL, OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>
                        .Inst.Bind<MValidation<FAIL, OptionUnsafe<C>>, Validation<FAIL, OptionUnsafe<C>>, MOptionUnsafe<C>, OptionUnsafe<C>, C>(bind(a), b =>
                            default(MOptionUnsafe<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, OptionUnsafe&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, OptionUnsafe<A>> Where<FAIL, A>(this Validation<FAIL, OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MValidation<FAIL, OptionUnsafe<A>>, Validation<FAIL, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MValidation<FAIL, OptionUnsafe<A>>, Validation<FAIL, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, OptionUnsafe<B>> Select<FAIL, A, B>(this Validation<FAIL, OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MValidation<FAIL, OptionUnsafe<A>>, Validation<FAIL, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MValidation<FAIL, OptionUnsafe<B>>, Validation<FAIL, OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Validation&lt;FAIL, OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, OptionUnsafe&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Validation&lt;FAIL, OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, FAIL, A>(this Validation<FAIL, OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MValidation<FAIL, OptionUnsafe<A>>, Validation<FAIL, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Validation&lt;FAIL, OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, OptionUnsafe&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Validation&lt;FAIL, OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<FAIL, A>(this Validation<FAIL, OptionUnsafe<A>> ma) =>
            Trans<MValidation<FAIL, OptionUnsafe<A>>, Validation<FAIL, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Validation&lt;FAIL, OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, OptionUnsafe<B>> BindT<FAIL, A, B>(this Validation<FAIL, OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            Trans<MValidation<FAIL, OptionUnsafe<A>>, Validation<FAIL, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MValidation<FAIL, OptionUnsafe<B>>, Validation<FAIL, OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Validation&lt;FAIL, OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, OptionUnsafe<B>> BindT<FAIL, A, B>(this Validation<FAIL, OptionUnsafe<A>> ma, Func<A, Validation<FAIL, OptionUnsafe<B>>> f) =>
            Trans<MValidation<FAIL, OptionUnsafe<A>>, Validation<FAIL, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MValidation<FAIL, OptionUnsafe<B>>, Validation<FAIL, OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Validation&lt;FAIL, OptionUnsafe&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe&lt;Validation&lt;FAIL, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;Validation&lt;FAIL, B&gt;&gt;`</returns>
        [Pure]
        public static OptionUnsafe<Validation<FAIL, B>> Traverse<FAIL, A, B>(this Validation<FAIL, OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MValidation<FAIL, OptionUnsafe<A>>, Validation<FAIL, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Traverse<MOptionUnsafe<Validation<FAIL, B>>, OptionUnsafe<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Validation&lt;FAIL, OptionUnsafe&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `OptionUnsafe&lt;Validation&lt;FAIL, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<FAIL, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static OptionUnsafe<Validation<FAIL, A>> Sequence<FAIL, A>(this Validation<FAIL, OptionUnsafe<A>> ma) =>
            ma.Traverse<FAIL, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, OptionUnsafe<B>> MapT<FAIL, A, B>(this Validation<FAIL, OptionUnsafe<A>> ma, Func<A, B> f) =>
            Trans<MValidation<FAIL, OptionUnsafe<A>>, Validation<FAIL, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Map<MValidation<FAIL, OptionUnsafe<B>>, Validation<FAIL, OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, FAIL, A>(this Validation<FAIL, OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MValidation<FAIL, OptionUnsafe<A>>, Validation<FAIL, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, FAIL, A>(this Validation<FAIL, OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MValidation<FAIL, OptionUnsafe<A>>, Validation<FAIL, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<FAIL, A>(this Validation<FAIL, OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MValidation<FAIL, OptionUnsafe<A>>, Validation<FAIL, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<FAIL, A>(this Validation<FAIL, OptionUnsafe<A>> ma, Func<A, bool> f) =>
            Trans<MValidation<FAIL, OptionUnsafe<A>>, Validation<FAIL, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Validation&lt;FAIL, OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<FAIL, A>(this Validation<FAIL, OptionUnsafe<A>> ma, Action<A> f) =>
            Trans<MValidation<FAIL, OptionUnsafe<A>>, Validation<FAIL, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, OptionUnsafe&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, OptionUnsafe<A>> FilterT<FAIL, A>(this Validation<FAIL, OptionUnsafe<A>> ma, Func<A, bool> pred) =>
            Trans<MValidation<FAIL, OptionUnsafe<A>>, Validation<FAIL, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>
                .Inst.Bind<MValidation<FAIL, OptionUnsafe<A>>, Validation<FAIL, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>(ma, 
                    a => pred(a)
                        ? default(MOptionUnsafe<A>).Return(a)
                        : default(MOptionUnsafe<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, OptionUnsafe&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Validation<FAIL, OptionUnsafe<A>> PlusT<NUM, FAIL, A>(this Validation<FAIL, OptionUnsafe<A>> x, Validation<FAIL, OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, OptionUnsafe&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Validation<FAIL, OptionUnsafe<A>> SubtractT<NUM, FAIL, A>(this Validation<FAIL, OptionUnsafe<A>> x, Validation<FAIL, OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Validation<FAIL, OptionUnsafe<A>> ProductT<NUM, FAIL, A>(this Validation<FAIL, OptionUnsafe<A>> x, Validation<FAIL, OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Validation<FAIL, OptionUnsafe<A>> DivideT<NUM, FAIL, A>(this Validation<FAIL, OptionUnsafe<A>> x, Validation<FAIL, OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Validation<FAIL, OptionUnsafe<A>> AppendT<SEMI, FAIL, A>(this Validation<FAIL, OptionUnsafe<A>> x, Validation<FAIL, OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, FAIL, A>(this Validation<FAIL, OptionUnsafe<A>> x, Validation<FAIL, OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, FAIL, A>(this Validation<FAIL, OptionUnsafe<A>> x, Validation<FAIL, OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Validation&lt;FAIL, OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <returns>`Validation&lt;FAIL, OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Validation<FAIL, OptionUnsafe<B>> ApplyT<FAIL, A, B>(this Func<A, B> fab, Validation<FAIL, OptionUnsafe<A>> fa) =>
            ApplValidation<FAIL, OptionUnsafe<A>, OptionUnsafe<B>>.Inst.Apply(
                 MValidation<FAIL, Func<OptionUnsafe<A>, OptionUnsafe<B>>>.Inst.Return((OptionUnsafe<A> a) => ApplOptionUnsafe< A, B>.Inst.Apply(
                     MOptionUnsafe< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Validation&lt;FAIL, OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Validation&lt;FAIL, OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <returns>`Validation&lt;FAIL, OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Validation<FAIL, OptionUnsafe<C>> ApplyT<FAIL, A, B, C>(this Func<A, B, C> fabc, Validation<FAIL, OptionUnsafe<A>> fa, Validation<FAIL, OptionUnsafe<B>> fb) =>
            ApplValidation<FAIL, OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>.Inst.Apply(
                MValidation<FAIL, Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>.Inst.Return(
                    (OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            ApplOptionUnsafe< A, B, C>.Inst.Apply(
                                MOptionUnsafe< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    /// <summary>
    /// Monad transformer for Either, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class EitherT_Extensions
    {
        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Arr&lt;Either&lt;L, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<Either<L, C>> SelectMany<L, A, B, C>(
            this Arr<Either<L, A>> ma,
            Func<A, Arr<Either<L, B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MArr<Either<L, C>>, Arr<Either<L, C>>, MEither<L, C>, Either<L, C>, C>(ma, a =>
                    SeqTrans<MArr<Either<L, B>>, Arr<Either<L, B>>, MEither<L, B>, Either<L, B>, B>
                        .Inst.Bind<MArr<Either<L, C>>, Arr<Either<L, C>>, MEither<L, C>, Either<L, C>, C>(bind(a), b =>
                            default(MEither<L, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;Either&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<Either<L, A>> Where<L, A>(this Arr<Either<L, A>> ma, Func<A, bool> pred) =>
            SeqTrans<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Either<L, B>> Select<L, A, B>(this Arr<Either<L, A>> ma, Func<A, B> f) =>
            SeqTrans<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MArr<Either<L, B>>, Arr<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Arr&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Either&lt;L, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Arr&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Arr<Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Arr&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Either&lt;L, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Arr&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this Arr<Either<L, A>> ma) =>
            SeqTrans<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Either<L, B>> BindT<L, A, B>(this Arr<Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            SeqTrans<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MArr<Either<L, B>>, Arr<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Either<L, B>> BindT<L, A, B>(this Arr<Either<L, A>> ma, Func<A, Arr<Either<L, B>>> f) =>
            SeqTrans<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MArr<Either<L, B>>, Arr<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Arr&lt;Either&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Either&lt;L, Arr&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, Arr&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Either<L, Arr<B>> Traverse<L, A, B>(this Arr<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, Arr<B>>, Either<L, Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Arr&lt;Either&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Either&lt;L, Arr&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Either<L, Arr<A>> Sequence<L, A>(this Arr<Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Either<L, B>> MapT<L, A, B>(this Arr<Either<L, A>> ma, Func<A, B> f) =>
            SeqTrans<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MArr<Either<L, B>>, Arr<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Arr<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Arr<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Arr<Either<L, A>> ma, Func<A, bool> f) =>
            SeqTrans<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Arr<Either<L, A>> ma, Func<A, bool> f) =>
            SeqTrans<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Arr&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Arr<Either<L, A>> ma, Action<A> f) =>
            SeqTrans<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;Either&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<Either<L, A>> FilterT<L, A>(this Arr<Either<L, A>> ma, Func<A, bool> pred) =>
            SeqTrans<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MArr<Either<L, A>>, Arr<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Either&lt;L, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Arr<Either<L, A>> PlusT<NUM, L, A>(this Arr<Either<L, A>> x, Arr<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Either&lt;L, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Arr<Either<L, A>> SubtractT<NUM, L, A>(this Arr<Either<L, A>> x, Arr<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Arr<Either<L, A>> ProductT<NUM, L, A>(this Arr<Either<L, A>> x, Arr<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Arr<Either<L, A>> DivideT<NUM, L, A>(this Arr<Either<L, A>> x, Arr<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Arr<Either<L, A>> AppendT<SEMI, L, A>(this Arr<Either<L, A>> x, Arr<Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Arr<Either<L, A>> x, Arr<Either<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Arr<Either<L, A>> x, Arr<Either<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Arr&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <returns>`Arr&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Arr<Either<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, Arr<Either<L, A>> fa) =>
            ApplArr< Either<L, A>, Either<L, B>>.Inst.Apply(
                 MArr< Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => ApplEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Arr&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Arr&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <returns>`Arr&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Arr<Either<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Arr<Either<L, A>> fa, Arr<Either<L, B>> fb) =>
            ApplArr< Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MArr< Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            ApplEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`HashSet&lt;Either&lt;L, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<Either<L, C>> SelectMany<L, A, B, C>(
            this HashSet<Either<L, A>> ma,
            Func<A, HashSet<Either<L, B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MHashSet<Either<L, C>>, HashSet<Either<L, C>>, MEither<L, C>, Either<L, C>, C>(ma, a =>
                    SeqTrans<MHashSet<Either<L, B>>, HashSet<Either<L, B>>, MEither<L, B>, Either<L, B>, B>
                        .Inst.Bind<MHashSet<Either<L, C>>, HashSet<Either<L, C>>, MEither<L, C>, Either<L, C>, C>(bind(a), b =>
                            default(MEither<L, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;Either&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<Either<L, A>> Where<L, A>(this HashSet<Either<L, A>> ma, Func<A, bool> pred) =>
            SeqTrans<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Either<L, B>> Select<L, A, B>(this HashSet<Either<L, A>> ma, Func<A, B> f) =>
            SeqTrans<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MHashSet<Either<L, B>>, HashSet<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `HashSet&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Either&lt;L, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `HashSet&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this HashSet<Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `HashSet&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Either&lt;L, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `HashSet&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this HashSet<Either<L, A>> ma) =>
            SeqTrans<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Either<L, B>> BindT<L, A, B>(this HashSet<Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            SeqTrans<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MHashSet<Either<L, B>>, HashSet<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Either<L, B>> BindT<L, A, B>(this HashSet<Either<L, A>> ma, Func<A, HashSet<Either<L, B>>> f) =>
            SeqTrans<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MHashSet<Either<L, B>>, HashSet<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `HashSet&lt;Either&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Either&lt;L, HashSet&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, HashSet&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Either<L, HashSet<B>> Traverse<L, A, B>(this HashSet<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, HashSet<B>>, Either<L, HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `HashSet&lt;Either&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Either&lt;L, HashSet&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Either<L, HashSet<A>> Sequence<L, A>(this HashSet<Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Either<L, B>> MapT<L, A, B>(this HashSet<Either<L, A>> ma, Func<A, B> f) =>
            SeqTrans<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MHashSet<Either<L, B>>, HashSet<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this HashSet<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this HashSet<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this HashSet<Either<L, A>> ma, Func<A, bool> f) =>
            SeqTrans<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this HashSet<Either<L, A>> ma, Func<A, bool> f) =>
            SeqTrans<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `HashSet&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this HashSet<Either<L, A>> ma, Action<A> f) =>
            SeqTrans<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;Either&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<Either<L, A>> FilterT<L, A>(this HashSet<Either<L, A>> ma, Func<A, bool> pred) =>
            SeqTrans<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MHashSet<Either<L, A>>, HashSet<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Either&lt;L, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<Either<L, A>> PlusT<NUM, L, A>(this HashSet<Either<L, A>> x, HashSet<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Either&lt;L, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<Either<L, A>> SubtractT<NUM, L, A>(this HashSet<Either<L, A>> x, HashSet<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static HashSet<Either<L, A>> ProductT<NUM, L, A>(this HashSet<Either<L, A>> x, HashSet<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static HashSet<Either<L, A>> DivideT<NUM, L, A>(this HashSet<Either<L, A>> x, HashSet<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static HashSet<Either<L, A>> AppendT<SEMI, L, A>(this HashSet<Either<L, A>> x, HashSet<Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this HashSet<Either<L, A>> x, HashSet<Either<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this HashSet<Either<L, A>> x, HashSet<Either<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `HashSet&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <returns>`HashSet&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static HashSet<Either<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, HashSet<Either<L, A>> fa) =>
            ApplHashSet< Either<L, A>, Either<L, B>>.Inst.Apply(
                 MHashSet< Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => ApplEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `HashSet&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `HashSet&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <returns>`HashSet&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static HashSet<Either<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, HashSet<Either<L, A>> fa, HashSet<Either<L, B>> fb) =>
            ApplHashSet< Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MHashSet< Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            ApplEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Lst&lt;Either&lt;L, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<Either<L, C>> SelectMany<L, A, B, C>(
            this Lst<Either<L, A>> ma,
            Func<A, Lst<Either<L, B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MLst<Either<L, C>>, Lst<Either<L, C>>, MEither<L, C>, Either<L, C>, C>(ma, a =>
                    SeqTrans<MLst<Either<L, B>>, Lst<Either<L, B>>, MEither<L, B>, Either<L, B>, B>
                        .Inst.Bind<MLst<Either<L, C>>, Lst<Either<L, C>>, MEither<L, C>, Either<L, C>, C>(bind(a), b =>
                            default(MEither<L, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;Either&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<Either<L, A>> Where<L, A>(this Lst<Either<L, A>> ma, Func<A, bool> pred) =>
            SeqTrans<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Either<L, B>> Select<L, A, B>(this Lst<Either<L, A>> ma, Func<A, B> f) =>
            SeqTrans<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MLst<Either<L, B>>, Lst<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Lst&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Either&lt;L, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Lst&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Lst<Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Lst&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Either&lt;L, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Lst&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this Lst<Either<L, A>> ma) =>
            SeqTrans<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Either<L, B>> BindT<L, A, B>(this Lst<Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            SeqTrans<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MLst<Either<L, B>>, Lst<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Either<L, B>> BindT<L, A, B>(this Lst<Either<L, A>> ma, Func<A, Lst<Either<L, B>>> f) =>
            SeqTrans<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MLst<Either<L, B>>, Lst<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Lst&lt;Either&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Either&lt;L, Lst&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, Lst&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Either<L, Lst<B>> Traverse<L, A, B>(this Lst<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, Lst<B>>, Either<L, Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Lst&lt;Either&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Either&lt;L, Lst&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Either<L, Lst<A>> Sequence<L, A>(this Lst<Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Either<L, B>> MapT<L, A, B>(this Lst<Either<L, A>> ma, Func<A, B> f) =>
            SeqTrans<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MLst<Either<L, B>>, Lst<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Lst<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Lst<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Lst<Either<L, A>> ma, Func<A, bool> f) =>
            SeqTrans<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Lst<Either<L, A>> ma, Func<A, bool> f) =>
            SeqTrans<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Lst&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Lst<Either<L, A>> ma, Action<A> f) =>
            SeqTrans<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;Either&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<Either<L, A>> FilterT<L, A>(this Lst<Either<L, A>> ma, Func<A, bool> pred) =>
            SeqTrans<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MLst<Either<L, A>>, Lst<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Either&lt;L, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Lst<Either<L, A>> PlusT<NUM, L, A>(this Lst<Either<L, A>> x, Lst<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Either&lt;L, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Lst<Either<L, A>> SubtractT<NUM, L, A>(this Lst<Either<L, A>> x, Lst<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Lst<Either<L, A>> ProductT<NUM, L, A>(this Lst<Either<L, A>> x, Lst<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Lst<Either<L, A>> DivideT<NUM, L, A>(this Lst<Either<L, A>> x, Lst<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Lst<Either<L, A>> AppendT<SEMI, L, A>(this Lst<Either<L, A>> x, Lst<Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Lst<Either<L, A>> x, Lst<Either<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Lst<Either<L, A>> x, Lst<Either<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Lst&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <returns>`Lst&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Lst<Either<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, Lst<Either<L, A>> fa) =>
            ApplLst< Either<L, A>, Either<L, B>>.Inst.Apply(
                 MLst< Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => ApplEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Lst&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Lst&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <returns>`Lst&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Lst<Either<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Lst<Either<L, A>> fa, Lst<Either<L, B>> fb) =>
            ApplLst< Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MLst< Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            ApplEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Option&lt;Either&lt;L, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Option<Either<L, C>> SelectMany<L, A, B, C>(
            this Option<Either<L, A>> ma,
            Func<A, Option<Either<L, B>>> bind,
            Func<A, B, C> project) =>
            Trans<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MOption<Either<L, C>>, Option<Either<L, C>>, MEither<L, C>, Either<L, C>, C>(ma, a =>
                    Trans<MOption<Either<L, B>>, Option<Either<L, B>>, MEither<L, B>, Either<L, B>, B>
                        .Inst.Bind<MOption<Either<L, C>>, Option<Either<L, C>>, MEither<L, C>, Either<L, C>, C>(bind(a), b =>
                            default(MEither<L, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;Either&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<Either<L, A>> Where<L, A>(this Option<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Either<L, B>> Select<L, A, B>(this Option<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MOption<Either<L, B>>, Option<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Option&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Either&lt;L, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Option&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Option<Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Option&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Either&lt;L, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Option&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this Option<Either<L, A>> ma) =>
            Trans<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Either<L, B>> BindT<L, A, B>(this Option<Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            Trans<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MOption<Either<L, B>>, Option<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Either<L, B>> BindT<L, A, B>(this Option<Either<L, A>> ma, Func<A, Option<Either<L, B>>> f) =>
            Trans<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MOption<Either<L, B>>, Option<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Option&lt;Either&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Either&lt;L, Option&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, Option&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Either<L, Option<B>> Traverse<L, A, B>(this Option<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, Option<B>>, Either<L, Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Option&lt;Either&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Either&lt;L, Option&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Either<L, Option<A>> Sequence<L, A>(this Option<Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Either<L, B>> MapT<L, A, B>(this Option<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MOption<Either<L, B>>, Option<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Option<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Option<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Option<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Option<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Option&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Option<Either<L, A>> ma, Action<A> f) =>
            Trans<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;Either&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<Either<L, A>> FilterT<L, A>(this Option<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MOption<Either<L, A>>, Option<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Either&lt;L, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Option<Either<L, A>> PlusT<NUM, L, A>(this Option<Either<L, A>> x, Option<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Either&lt;L, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Option<Either<L, A>> SubtractT<NUM, L, A>(this Option<Either<L, A>> x, Option<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Option<Either<L, A>> ProductT<NUM, L, A>(this Option<Either<L, A>> x, Option<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Option<Either<L, A>> DivideT<NUM, L, A>(this Option<Either<L, A>> x, Option<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Option<Either<L, A>> AppendT<SEMI, L, A>(this Option<Either<L, A>> x, Option<Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Option<Either<L, A>> x, Option<Either<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Option<Either<L, A>> x, Option<Either<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Option&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <returns>`Option&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Option<Either<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, Option<Either<L, A>> fa) =>
            ApplOption< Either<L, A>, Either<L, B>>.Inst.Apply(
                 MOption< Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => ApplEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Option&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Option&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <returns>`Option&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Option<Either<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Option<Either<L, A>> fa, Option<Either<L, B>> fb) =>
            ApplOption< Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MOption< Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            ApplEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionUnsafe&lt;Either&lt;L, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<Either<L, C>> SelectMany<L, A, B, C>(
            this OptionUnsafe<Either<L, A>> ma,
            Func<A, OptionUnsafe<Either<L, B>>> bind,
            Func<A, B, C> project) =>
            Trans<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MOptionUnsafe<Either<L, C>>, OptionUnsafe<Either<L, C>>, MEither<L, C>, Either<L, C>, C>(ma, a =>
                    Trans<MOptionUnsafe<Either<L, B>>, OptionUnsafe<Either<L, B>>, MEither<L, B>, Either<L, B>, B>
                        .Inst.Bind<MOptionUnsafe<Either<L, C>>, OptionUnsafe<Either<L, C>>, MEither<L, C>, Either<L, C>, C>(bind(a), b =>
                            default(MEither<L, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;Either&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<Either<L, A>> Where<L, A>(this OptionUnsafe<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Either<L, B>> Select<L, A, B>(this OptionUnsafe<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MOptionUnsafe<Either<L, B>>, OptionUnsafe<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionUnsafe&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Either&lt;L, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionUnsafe&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this OptionUnsafe<Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionUnsafe&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Either&lt;L, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionUnsafe&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this OptionUnsafe<Either<L, A>> ma) =>
            Trans<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Either<L, B>> BindT<L, A, B>(this OptionUnsafe<Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            Trans<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MOptionUnsafe<Either<L, B>>, OptionUnsafe<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Either<L, B>> BindT<L, A, B>(this OptionUnsafe<Either<L, A>> ma, Func<A, OptionUnsafe<Either<L, B>>> f) =>
            Trans<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MOptionUnsafe<Either<L, B>>, OptionUnsafe<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionUnsafe&lt;Either&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Either&lt;L, OptionUnsafe&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, OptionUnsafe&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Either<L, OptionUnsafe<B>> Traverse<L, A, B>(this OptionUnsafe<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, OptionUnsafe<B>>, Either<L, OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionUnsafe&lt;Either&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Either&lt;L, OptionUnsafe&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Either<L, OptionUnsafe<A>> Sequence<L, A>(this OptionUnsafe<Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Either<L, B>> MapT<L, A, B>(this OptionUnsafe<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MOptionUnsafe<Either<L, B>>, OptionUnsafe<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this OptionUnsafe<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this OptionUnsafe<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this OptionUnsafe<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this OptionUnsafe<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionUnsafe&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this OptionUnsafe<Either<L, A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;Either&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<Either<L, A>> FilterT<L, A>(this OptionUnsafe<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MOptionUnsafe<Either<L, A>>, OptionUnsafe<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Either&lt;L, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<Either<L, A>> PlusT<NUM, L, A>(this OptionUnsafe<Either<L, A>> x, OptionUnsafe<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Either&lt;L, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<Either<L, A>> SubtractT<NUM, L, A>(this OptionUnsafe<Either<L, A>> x, OptionUnsafe<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionUnsafe<Either<L, A>> ProductT<NUM, L, A>(this OptionUnsafe<Either<L, A>> x, OptionUnsafe<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionUnsafe<Either<L, A>> DivideT<NUM, L, A>(this OptionUnsafe<Either<L, A>> x, OptionUnsafe<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionUnsafe<Either<L, A>> AppendT<SEMI, L, A>(this OptionUnsafe<Either<L, A>> x, OptionUnsafe<Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this OptionUnsafe<Either<L, A>> x, OptionUnsafe<Either<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this OptionUnsafe<Either<L, A>> x, OptionUnsafe<Either<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <returns>`OptionUnsafe&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionUnsafe<Either<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, OptionUnsafe<Either<L, A>> fa) =>
            ApplOptionUnsafe< Either<L, A>, Either<L, B>>.Inst.Apply(
                 MOptionUnsafe< Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => ApplEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `OptionUnsafe&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <returns>`OptionUnsafe&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionUnsafe<Either<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, OptionUnsafe<Either<L, A>> fa, OptionUnsafe<Either<L, B>> fb) =>
            ApplOptionUnsafe< Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MOptionUnsafe< Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            ApplEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Either&lt;L, Either&lt;L, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, Either<L, C>> SelectMany<L, A, B, C>(
            this Either<L, Either<L, A>> ma,
            Func<A, Either<L, Either<L, B>>> bind,
            Func<A, B, C> project) =>
            Trans<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MEither<L, Either<L, C>>, Either<L, Either<L, C>>, MEither<L, C>, Either<L, C>, C>(ma, a =>
                    Trans<MEither<L, Either<L, B>>, Either<L, Either<L, B>>, MEither<L, B>, Either<L, B>, B>
                        .Inst.Bind<MEither<L, Either<L, C>>, Either<L, Either<L, C>>, MEither<L, C>, Either<L, C>, C>(bind(a), b =>
                            default(MEither<L, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, Either&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, Either<L, A>> Where<L, A>(this Either<L, Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Either<L, B>> Select<L, A, B>(this Either<L, Either<L, A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MEither<L, Either<L, B>>, Either<L, Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Either&lt;L, Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Either&lt;L, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Either&lt;L, Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Either<L, Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Either&lt;L, Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Either&lt;L, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Either&lt;L, Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this Either<L, Either<L, A>> ma) =>
            Trans<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either&lt;L, Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Either<L, B>> BindT<L, A, B>(this Either<L, Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            Trans<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MEither<L, Either<L, B>>, Either<L, Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either&lt;L, Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Either<L, B>> BindT<L, A, B>(this Either<L, Either<L, A>> ma, Func<A, Either<L, Either<L, B>>> f) =>
            Trans<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MEither<L, Either<L, B>>, Either<L, Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Either&lt;L, Either&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Either&lt;L, Either&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, Either&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static Either<L, Either<L, B>> Traverse<L, A, B>(this Either<L, Either<L, A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, Either<L, B>>, Either<L, Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Either&lt;L, Either&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Either&lt;L, Either&lt;L, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static Either<L, Either<L, A>> Sequence<L, A>(this Either<L, Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Either<L, B>> MapT<L, A, B>(this Either<L, Either<L, A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MEither<L, Either<L, B>>, Either<L, Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Either<L, Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Either<L, Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Either<L, Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Either<L, Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Either&lt;L, Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Either<L, Either<L, A>> ma, Action<A> f) =>
            Trans<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, Either&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, Either<L, A>> FilterT<L, A>(this Either<L, Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MEither<L, Either<L, A>>, Either<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Either&lt;L, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, Either<L, A>> PlusT<NUM, L, A>(this Either<L, Either<L, A>> x, Either<L, Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Either&lt;L, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, Either<L, A>> SubtractT<NUM, L, A>(this Either<L, Either<L, A>> x, Either<L, Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Either&lt;L, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Either<L, Either<L, A>> ProductT<NUM, L, A>(this Either<L, Either<L, A>> x, Either<L, Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Either&lt;L, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Either<L, Either<L, A>> DivideT<NUM, L, A>(this Either<L, Either<L, A>> x, Either<L, Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Either&lt;L, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Either<L, Either<L, A>> AppendT<SEMI, L, A>(this Either<L, Either<L, A>> x, Either<L, Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Either<L, Either<L, A>> x, Either<L, Either<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Either&lt;L, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Either<L, Either<L, A>> x, Either<L, Either<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Either&lt;L, Either&lt;L, A&gt;&gt;`</param>
        /// <returns>`Either&lt;L, Either&lt;L, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Either<L, Either<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, Either<L, Either<L, A>> fa) =>
            ApplEither<L, Either<L, A>, Either<L, B>>.Inst.Apply(
                 MEither<L, Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => ApplEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Either&lt;L, Either&lt;L, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Either&lt;L, Either&lt;L, A&gt;&gt;`</param>
        /// <returns>`Either&lt;L, Either&lt;L, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Either<L, Either<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Either<L, Either<L, A>> fa, Either<L, Either<L, B>> fb) =>
            ApplEither<L, Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MEither<L, Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            ApplEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`EitherUnsafe&lt;L, Either&lt;L, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, Either<L, A>> ma,
            Func<A, EitherUnsafe<L, Either<L, B>>> bind,
            Func<A, B, C> project) =>
            Trans<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MEitherUnsafe<L, Either<L, C>>, EitherUnsafe<L, Either<L, C>>, MEither<L, C>, Either<L, C>, C>(ma, a =>
                    Trans<MEitherUnsafe<L, Either<L, B>>, EitherUnsafe<L, Either<L, B>>, MEither<L, B>, Either<L, B>, B>
                        .Inst.Bind<MEitherUnsafe<L, Either<L, C>>, EitherUnsafe<L, Either<L, C>>, MEither<L, C>, Either<L, C>, C>(bind(a), b =>
                            default(MEither<L, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, Either&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, A>> Where<L, A>(this EitherUnsafe<L, Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, B>> Select<L, A, B>(this EitherUnsafe<L, Either<L, A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MEitherUnsafe<L, Either<L, B>>, EitherUnsafe<L, Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherUnsafe&lt;L, Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Either&lt;L, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherUnsafe&lt;L, Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this EitherUnsafe<L, Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherUnsafe&lt;L, Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Either&lt;L, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherUnsafe&lt;L, Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this EitherUnsafe<L, Either<L, A>> ma) =>
            Trans<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, B>> BindT<L, A, B>(this EitherUnsafe<L, Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            Trans<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MEitherUnsafe<L, Either<L, B>>, EitherUnsafe<L, Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, B>> BindT<L, A, B>(this EitherUnsafe<L, Either<L, A>> ma, Func<A, EitherUnsafe<L, Either<L, B>>> f) =>
            Trans<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MEitherUnsafe<L, Either<L, B>>, EitherUnsafe<L, Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `EitherUnsafe&lt;L, Either&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Either&lt;L, EitherUnsafe&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, EitherUnsafe&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, B>> Traverse<L, A, B>(this EitherUnsafe<L, Either<L, A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, EitherUnsafe<L, B>>, Either<L, EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `EitherUnsafe&lt;L, Either&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Either&lt;L, EitherUnsafe&lt;L, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, A>> Sequence<L, A>(this EitherUnsafe<L, Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, B>> MapT<L, A, B>(this EitherUnsafe<L, Either<L, A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MEitherUnsafe<L, Either<L, B>>, EitherUnsafe<L, Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this EitherUnsafe<L, Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this EitherUnsafe<L, Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this EitherUnsafe<L, Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this EitherUnsafe<L, Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherUnsafe&lt;L, Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this EitherUnsafe<L, Either<L, A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, Either&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, A>> FilterT<L, A>(this EitherUnsafe<L, Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MEitherUnsafe<L, Either<L, A>>, EitherUnsafe<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Either&lt;L, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, A>> PlusT<NUM, L, A>(this EitherUnsafe<L, Either<L, A>> x, EitherUnsafe<L, Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Either&lt;L, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, A>> SubtractT<NUM, L, A>(this EitherUnsafe<L, Either<L, A>> x, EitherUnsafe<L, Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Either&lt;L, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, A>> ProductT<NUM, L, A>(this EitherUnsafe<L, Either<L, A>> x, EitherUnsafe<L, Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Either&lt;L, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, A>> DivideT<NUM, L, A>(this EitherUnsafe<L, Either<L, A>> x, EitherUnsafe<L, Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Either&lt;L, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, A>> AppendT<SEMI, L, A>(this EitherUnsafe<L, Either<L, A>> x, EitherUnsafe<L, Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this EitherUnsafe<L, Either<L, A>> x, EitherUnsafe<L, Either<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Either&lt;L, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this EitherUnsafe<L, Either<L, A>> x, EitherUnsafe<L, Either<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe&lt;L, Either&lt;L, A&gt;&gt;`</param>
        /// <returns>`EitherUnsafe&lt;L, Either&lt;L, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherUnsafe<L, Either<L, A>> fa) =>
            ApplEitherUnsafe<L, Either<L, A>, Either<L, B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => ApplEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe&lt;L, Either&lt;L, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `EitherUnsafe&lt;L, Either&lt;L, A&gt;&gt;`</param>
        /// <returns>`EitherUnsafe&lt;L, Either&lt;L, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherUnsafe<L, Either<L, A>> fa, EitherUnsafe<L, Either<L, B>> fb) =>
            ApplEitherUnsafe<L, Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MEitherUnsafe<L, Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            ApplEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Try&lt;Either&lt;L, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Try<Either<L, C>> SelectMany<L, A, B, C>(
            this Try<Either<L, A>> ma,
            Func<A, Try<Either<L, B>>> bind,
            Func<A, B, C> project) =>
            Trans<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MTry<Either<L, C>>, Try<Either<L, C>>, MEither<L, C>, Either<L, C>, C>(ma, a =>
                    Trans<MTry<Either<L, B>>, Try<Either<L, B>>, MEither<L, B>, Either<L, B>, B>
                        .Inst.Bind<MTry<Either<L, C>>, Try<Either<L, C>>, MEither<L, C>, Either<L, C>, C>(bind(a), b =>
                            default(MEither<L, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;Either&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<Either<L, A>> Where<L, A>(this Try<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Either<L, B>> Select<L, A, B>(this Try<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MTry<Either<L, B>>, Try<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Try&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Either&lt;L, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Try&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Try<Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Try&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Either&lt;L, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Try&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this Try<Either<L, A>> ma) =>
            Trans<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Either<L, B>> BindT<L, A, B>(this Try<Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            Trans<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MTry<Either<L, B>>, Try<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Either<L, B>> BindT<L, A, B>(this Try<Either<L, A>> ma, Func<A, Try<Either<L, B>>> f) =>
            Trans<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MTry<Either<L, B>>, Try<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Try&lt;Either&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Either&lt;L, Try&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, Try&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Either<L, Try<B>> Traverse<L, A, B>(this Try<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, Try<B>>, Either<L, Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Try&lt;Either&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Either&lt;L, Try&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Either<L, Try<A>> Sequence<L, A>(this Try<Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Either<L, B>> MapT<L, A, B>(this Try<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MTry<Either<L, B>>, Try<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Try<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Try<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Try<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Try<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Try&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Try<Either<L, A>> ma, Action<A> f) =>
            Trans<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;Either&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<Either<L, A>> FilterT<L, A>(this Try<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MTry<Either<L, A>>, Try<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Either&lt;L, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Try<Either<L, A>> PlusT<NUM, L, A>(this Try<Either<L, A>> x, Try<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Either&lt;L, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Try<Either<L, A>> SubtractT<NUM, L, A>(this Try<Either<L, A>> x, Try<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Try<Either<L, A>> ProductT<NUM, L, A>(this Try<Either<L, A>> x, Try<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Try<Either<L, A>> DivideT<NUM, L, A>(this Try<Either<L, A>> x, Try<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Try<Either<L, A>> AppendT<SEMI, L, A>(this Try<Either<L, A>> x, Try<Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Try<Either<L, A>> x, Try<Either<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Try<Either<L, A>> x, Try<Either<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Try&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <returns>`Try&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Try<Either<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, Try<Either<L, A>> fa) =>
            ApplTry< Either<L, A>, Either<L, B>>.Inst.Apply(
                 MTry< Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => ApplEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Try&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Try&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <returns>`Try&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Try<Either<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Try<Either<L, A>> fa, Try<Either<L, B>> fb) =>
            ApplTry< Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MTry< Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            ApplEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOption&lt;Either&lt;L, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<Either<L, C>> SelectMany<L, A, B, C>(
            this TryOption<Either<L, A>> ma,
            Func<A, TryOption<Either<L, B>>> bind,
            Func<A, B, C> project) =>
            Trans<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MTryOption<Either<L, C>>, TryOption<Either<L, C>>, MEither<L, C>, Either<L, C>, C>(ma, a =>
                    Trans<MTryOption<Either<L, B>>, TryOption<Either<L, B>>, MEither<L, B>, Either<L, B>, B>
                        .Inst.Bind<MTryOption<Either<L, C>>, TryOption<Either<L, C>>, MEither<L, C>, Either<L, C>, C>(bind(a), b =>
                            default(MEither<L, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;Either&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<Either<L, A>> Where<L, A>(this TryOption<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Either<L, B>> Select<L, A, B>(this TryOption<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MTryOption<Either<L, B>>, TryOption<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOption&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Either&lt;L, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOption&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this TryOption<Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOption&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Either&lt;L, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOption&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this TryOption<Either<L, A>> ma) =>
            Trans<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Either<L, B>> BindT<L, A, B>(this TryOption<Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            Trans<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MTryOption<Either<L, B>>, TryOption<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Either<L, B>> BindT<L, A, B>(this TryOption<Either<L, A>> ma, Func<A, TryOption<Either<L, B>>> f) =>
            Trans<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MTryOption<Either<L, B>>, TryOption<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOption&lt;Either&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Either&lt;L, TryOption&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, TryOption&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Either<L, TryOption<B>> Traverse<L, A, B>(this TryOption<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, TryOption<B>>, Either<L, TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOption&lt;Either&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Either&lt;L, TryOption&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Either<L, TryOption<A>> Sequence<L, A>(this TryOption<Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Either<L, B>> MapT<L, A, B>(this TryOption<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MTryOption<Either<L, B>>, TryOption<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this TryOption<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this TryOption<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this TryOption<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this TryOption<Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOption&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this TryOption<Either<L, A>> ma, Action<A> f) =>
            Trans<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;Either&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<Either<L, A>> FilterT<L, A>(this TryOption<Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MTryOption<Either<L, A>>, TryOption<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Either&lt;L, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<Either<L, A>> PlusT<NUM, L, A>(this TryOption<Either<L, A>> x, TryOption<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Either&lt;L, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<Either<L, A>> SubtractT<NUM, L, A>(this TryOption<Either<L, A>> x, TryOption<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOption<Either<L, A>> ProductT<NUM, L, A>(this TryOption<Either<L, A>> x, TryOption<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOption<Either<L, A>> DivideT<NUM, L, A>(this TryOption<Either<L, A>> x, TryOption<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOption<Either<L, A>> AppendT<SEMI, L, A>(this TryOption<Either<L, A>> x, TryOption<Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this TryOption<Either<L, A>> x, TryOption<Either<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this TryOption<Either<L, A>> x, TryOption<Either<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOption&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <returns>`TryOption&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOption<Either<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, TryOption<Either<L, A>> fa) =>
            ApplTryOption< Either<L, A>, Either<L, B>>.Inst.Apply(
                 MTryOption< Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => ApplEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOption&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryOption&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <returns>`TryOption&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOption<Either<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, TryOption<Either<L, A>> fa, TryOption<Either<L, B>> fb) =>
            ApplTryOption< Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MTryOption< Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            ApplEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`IEnumerable&lt;Either&lt;L, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<Either<L, C>> SelectMany<L, A, B, C>(
            this IEnumerable<Either<L, A>> ma,
            Func<A, IEnumerable<Either<L, B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MEnumerable<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MEnumerable<Either<L, C>>, IEnumerable<Either<L, C>>, MEither<L, C>, Either<L, C>, C>(ma, a =>
                    SeqTrans<MEnumerable<Either<L, B>>, IEnumerable<Either<L, B>>, MEither<L, B>, Either<L, B>, B>
                        .Inst.Bind<MEnumerable<Either<L, C>>, IEnumerable<Either<L, C>>, MEither<L, C>, Either<L, C>, C>(bind(a), b =>
                            default(MEither<L, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;Either&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<Either<L, A>> Where<L, A>(this IEnumerable<Either<L, A>> ma, Func<A, bool> pred) =>
            SeqTrans<MEnumerable<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MEnumerable<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Either<L, B>> Select<L, A, B>(this IEnumerable<Either<L, A>> ma, Func<A, B> f) =>
            SeqTrans<MEnumerable<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MEnumerable<Either<L, B>>, IEnumerable<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `IEnumerable&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Either&lt;L, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `IEnumerable&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this IEnumerable<Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MEnumerable<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `IEnumerable&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Either&lt;L, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `IEnumerable&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this IEnumerable<Either<L, A>> ma) =>
            SeqTrans<MEnumerable<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Either<L, B>> BindT<L, A, B>(this IEnumerable<Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            SeqTrans<MEnumerable<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MEnumerable<Either<L, B>>, IEnumerable<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Either<L, B>> BindT<L, A, B>(this IEnumerable<Either<L, A>> ma, Func<A, IEnumerable<Either<L, B>>> f) =>
            SeqTrans<MEnumerable<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MEnumerable<Either<L, B>>, IEnumerable<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `IEnumerable&lt;Either&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Either&lt;L, IEnumerable&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, IEnumerable&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Either<L, IEnumerable<B>> Traverse<L, A, B>(this IEnumerable<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MEnumerable<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, IEnumerable<B>>, Either<L, IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `IEnumerable&lt;Either&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Either&lt;L, IEnumerable&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Either<L, IEnumerable<A>> Sequence<L, A>(this IEnumerable<Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Either<L, B>> MapT<L, A, B>(this IEnumerable<Either<L, A>> ma, Func<A, B> f) =>
            SeqTrans<MEnumerable<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MEnumerable<Either<L, B>>, IEnumerable<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this IEnumerable<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MEnumerable<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this IEnumerable<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MEnumerable<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this IEnumerable<Either<L, A>> ma, Func<A, bool> f) =>
            SeqTrans<MEnumerable<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this IEnumerable<Either<L, A>> ma, Func<A, bool> f) =>
            SeqTrans<MEnumerable<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `IEnumerable&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this IEnumerable<Either<L, A>> ma, Action<A> f) =>
            SeqTrans<MEnumerable<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;Either&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<Either<L, A>> FilterT<L, A>(this IEnumerable<Either<L, A>> ma, Func<A, bool> pred) =>
            SeqTrans<MEnumerable<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MEnumerable<Either<L, A>>, IEnumerable<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Either&lt;L, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<Either<L, A>> PlusT<NUM, L, A>(this IEnumerable<Either<L, A>> x, IEnumerable<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Either&lt;L, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<Either<L, A>> SubtractT<NUM, L, A>(this IEnumerable<Either<L, A>> x, IEnumerable<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static IEnumerable<Either<L, A>> ProductT<NUM, L, A>(this IEnumerable<Either<L, A>> x, IEnumerable<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static IEnumerable<Either<L, A>> DivideT<NUM, L, A>(this IEnumerable<Either<L, A>> x, IEnumerable<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static IEnumerable<Either<L, A>> AppendT<SEMI, L, A>(this IEnumerable<Either<L, A>> x, IEnumerable<Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this IEnumerable<Either<L, A>> x, IEnumerable<Either<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this IEnumerable<Either<L, A>> x, IEnumerable<Either<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `IEnumerable&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <returns>`IEnumerable&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static IEnumerable<Either<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, IEnumerable<Either<L, A>> fa) =>
            ApplEnumerable< Either<L, A>, Either<L, B>>.Inst.Apply(
                 MEnumerable< Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => ApplEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `IEnumerable&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `IEnumerable&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <returns>`IEnumerable&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static IEnumerable<Either<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, IEnumerable<Either<L, A>> fa, IEnumerable<Either<L, B>> fb) =>
            ApplEnumerable< Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MEnumerable< Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            ApplEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Seq&lt;Either&lt;L, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Seq<Either<L, C>> SelectMany<L, A, B, C>(
            this Seq<Either<L, A>> ma,
            Func<A, Seq<Either<L, B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MSeq<Either<L, A>>, Seq<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MSeq<Either<L, C>>, Seq<Either<L, C>>, MEither<L, C>, Either<L, C>, C>(ma, a =>
                    SeqTrans<MSeq<Either<L, B>>, Seq<Either<L, B>>, MEither<L, B>, Either<L, B>, B>
                        .Inst.Bind<MSeq<Either<L, C>>, Seq<Either<L, C>>, MEither<L, C>, Either<L, C>, C>(bind(a), b =>
                            default(MEither<L, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;Either&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<Either<L, A>> Where<L, A>(this Seq<Either<L, A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSeq<Either<L, A>>, Seq<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MSeq<Either<L, A>>, Seq<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<Either<L, B>> Select<L, A, B>(this Seq<Either<L, A>> ma, Func<A, B> f) =>
            SeqTrans<MSeq<Either<L, A>>, Seq<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MSeq<Either<L, B>>, Seq<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Seq&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Either&lt;L, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Seq&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Seq<Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MSeq<Either<L, A>>, Seq<Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Seq&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Either&lt;L, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Seq&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this Seq<Either<L, A>> ma) =>
            SeqTrans<MSeq<Either<L, A>>, Seq<Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Seq&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<Either<L, B>> BindT<L, A, B>(this Seq<Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            SeqTrans<MSeq<Either<L, A>>, Seq<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MSeq<Either<L, B>>, Seq<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Seq&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<Either<L, B>> BindT<L, A, B>(this Seq<Either<L, A>> ma, Func<A, Seq<Either<L, B>>> f) =>
            SeqTrans<MSeq<Either<L, A>>, Seq<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MSeq<Either<L, B>>, Seq<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Seq&lt;Either&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Either&lt;L, Seq&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, Seq&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Either<L, Seq<B>> Traverse<L, A, B>(this Seq<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MSeq<Either<L, A>>, Seq<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, Seq<B>>, Either<L, Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Seq&lt;Either&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Either&lt;L, Seq&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Either<L, Seq<A>> Sequence<L, A>(this Seq<Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<Either<L, B>> MapT<L, A, B>(this Seq<Either<L, A>> ma, Func<A, B> f) =>
            SeqTrans<MSeq<Either<L, A>>, Seq<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MSeq<Either<L, B>>, Seq<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Seq<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSeq<Either<L, A>>, Seq<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Seq<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSeq<Either<L, A>>, Seq<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Seq<Either<L, A>> ma, Func<A, bool> f) =>
            SeqTrans<MSeq<Either<L, A>>, Seq<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Seq<Either<L, A>> ma, Func<A, bool> f) =>
            SeqTrans<MSeq<Either<L, A>>, Seq<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Seq&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Seq<Either<L, A>> ma, Action<A> f) =>
            SeqTrans<MSeq<Either<L, A>>, Seq<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;Either&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<Either<L, A>> FilterT<L, A>(this Seq<Either<L, A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSeq<Either<L, A>>, Seq<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MSeq<Either<L, A>>, Seq<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Either&lt;L, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Seq<Either<L, A>> PlusT<NUM, L, A>(this Seq<Either<L, A>> x, Seq<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Either&lt;L, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Seq<Either<L, A>> SubtractT<NUM, L, A>(this Seq<Either<L, A>> x, Seq<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Seq<Either<L, A>> ProductT<NUM, L, A>(this Seq<Either<L, A>> x, Seq<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Seq<Either<L, A>> DivideT<NUM, L, A>(this Seq<Either<L, A>> x, Seq<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Seq<Either<L, A>> AppendT<SEMI, L, A>(this Seq<Either<L, A>> x, Seq<Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Seq<Either<L, A>> x, Seq<Either<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Seq<Either<L, A>> x, Seq<Either<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Seq&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <returns>`Seq&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Seq<Either<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, Seq<Either<L, A>> fa) =>
            ApplSeq< Either<L, A>, Either<L, B>>.Inst.Apply(
                 MSeq< Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => ApplEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Seq&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Seq&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <returns>`Seq&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Seq<Either<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Seq<Either<L, A>> fa, Seq<Either<L, B>> fb) =>
            ApplSeq< Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MSeq< Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            ApplEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Set&lt;Either&lt;L, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Set<Either<L, C>> SelectMany<L, A, B, C>(
            this Set<Either<L, A>> ma,
            Func<A, Set<Either<L, B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MSet<Either<L, C>>, Set<Either<L, C>>, MEither<L, C>, Either<L, C>, C>(ma, a =>
                    SeqTrans<MSet<Either<L, B>>, Set<Either<L, B>>, MEither<L, B>, Either<L, B>, B>
                        .Inst.Bind<MSet<Either<L, C>>, Set<Either<L, C>>, MEither<L, C>, Either<L, C>, C>(bind(a), b =>
                            default(MEither<L, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;Either&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<Either<L, A>> Where<L, A>(this Set<Either<L, A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Either<L, B>> Select<L, A, B>(this Set<Either<L, A>> ma, Func<A, B> f) =>
            SeqTrans<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MSet<Either<L, B>>, Set<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Set&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Either&lt;L, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Set&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Set<Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Set&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Either&lt;L, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Set&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this Set<Either<L, A>> ma) =>
            SeqTrans<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Either<L, B>> BindT<L, A, B>(this Set<Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            SeqTrans<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MSet<Either<L, B>>, Set<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Either<L, B>> BindT<L, A, B>(this Set<Either<L, A>> ma, Func<A, Set<Either<L, B>>> f) =>
            SeqTrans<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MSet<Either<L, B>>, Set<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Set&lt;Either&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Either&lt;L, Set&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, Set&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Either<L, Set<B>> Traverse<L, A, B>(this Set<Either<L, A>> ma, Func<A, B> f) =>
            Trans<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, Set<B>>, Either<L, Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Set&lt;Either&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Either&lt;L, Set&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Either<L, Set<A>> Sequence<L, A>(this Set<Either<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Either<L, B>> MapT<L, A, B>(this Set<Either<L, A>> ma, Func<A, B> f) =>
            SeqTrans<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MSet<Either<L, B>>, Set<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Set<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Set<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Set<Either<L, A>> ma, Func<A, bool> f) =>
            SeqTrans<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Set<Either<L, A>> ma, Func<A, bool> f) =>
            SeqTrans<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Set&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Set<Either<L, A>> ma, Action<A> f) =>
            SeqTrans<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;Either&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<Either<L, A>> FilterT<L, A>(this Set<Either<L, A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MSet<Either<L, A>>, Set<Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Either&lt;L, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Set<Either<L, A>> PlusT<NUM, L, A>(this Set<Either<L, A>> x, Set<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Either&lt;L, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Set<Either<L, A>> SubtractT<NUM, L, A>(this Set<Either<L, A>> x, Set<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Set<Either<L, A>> ProductT<NUM, L, A>(this Set<Either<L, A>> x, Set<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Set<Either<L, A>> DivideT<NUM, L, A>(this Set<Either<L, A>> x, Set<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Set<Either<L, A>> AppendT<SEMI, L, A>(this Set<Either<L, A>> x, Set<Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Set<Either<L, A>> x, Set<Either<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Set<Either<L, A>> x, Set<Either<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Set&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <returns>`Set&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Set<Either<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, Set<Either<L, A>> fa) =>
            ApplSet< Either<L, A>, Either<L, B>>.Inst.Apply(
                 MSet< Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => ApplEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Set&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Set&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <returns>`Set&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Set<Either<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Set<Either<L, A>> fa, Set<Either<L, B>> fb) =>
            ApplSet< Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MSet< Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            ApplEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Validation&lt;FAIL, Either&lt;L, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Validation<FAIL, Either<L, C>> SelectMany<FAIL, L, A, B, C>(
            this Validation<FAIL, Either<L, A>> ma,
            Func<A, Validation<FAIL, Either<L, B>>> bind,
            Func<A, B, C> project) =>
            Trans<MValidation<FAIL, Either<L, A>>, Validation<FAIL, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MValidation<FAIL, Either<L, C>>, Validation<FAIL, Either<L, C>>, MEither<L, C>, Either<L, C>, C>(ma, a =>
                    Trans<MValidation<FAIL, Either<L, B>>, Validation<FAIL, Either<L, B>>, MEither<L, B>, Either<L, B>, B>
                        .Inst.Bind<MValidation<FAIL, Either<L, C>>, Validation<FAIL, Either<L, C>>, MEither<L, C>, Either<L, C>, C>(bind(a), b =>
                            default(MEither<L, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, Either&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, Either<L, A>> Where<FAIL, L, A>(this Validation<FAIL, Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MValidation<FAIL, Either<L, A>>, Validation<FAIL, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MValidation<FAIL, Either<L, A>>, Validation<FAIL, Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, Either<L, B>> Select<FAIL, L, A, B>(this Validation<FAIL, Either<L, A>> ma, Func<A, B> f) =>
            Trans<MValidation<FAIL, Either<L, A>>, Validation<FAIL, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MValidation<FAIL, Either<L, B>>, Validation<FAIL, Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Validation&lt;FAIL, Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Either&lt;L, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Validation&lt;FAIL, Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, FAIL, L, A>(this Validation<FAIL, Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MValidation<FAIL, Either<L, A>>, Validation<FAIL, Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Validation&lt;FAIL, Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Either&lt;L, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Validation&lt;FAIL, Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<FAIL, L, A>(this Validation<FAIL, Either<L, A>> ma) =>
            Trans<MValidation<FAIL, Either<L, A>>, Validation<FAIL, Either<L, A>>, MEither<L, A>, Either<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Validation&lt;FAIL, Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, Either<L, B>> BindT<FAIL, L, A, B>(this Validation<FAIL, Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            Trans<MValidation<FAIL, Either<L, A>>, Validation<FAIL, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MValidation<FAIL, Either<L, B>>, Validation<FAIL, Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Validation&lt;FAIL, Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, Either<L, B>> BindT<FAIL, L, A, B>(this Validation<FAIL, Either<L, A>> ma, Func<A, Validation<FAIL, Either<L, B>>> f) =>
            Trans<MValidation<FAIL, Either<L, A>>, Validation<FAIL, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MValidation<FAIL, Either<L, B>>, Validation<FAIL, Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Validation&lt;FAIL, Either&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Either&lt;L, Validation&lt;FAIL, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, Validation&lt;FAIL, B&gt;&gt;`</returns>
        [Pure]
        public static Either<L, Validation<FAIL, B>> Traverse<FAIL, L, A, B>(this Validation<FAIL, Either<L, A>> ma, Func<A, B> f) =>
            Trans<MValidation<FAIL, Either<L, A>>, Validation<FAIL, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Traverse<MEither<L, Validation<FAIL, B>>, Either<L, Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Validation&lt;FAIL, Either&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Either&lt;L, Validation&lt;FAIL, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<FAIL, L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static Either<L, Validation<FAIL, A>> Sequence<FAIL, L, A>(this Validation<FAIL, Either<L, A>> ma) =>
            ma.Traverse<FAIL, L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, Either<L, B>> MapT<FAIL, L, A, B>(this Validation<FAIL, Either<L, A>> ma, Func<A, B> f) =>
            Trans<MValidation<FAIL, Either<L, A>>, Validation<FAIL, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Map<MValidation<FAIL, Either<L, B>>, Validation<FAIL, Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, FAIL, L, A>(this Validation<FAIL, Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MValidation<FAIL, Either<L, A>>, Validation<FAIL, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, FAIL, L, A>(this Validation<FAIL, Either<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MValidation<FAIL, Either<L, A>>, Validation<FAIL, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<FAIL, L, A>(this Validation<FAIL, Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MValidation<FAIL, Either<L, A>>, Validation<FAIL, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<FAIL, L, A>(this Validation<FAIL, Either<L, A>> ma, Func<A, bool> f) =>
            Trans<MValidation<FAIL, Either<L, A>>, Validation<FAIL, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Validation&lt;FAIL, Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<FAIL, L, A>(this Validation<FAIL, Either<L, A>> ma, Action<A> f) =>
            Trans<MValidation<FAIL, Either<L, A>>, Validation<FAIL, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, Either&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, Either<L, A>> FilterT<FAIL, L, A>(this Validation<FAIL, Either<L, A>> ma, Func<A, bool> pred) =>
            Trans<MValidation<FAIL, Either<L, A>>, Validation<FAIL, Either<L, A>>, MEither<L, A>, Either<L, A>, A>
                .Inst.Bind<MValidation<FAIL, Either<L, A>>, Validation<FAIL, Either<L, A>>, MEither<L, A>, Either<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEither<L, A>).Return(a)
                        : default(MEither<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Either&lt;L, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Validation<FAIL, Either<L, A>> PlusT<NUM, FAIL, L, A>(this Validation<FAIL, Either<L, A>> x, Validation<FAIL, Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Either&lt;L, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Validation<FAIL, Either<L, A>> SubtractT<NUM, FAIL, L, A>(this Validation<FAIL, Either<L, A>> x, Validation<FAIL, Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Either&lt;L, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Validation<FAIL, Either<L, A>> ProductT<NUM, FAIL, L, A>(this Validation<FAIL, Either<L, A>> x, Validation<FAIL, Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Either&lt;L, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Validation<FAIL, Either<L, A>> DivideT<NUM, FAIL, L, A>(this Validation<FAIL, Either<L, A>> x, Validation<FAIL, Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Either&lt;L, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Validation<FAIL, Either<L, A>> AppendT<SEMI, FAIL, L, A>(this Validation<FAIL, Either<L, A>> x, Validation<FAIL, Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, FAIL, L, A>(this Validation<FAIL, Either<L, A>> x, Validation<FAIL, Either<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Either&lt;L, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, FAIL, L, A>(this Validation<FAIL, Either<L, A>> x, Validation<FAIL, Either<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Validation&lt;FAIL, Either&lt;L, A&gt;&gt;`</param>
        /// <returns>`Validation&lt;FAIL, Either&lt;L, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Validation<FAIL, Either<L, B>> ApplyT<FAIL, L, A, B>(this Func<A, B> fab, Validation<FAIL, Either<L, A>> fa) =>
            ApplValidation<FAIL, Either<L, A>, Either<L, B>>.Inst.Apply(
                 MValidation<FAIL, Func<Either<L, A>, Either<L, B>>>.Inst.Return((Either<L, A> a) => ApplEither<L, A, B>.Inst.Apply(
                     MEither<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Validation&lt;FAIL, Either&lt;L, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Validation&lt;FAIL, Either&lt;L, A&gt;&gt;`</param>
        /// <returns>`Validation&lt;FAIL, Either&lt;L, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Validation<FAIL, Either<L, C>> ApplyT<FAIL, L, A, B, C>(this Func<A, B, C> fabc, Validation<FAIL, Either<L, A>> fa, Validation<FAIL, Either<L, B>> fb) =>
            ApplValidation<FAIL, Either<L, A>, Either<L, B>, Either<L, C>>.Inst.Apply(
                MValidation<FAIL, Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>.Inst.Return(
                    (Either<L, A> a) =>
                        (Either<L, B> b) =>
                            ApplEither<L, A, B, C>.Inst.Apply(
                                MEither<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    /// <summary>
    /// Monad transformer for EitherUnsafe, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class EitherUnsafeT_Extensions
    {
        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Arr&lt;EitherUnsafe&lt;L, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, C>> SelectMany<L, A, B, C>(
            this Arr<EitherUnsafe<L, A>> ma,
            Func<A, Arr<EitherUnsafe<L, B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MArr<EitherUnsafe<L, C>>, Arr<EitherUnsafe<L, C>>, MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(ma, a =>
                    SeqTrans<MArr<EitherUnsafe<L, B>>, Arr<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>
                        .Inst.Bind<MArr<EitherUnsafe<L, C>>, Arr<EitherUnsafe<L, C>>, MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(bind(a), b =>
                            default(MEitherUnsafe<L, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;EitherUnsafe&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, A>> Where<L, A>(this Arr<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            SeqTrans<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, B>> Select<L, A, B>(this Arr<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            SeqTrans<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MArr<EitherUnsafe<L, B>>, Arr<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Arr&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Arr&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Arr<EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Arr&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Arr&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this Arr<EitherUnsafe<L, A>> ma) =>
            SeqTrans<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, B>> BindT<L, A, B>(this Arr<EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            SeqTrans<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MArr<EitherUnsafe<L, B>>, Arr<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, B>> BindT<L, A, B>(this Arr<EitherUnsafe<L, A>> ma, Func<A, Arr<EitherUnsafe<L, B>>> f) =>
            SeqTrans<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MArr<EitherUnsafe<L, B>>, Arr<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Arr&lt;EitherUnsafe&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe&lt;L, Arr&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Arr&lt;B&gt;&gt;`</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<B>> Traverse<L, A, B>(this Arr<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, Arr<B>>, EitherUnsafe<L, Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Arr&lt;EitherUnsafe&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe&lt;L, Arr&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static EitherUnsafe<L, Arr<A>> Sequence<L, A>(this Arr<EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, B>> MapT<L, A, B>(this Arr<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            SeqTrans<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MArr<EitherUnsafe<L, B>>, Arr<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Arr<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Arr<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Arr<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            SeqTrans<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Arr<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            SeqTrans<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Arr&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Arr<EitherUnsafe<L, A>> ma, Action<A> f) =>
            SeqTrans<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;EitherUnsafe&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, A>> FilterT<L, A>(this Arr<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            SeqTrans<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MArr<EitherUnsafe<L, A>>, Arr<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, A>> PlusT<NUM, L, A>(this Arr<EitherUnsafe<L, A>> x, Arr<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, A>> SubtractT<NUM, L, A>(this Arr<EitherUnsafe<L, A>> x, Arr<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, A>> ProductT<NUM, L, A>(this Arr<EitherUnsafe<L, A>> x, Arr<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, A>> DivideT<NUM, L, A>(this Arr<EitherUnsafe<L, A>> x, Arr<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, A>> AppendT<SEMI, L, A>(this Arr<EitherUnsafe<L, A>> x, Arr<EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Arr<EitherUnsafe<L, A>> x, Arr<EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Arr<EitherUnsafe<L, A>> x, Arr<EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Arr&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <returns>`Arr&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, Arr<EitherUnsafe<L, A>> fa) =>
            ApplArr< EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MArr< Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => ApplEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Arr&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Arr&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <returns>`Arr&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Arr<EitherUnsafe<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Arr<EitherUnsafe<L, A>> fa, Arr<EitherUnsafe<L, B>> fb) =>
            ApplArr< EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MArr< Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            ApplEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`HashSet&lt;EitherUnsafe&lt;L, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, C>> SelectMany<L, A, B, C>(
            this HashSet<EitherUnsafe<L, A>> ma,
            Func<A, HashSet<EitherUnsafe<L, B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MHashSet<EitherUnsafe<L, C>>, HashSet<EitherUnsafe<L, C>>, MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(ma, a =>
                    SeqTrans<MHashSet<EitherUnsafe<L, B>>, HashSet<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>
                        .Inst.Bind<MHashSet<EitherUnsafe<L, C>>, HashSet<EitherUnsafe<L, C>>, MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(bind(a), b =>
                            default(MEitherUnsafe<L, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;EitherUnsafe&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, A>> Where<L, A>(this HashSet<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            SeqTrans<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, B>> Select<L, A, B>(this HashSet<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            SeqTrans<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MHashSet<EitherUnsafe<L, B>>, HashSet<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `HashSet&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `HashSet&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this HashSet<EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `HashSet&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `HashSet&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this HashSet<EitherUnsafe<L, A>> ma) =>
            SeqTrans<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, B>> BindT<L, A, B>(this HashSet<EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            SeqTrans<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MHashSet<EitherUnsafe<L, B>>, HashSet<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, B>> BindT<L, A, B>(this HashSet<EitherUnsafe<L, A>> ma, Func<A, HashSet<EitherUnsafe<L, B>>> f) =>
            SeqTrans<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MHashSet<EitherUnsafe<L, B>>, HashSet<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `HashSet&lt;EitherUnsafe&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe&lt;L, HashSet&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, HashSet&lt;B&gt;&gt;`</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<B>> Traverse<L, A, B>(this HashSet<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, HashSet<B>>, EitherUnsafe<L, HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `HashSet&lt;EitherUnsafe&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe&lt;L, HashSet&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static EitherUnsafe<L, HashSet<A>> Sequence<L, A>(this HashSet<EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, B>> MapT<L, A, B>(this HashSet<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            SeqTrans<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MHashSet<EitherUnsafe<L, B>>, HashSet<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this HashSet<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this HashSet<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this HashSet<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            SeqTrans<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this HashSet<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            SeqTrans<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `HashSet&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this HashSet<EitherUnsafe<L, A>> ma, Action<A> f) =>
            SeqTrans<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;EitherUnsafe&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, A>> FilterT<L, A>(this HashSet<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            SeqTrans<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MHashSet<EitherUnsafe<L, A>>, HashSet<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, A>> PlusT<NUM, L, A>(this HashSet<EitherUnsafe<L, A>> x, HashSet<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, A>> SubtractT<NUM, L, A>(this HashSet<EitherUnsafe<L, A>> x, HashSet<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, A>> ProductT<NUM, L, A>(this HashSet<EitherUnsafe<L, A>> x, HashSet<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, A>> DivideT<NUM, L, A>(this HashSet<EitherUnsafe<L, A>> x, HashSet<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, A>> AppendT<SEMI, L, A>(this HashSet<EitherUnsafe<L, A>> x, HashSet<EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this HashSet<EitherUnsafe<L, A>> x, HashSet<EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this HashSet<EitherUnsafe<L, A>> x, HashSet<EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `HashSet&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <returns>`HashSet&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, HashSet<EitherUnsafe<L, A>> fa) =>
            ApplHashSet< EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MHashSet< Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => ApplEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `HashSet&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `HashSet&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <returns>`HashSet&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static HashSet<EitherUnsafe<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, HashSet<EitherUnsafe<L, A>> fa, HashSet<EitherUnsafe<L, B>> fb) =>
            ApplHashSet< EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MHashSet< Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            ApplEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Lst&lt;EitherUnsafe&lt;L, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, C>> SelectMany<L, A, B, C>(
            this Lst<EitherUnsafe<L, A>> ma,
            Func<A, Lst<EitherUnsafe<L, B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MLst<EitherUnsafe<L, C>>, Lst<EitherUnsafe<L, C>>, MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(ma, a =>
                    SeqTrans<MLst<EitherUnsafe<L, B>>, Lst<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>
                        .Inst.Bind<MLst<EitherUnsafe<L, C>>, Lst<EitherUnsafe<L, C>>, MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(bind(a), b =>
                            default(MEitherUnsafe<L, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;EitherUnsafe&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, A>> Where<L, A>(this Lst<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            SeqTrans<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, B>> Select<L, A, B>(this Lst<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            SeqTrans<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MLst<EitherUnsafe<L, B>>, Lst<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Lst&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Lst&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Lst<EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Lst&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Lst&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this Lst<EitherUnsafe<L, A>> ma) =>
            SeqTrans<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, B>> BindT<L, A, B>(this Lst<EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            SeqTrans<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MLst<EitherUnsafe<L, B>>, Lst<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, B>> BindT<L, A, B>(this Lst<EitherUnsafe<L, A>> ma, Func<A, Lst<EitherUnsafe<L, B>>> f) =>
            SeqTrans<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MLst<EitherUnsafe<L, B>>, Lst<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Lst&lt;EitherUnsafe&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe&lt;L, Lst&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Lst&lt;B&gt;&gt;`</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<B>> Traverse<L, A, B>(this Lst<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, Lst<B>>, EitherUnsafe<L, Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Lst&lt;EitherUnsafe&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe&lt;L, Lst&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static EitherUnsafe<L, Lst<A>> Sequence<L, A>(this Lst<EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, B>> MapT<L, A, B>(this Lst<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            SeqTrans<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MLst<EitherUnsafe<L, B>>, Lst<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Lst<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Lst<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Lst<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            SeqTrans<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Lst<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            SeqTrans<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Lst&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Lst<EitherUnsafe<L, A>> ma, Action<A> f) =>
            SeqTrans<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;EitherUnsafe&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, A>> FilterT<L, A>(this Lst<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            SeqTrans<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MLst<EitherUnsafe<L, A>>, Lst<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, A>> PlusT<NUM, L, A>(this Lst<EitherUnsafe<L, A>> x, Lst<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, A>> SubtractT<NUM, L, A>(this Lst<EitherUnsafe<L, A>> x, Lst<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, A>> ProductT<NUM, L, A>(this Lst<EitherUnsafe<L, A>> x, Lst<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, A>> DivideT<NUM, L, A>(this Lst<EitherUnsafe<L, A>> x, Lst<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, A>> AppendT<SEMI, L, A>(this Lst<EitherUnsafe<L, A>> x, Lst<EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Lst<EitherUnsafe<L, A>> x, Lst<EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Lst<EitherUnsafe<L, A>> x, Lst<EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Lst&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <returns>`Lst&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, Lst<EitherUnsafe<L, A>> fa) =>
            ApplLst< EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MLst< Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => ApplEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Lst&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Lst&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <returns>`Lst&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Lst<EitherUnsafe<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Lst<EitherUnsafe<L, A>> fa, Lst<EitherUnsafe<L, B>> fb) =>
            ApplLst< EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MLst< Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            ApplEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Option&lt;EitherUnsafe&lt;L, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Option<EitherUnsafe<L, C>> SelectMany<L, A, B, C>(
            this Option<EitherUnsafe<L, A>> ma,
            Func<A, Option<EitherUnsafe<L, B>>> bind,
            Func<A, B, C> project) =>
            Trans<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MOption<EitherUnsafe<L, C>>, Option<EitherUnsafe<L, C>>, MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(ma, a =>
                    Trans<MOption<EitherUnsafe<L, B>>, Option<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>
                        .Inst.Bind<MOption<EitherUnsafe<L, C>>, Option<EitherUnsafe<L, C>>, MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(bind(a), b =>
                            default(MEitherUnsafe<L, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;EitherUnsafe&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<EitherUnsafe<L, A>> Where<L, A>(this Option<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<EitherUnsafe<L, B>> Select<L, A, B>(this Option<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MOption<EitherUnsafe<L, B>>, Option<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Option&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Option&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Option<EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Option&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Option&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this Option<EitherUnsafe<L, A>> ma) =>
            Trans<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<EitherUnsafe<L, B>> BindT<L, A, B>(this Option<EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            Trans<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MOption<EitherUnsafe<L, B>>, Option<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<EitherUnsafe<L, B>> BindT<L, A, B>(this Option<EitherUnsafe<L, A>> ma, Func<A, Option<EitherUnsafe<L, B>>> f) =>
            Trans<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MOption<EitherUnsafe<L, B>>, Option<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Option&lt;EitherUnsafe&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe&lt;L, Option&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Option&lt;B&gt;&gt;`</returns>
        [Pure]
        public static EitherUnsafe<L, Option<B>> Traverse<L, A, B>(this Option<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, Option<B>>, EitherUnsafe<L, Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Option&lt;EitherUnsafe&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe&lt;L, Option&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static EitherUnsafe<L, Option<A>> Sequence<L, A>(this Option<EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<EitherUnsafe<L, B>> MapT<L, A, B>(this Option<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MOption<EitherUnsafe<L, B>>, Option<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Option<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Option<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Option<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Option<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Option&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Option<EitherUnsafe<L, A>> ma, Action<A> f) =>
            Trans<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;EitherUnsafe&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<EitherUnsafe<L, A>> FilterT<L, A>(this Option<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MOption<EitherUnsafe<L, A>>, Option<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Option<EitherUnsafe<L, A>> PlusT<NUM, L, A>(this Option<EitherUnsafe<L, A>> x, Option<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Option<EitherUnsafe<L, A>> SubtractT<NUM, L, A>(this Option<EitherUnsafe<L, A>> x, Option<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Option<EitherUnsafe<L, A>> ProductT<NUM, L, A>(this Option<EitherUnsafe<L, A>> x, Option<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Option<EitherUnsafe<L, A>> DivideT<NUM, L, A>(this Option<EitherUnsafe<L, A>> x, Option<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Option<EitherUnsafe<L, A>> AppendT<SEMI, L, A>(this Option<EitherUnsafe<L, A>> x, Option<EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Option<EitherUnsafe<L, A>> x, Option<EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Option<EitherUnsafe<L, A>> x, Option<EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Option&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <returns>`Option&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Option<EitherUnsafe<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, Option<EitherUnsafe<L, A>> fa) =>
            ApplOption< EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MOption< Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => ApplEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Option&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Option&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <returns>`Option&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Option<EitherUnsafe<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Option<EitherUnsafe<L, A>> fa, Option<EitherUnsafe<L, B>> fb) =>
            ApplOption< EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MOption< Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            ApplEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionUnsafe&lt;EitherUnsafe&lt;L, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, C>> SelectMany<L, A, B, C>(
            this OptionUnsafe<EitherUnsafe<L, A>> ma,
            Func<A, OptionUnsafe<EitherUnsafe<L, B>>> bind,
            Func<A, B, C> project) =>
            Trans<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MOptionUnsafe<EitherUnsafe<L, C>>, OptionUnsafe<EitherUnsafe<L, C>>, MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(ma, a =>
                    Trans<MOptionUnsafe<EitherUnsafe<L, B>>, OptionUnsafe<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>
                        .Inst.Bind<MOptionUnsafe<EitherUnsafe<L, C>>, OptionUnsafe<EitherUnsafe<L, C>>, MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(bind(a), b =>
                            default(MEitherUnsafe<L, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;EitherUnsafe&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, A>> Where<L, A>(this OptionUnsafe<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, B>> Select<L, A, B>(this OptionUnsafe<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MOptionUnsafe<EitherUnsafe<L, B>>, OptionUnsafe<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionUnsafe&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionUnsafe&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this OptionUnsafe<EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionUnsafe&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionUnsafe&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this OptionUnsafe<EitherUnsafe<L, A>> ma) =>
            Trans<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, B>> BindT<L, A, B>(this OptionUnsafe<EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            Trans<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MOptionUnsafe<EitherUnsafe<L, B>>, OptionUnsafe<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, B>> BindT<L, A, B>(this OptionUnsafe<EitherUnsafe<L, A>> ma, Func<A, OptionUnsafe<EitherUnsafe<L, B>>> f) =>
            Trans<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MOptionUnsafe<EitherUnsafe<L, B>>, OptionUnsafe<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionUnsafe&lt;EitherUnsafe&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe&lt;L, OptionUnsafe&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, OptionUnsafe&lt;B&gt;&gt;`</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<B>> Traverse<L, A, B>(this OptionUnsafe<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, OptionUnsafe<B>>, EitherUnsafe<L, OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionUnsafe&lt;EitherUnsafe&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe&lt;L, OptionUnsafe&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static EitherUnsafe<L, OptionUnsafe<A>> Sequence<L, A>(this OptionUnsafe<EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, B>> MapT<L, A, B>(this OptionUnsafe<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MOptionUnsafe<EitherUnsafe<L, B>>, OptionUnsafe<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this OptionUnsafe<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this OptionUnsafe<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this OptionUnsafe<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this OptionUnsafe<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionUnsafe&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this OptionUnsafe<EitherUnsafe<L, A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;EitherUnsafe&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, A>> FilterT<L, A>(this OptionUnsafe<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MOptionUnsafe<EitherUnsafe<L, A>>, OptionUnsafe<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, A>> PlusT<NUM, L, A>(this OptionUnsafe<EitherUnsafe<L, A>> x, OptionUnsafe<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, A>> SubtractT<NUM, L, A>(this OptionUnsafe<EitherUnsafe<L, A>> x, OptionUnsafe<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, A>> ProductT<NUM, L, A>(this OptionUnsafe<EitherUnsafe<L, A>> x, OptionUnsafe<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, A>> DivideT<NUM, L, A>(this OptionUnsafe<EitherUnsafe<L, A>> x, OptionUnsafe<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, A>> AppendT<SEMI, L, A>(this OptionUnsafe<EitherUnsafe<L, A>> x, OptionUnsafe<EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this OptionUnsafe<EitherUnsafe<L, A>> x, OptionUnsafe<EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this OptionUnsafe<EitherUnsafe<L, A>> x, OptionUnsafe<EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <returns>`OptionUnsafe&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, OptionUnsafe<EitherUnsafe<L, A>> fa) =>
            ApplOptionUnsafe< EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MOptionUnsafe< Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => ApplEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `OptionUnsafe&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <returns>`OptionUnsafe&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionUnsafe<EitherUnsafe<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, OptionUnsafe<EitherUnsafe<L, A>> fa, OptionUnsafe<EitherUnsafe<L, B>> fb) =>
            ApplOptionUnsafe< EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MOptionUnsafe< Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            ApplEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Either&lt;L, EitherUnsafe&lt;L, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, C>> SelectMany<L, A, B, C>(
            this Either<L, EitherUnsafe<L, A>> ma,
            Func<A, Either<L, EitherUnsafe<L, B>>> bind,
            Func<A, B, C> project) =>
            Trans<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MEither<L, EitherUnsafe<L, C>>, Either<L, EitherUnsafe<L, C>>, MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(ma, a =>
                    Trans<MEither<L, EitherUnsafe<L, B>>, Either<L, EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>
                        .Inst.Bind<MEither<L, EitherUnsafe<L, C>>, Either<L, EitherUnsafe<L, C>>, MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(bind(a), b =>
                            default(MEitherUnsafe<L, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, A>> Where<L, A>(this Either<L, EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, B>> Select<L, A, B>(this Either<L, EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MEither<L, EitherUnsafe<L, B>>, Either<L, EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Either&lt;L, EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Either&lt;L, EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Either<L, EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Either&lt;L, EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Either&lt;L, EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this Either<L, EitherUnsafe<L, A>> ma) =>
            Trans<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either&lt;L, EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, B>> BindT<L, A, B>(this Either<L, EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            Trans<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MEither<L, EitherUnsafe<L, B>>, Either<L, EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either&lt;L, EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, B>> BindT<L, A, B>(this Either<L, EitherUnsafe<L, A>> ma, Func<A, Either<L, EitherUnsafe<L, B>>> f) =>
            Trans<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MEither<L, EitherUnsafe<L, B>>, Either<L, EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Either&lt;L, EitherUnsafe&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe&lt;L, Either&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Either&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, B>> Traverse<L, A, B>(this Either<L, EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, Either<L, B>>, EitherUnsafe<L, Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Either&lt;L, EitherUnsafe&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe&lt;L, Either&lt;L, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static EitherUnsafe<L, Either<L, A>> Sequence<L, A>(this Either<L, EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, B>> MapT<L, A, B>(this Either<L, EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MEither<L, EitherUnsafe<L, B>>, Either<L, EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Either<L, EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Either<L, EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Either<L, EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Either<L, EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Either&lt;L, EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Either<L, EitherUnsafe<L, A>> ma, Action<A> f) =>
            Trans<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, A>> FilterT<L, A>(this Either<L, EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MEither<L, EitherUnsafe<L, A>>, Either<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, A>> PlusT<NUM, L, A>(this Either<L, EitherUnsafe<L, A>> x, Either<L, EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, A>> SubtractT<NUM, L, A>(this Either<L, EitherUnsafe<L, A>> x, Either<L, EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, A>> ProductT<NUM, L, A>(this Either<L, EitherUnsafe<L, A>> x, Either<L, EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, A>> DivideT<NUM, L, A>(this Either<L, EitherUnsafe<L, A>> x, Either<L, EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, A>> AppendT<SEMI, L, A>(this Either<L, EitherUnsafe<L, A>> x, Either<L, EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Either<L, EitherUnsafe<L, A>> x, Either<L, EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Either<L, EitherUnsafe<L, A>> x, Either<L, EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Either&lt;L, EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <returns>`Either&lt;L, EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, Either<L, EitherUnsafe<L, A>> fa) =>
            ApplEither<L, EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MEither<L, Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => ApplEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Either&lt;L, EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Either&lt;L, EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <returns>`Either&lt;L, EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Either<L, EitherUnsafe<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Either<L, EitherUnsafe<L, A>> fa, Either<L, EitherUnsafe<L, B>> fb) =>
            ApplEither<L, EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MEither<L, Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            ApplEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`EitherUnsafe&lt;L, EitherUnsafe&lt;L, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, EitherUnsafe<L, A>> ma,
            Func<A, EitherUnsafe<L, EitherUnsafe<L, B>>> bind,
            Func<A, B, C> project) =>
            Trans<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MEitherUnsafe<L, EitherUnsafe<L, C>>, EitherUnsafe<L, EitherUnsafe<L, C>>, MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(ma, a =>
                    Trans<MEitherUnsafe<L, EitherUnsafe<L, B>>, EitherUnsafe<L, EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>
                        .Inst.Bind<MEitherUnsafe<L, EitherUnsafe<L, C>>, EitherUnsafe<L, EitherUnsafe<L, C>>, MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(bind(a), b =>
                            default(MEitherUnsafe<L, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, A>> Where<L, A>(this EitherUnsafe<L, EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, B>> Select<L, A, B>(this EitherUnsafe<L, EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MEitherUnsafe<L, EitherUnsafe<L, B>>, EitherUnsafe<L, EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherUnsafe&lt;L, EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherUnsafe&lt;L, EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this EitherUnsafe<L, EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherUnsafe&lt;L, EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherUnsafe&lt;L, EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this EitherUnsafe<L, EitherUnsafe<L, A>> ma) =>
            Trans<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, B>> BindT<L, A, B>(this EitherUnsafe<L, EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            Trans<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MEitherUnsafe<L, EitherUnsafe<L, B>>, EitherUnsafe<L, EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, B>> BindT<L, A, B>(this EitherUnsafe<L, EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, EitherUnsafe<L, B>>> f) =>
            Trans<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MEitherUnsafe<L, EitherUnsafe<L, B>>, EitherUnsafe<L, EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `EitherUnsafe&lt;L, EitherUnsafe&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe&lt;L, EitherUnsafe&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, EitherUnsafe&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, B>> Traverse<L, A, B>(this EitherUnsafe<L, EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, EitherUnsafe<L, B>>, EitherUnsafe<L, EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `EitherUnsafe&lt;L, EitherUnsafe&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe&lt;L, EitherUnsafe&lt;L, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, A>> Sequence<L, A>(this EitherUnsafe<L, EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, B>> MapT<L, A, B>(this EitherUnsafe<L, EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MEitherUnsafe<L, EitherUnsafe<L, B>>, EitherUnsafe<L, EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this EitherUnsafe<L, EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this EitherUnsafe<L, EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this EitherUnsafe<L, EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this EitherUnsafe<L, EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherUnsafe&lt;L, EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this EitherUnsafe<L, EitherUnsafe<L, A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, A>> FilterT<L, A>(this EitherUnsafe<L, EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MEitherUnsafe<L, EitherUnsafe<L, A>>, EitherUnsafe<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, A>> PlusT<NUM, L, A>(this EitherUnsafe<L, EitherUnsafe<L, A>> x, EitherUnsafe<L, EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, A>> SubtractT<NUM, L, A>(this EitherUnsafe<L, EitherUnsafe<L, A>> x, EitherUnsafe<L, EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, A>> ProductT<NUM, L, A>(this EitherUnsafe<L, EitherUnsafe<L, A>> x, EitherUnsafe<L, EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, A>> DivideT<NUM, L, A>(this EitherUnsafe<L, EitherUnsafe<L, A>> x, EitherUnsafe<L, EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, A>> AppendT<SEMI, L, A>(this EitherUnsafe<L, EitherUnsafe<L, A>> x, EitherUnsafe<L, EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this EitherUnsafe<L, EitherUnsafe<L, A>> x, EitherUnsafe<L, EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this EitherUnsafe<L, EitherUnsafe<L, A>> x, EitherUnsafe<L, EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe&lt;L, EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <returns>`EitherUnsafe&lt;L, EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherUnsafe<L, EitherUnsafe<L, A>> fa) =>
            ApplEitherUnsafe<L, EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => ApplEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe&lt;L, EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `EitherUnsafe&lt;L, EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <returns>`EitherUnsafe&lt;L, EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherUnsafe<L, EitherUnsafe<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherUnsafe<L, EitherUnsafe<L, A>> fa, EitherUnsafe<L, EitherUnsafe<L, B>> fb) =>
            ApplEitherUnsafe<L, EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MEitherUnsafe<L, Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            ApplEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Try&lt;EitherUnsafe&lt;L, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Try<EitherUnsafe<L, C>> SelectMany<L, A, B, C>(
            this Try<EitherUnsafe<L, A>> ma,
            Func<A, Try<EitherUnsafe<L, B>>> bind,
            Func<A, B, C> project) =>
            Trans<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MTry<EitherUnsafe<L, C>>, Try<EitherUnsafe<L, C>>, MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(ma, a =>
                    Trans<MTry<EitherUnsafe<L, B>>, Try<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>
                        .Inst.Bind<MTry<EitherUnsafe<L, C>>, Try<EitherUnsafe<L, C>>, MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(bind(a), b =>
                            default(MEitherUnsafe<L, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;EitherUnsafe&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<EitherUnsafe<L, A>> Where<L, A>(this Try<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<EitherUnsafe<L, B>> Select<L, A, B>(this Try<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MTry<EitherUnsafe<L, B>>, Try<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Try&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Try&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Try<EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Try&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Try&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this Try<EitherUnsafe<L, A>> ma) =>
            Trans<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<EitherUnsafe<L, B>> BindT<L, A, B>(this Try<EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            Trans<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MTry<EitherUnsafe<L, B>>, Try<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<EitherUnsafe<L, B>> BindT<L, A, B>(this Try<EitherUnsafe<L, A>> ma, Func<A, Try<EitherUnsafe<L, B>>> f) =>
            Trans<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MTry<EitherUnsafe<L, B>>, Try<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Try&lt;EitherUnsafe&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe&lt;L, Try&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Try&lt;B&gt;&gt;`</returns>
        [Pure]
        public static EitherUnsafe<L, Try<B>> Traverse<L, A, B>(this Try<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, Try<B>>, EitherUnsafe<L, Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Try&lt;EitherUnsafe&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe&lt;L, Try&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static EitherUnsafe<L, Try<A>> Sequence<L, A>(this Try<EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<EitherUnsafe<L, B>> MapT<L, A, B>(this Try<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MTry<EitherUnsafe<L, B>>, Try<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Try<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Try<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Try<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Try<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Try&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Try<EitherUnsafe<L, A>> ma, Action<A> f) =>
            Trans<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;EitherUnsafe&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<EitherUnsafe<L, A>> FilterT<L, A>(this Try<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MTry<EitherUnsafe<L, A>>, Try<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Try<EitherUnsafe<L, A>> PlusT<NUM, L, A>(this Try<EitherUnsafe<L, A>> x, Try<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Try<EitherUnsafe<L, A>> SubtractT<NUM, L, A>(this Try<EitherUnsafe<L, A>> x, Try<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Try<EitherUnsafe<L, A>> ProductT<NUM, L, A>(this Try<EitherUnsafe<L, A>> x, Try<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Try<EitherUnsafe<L, A>> DivideT<NUM, L, A>(this Try<EitherUnsafe<L, A>> x, Try<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Try<EitherUnsafe<L, A>> AppendT<SEMI, L, A>(this Try<EitherUnsafe<L, A>> x, Try<EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Try<EitherUnsafe<L, A>> x, Try<EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Try<EitherUnsafe<L, A>> x, Try<EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Try&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <returns>`Try&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Try<EitherUnsafe<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, Try<EitherUnsafe<L, A>> fa) =>
            ApplTry< EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MTry< Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => ApplEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Try&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Try&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <returns>`Try&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Try<EitherUnsafe<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Try<EitherUnsafe<L, A>> fa, Try<EitherUnsafe<L, B>> fb) =>
            ApplTry< EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MTry< Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            ApplEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOption&lt;EitherUnsafe&lt;L, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, C>> SelectMany<L, A, B, C>(
            this TryOption<EitherUnsafe<L, A>> ma,
            Func<A, TryOption<EitherUnsafe<L, B>>> bind,
            Func<A, B, C> project) =>
            Trans<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MTryOption<EitherUnsafe<L, C>>, TryOption<EitherUnsafe<L, C>>, MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(ma, a =>
                    Trans<MTryOption<EitherUnsafe<L, B>>, TryOption<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>
                        .Inst.Bind<MTryOption<EitherUnsafe<L, C>>, TryOption<EitherUnsafe<L, C>>, MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(bind(a), b =>
                            default(MEitherUnsafe<L, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;EitherUnsafe&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, A>> Where<L, A>(this TryOption<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, B>> Select<L, A, B>(this TryOption<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MTryOption<EitherUnsafe<L, B>>, TryOption<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOption&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOption&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this TryOption<EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOption&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOption&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this TryOption<EitherUnsafe<L, A>> ma) =>
            Trans<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, B>> BindT<L, A, B>(this TryOption<EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            Trans<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MTryOption<EitherUnsafe<L, B>>, TryOption<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, B>> BindT<L, A, B>(this TryOption<EitherUnsafe<L, A>> ma, Func<A, TryOption<EitherUnsafe<L, B>>> f) =>
            Trans<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MTryOption<EitherUnsafe<L, B>>, TryOption<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOption&lt;EitherUnsafe&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe&lt;L, TryOption&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, TryOption&lt;B&gt;&gt;`</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<B>> Traverse<L, A, B>(this TryOption<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, TryOption<B>>, EitherUnsafe<L, TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOption&lt;EitherUnsafe&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe&lt;L, TryOption&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<A>> Sequence<L, A>(this TryOption<EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, B>> MapT<L, A, B>(this TryOption<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MTryOption<EitherUnsafe<L, B>>, TryOption<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this TryOption<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this TryOption<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this TryOption<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this TryOption<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOption&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this TryOption<EitherUnsafe<L, A>> ma, Action<A> f) =>
            Trans<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;EitherUnsafe&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, A>> FilterT<L, A>(this TryOption<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MTryOption<EitherUnsafe<L, A>>, TryOption<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, A>> PlusT<NUM, L, A>(this TryOption<EitherUnsafe<L, A>> x, TryOption<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, A>> SubtractT<NUM, L, A>(this TryOption<EitherUnsafe<L, A>> x, TryOption<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, A>> ProductT<NUM, L, A>(this TryOption<EitherUnsafe<L, A>> x, TryOption<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, A>> DivideT<NUM, L, A>(this TryOption<EitherUnsafe<L, A>> x, TryOption<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, A>> AppendT<SEMI, L, A>(this TryOption<EitherUnsafe<L, A>> x, TryOption<EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this TryOption<EitherUnsafe<L, A>> x, TryOption<EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this TryOption<EitherUnsafe<L, A>> x, TryOption<EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOption&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <returns>`TryOption&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, TryOption<EitherUnsafe<L, A>> fa) =>
            ApplTryOption< EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MTryOption< Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => ApplEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOption&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryOption&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <returns>`TryOption&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, TryOption<EitherUnsafe<L, A>> fa, TryOption<EitherUnsafe<L, B>> fb) =>
            ApplTryOption< EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MTryOption< Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            ApplEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`IEnumerable&lt;EitherUnsafe&lt;L, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, C>> SelectMany<L, A, B, C>(
            this IEnumerable<EitherUnsafe<L, A>> ma,
            Func<A, IEnumerable<EitherUnsafe<L, B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MEnumerable<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MEnumerable<EitherUnsafe<L, C>>, IEnumerable<EitherUnsafe<L, C>>, MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(ma, a =>
                    SeqTrans<MEnumerable<EitherUnsafe<L, B>>, IEnumerable<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>
                        .Inst.Bind<MEnumerable<EitherUnsafe<L, C>>, IEnumerable<EitherUnsafe<L, C>>, MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(bind(a), b =>
                            default(MEitherUnsafe<L, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;EitherUnsafe&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, A>> Where<L, A>(this IEnumerable<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            SeqTrans<MEnumerable<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MEnumerable<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, B>> Select<L, A, B>(this IEnumerable<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            SeqTrans<MEnumerable<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MEnumerable<EitherUnsafe<L, B>>, IEnumerable<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `IEnumerable&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `IEnumerable&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this IEnumerable<EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MEnumerable<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `IEnumerable&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `IEnumerable&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this IEnumerable<EitherUnsafe<L, A>> ma) =>
            SeqTrans<MEnumerable<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, B>> BindT<L, A, B>(this IEnumerable<EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            SeqTrans<MEnumerable<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MEnumerable<EitherUnsafe<L, B>>, IEnumerable<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, B>> BindT<L, A, B>(this IEnumerable<EitherUnsafe<L, A>> ma, Func<A, IEnumerable<EitherUnsafe<L, B>>> f) =>
            SeqTrans<MEnumerable<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MEnumerable<EitherUnsafe<L, B>>, IEnumerable<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `IEnumerable&lt;EitherUnsafe&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe&lt;L, IEnumerable&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, IEnumerable&lt;B&gt;&gt;`</returns>
        [Pure]
        public static EitherUnsafe<L, IEnumerable<B>> Traverse<L, A, B>(this IEnumerable<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MEnumerable<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, IEnumerable<B>>, EitherUnsafe<L, IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `IEnumerable&lt;EitherUnsafe&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe&lt;L, IEnumerable&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static EitherUnsafe<L, IEnumerable<A>> Sequence<L, A>(this IEnumerable<EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, B>> MapT<L, A, B>(this IEnumerable<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            SeqTrans<MEnumerable<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MEnumerable<EitherUnsafe<L, B>>, IEnumerable<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this IEnumerable<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MEnumerable<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this IEnumerable<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MEnumerable<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this IEnumerable<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            SeqTrans<MEnumerable<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this IEnumerable<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            SeqTrans<MEnumerable<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `IEnumerable&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this IEnumerable<EitherUnsafe<L, A>> ma, Action<A> f) =>
            SeqTrans<MEnumerable<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;EitherUnsafe&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, A>> FilterT<L, A>(this IEnumerable<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            SeqTrans<MEnumerable<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MEnumerable<EitherUnsafe<L, A>>, IEnumerable<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, A>> PlusT<NUM, L, A>(this IEnumerable<EitherUnsafe<L, A>> x, IEnumerable<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, A>> SubtractT<NUM, L, A>(this IEnumerable<EitherUnsafe<L, A>> x, IEnumerable<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, A>> ProductT<NUM, L, A>(this IEnumerable<EitherUnsafe<L, A>> x, IEnumerable<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, A>> DivideT<NUM, L, A>(this IEnumerable<EitherUnsafe<L, A>> x, IEnumerable<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, A>> AppendT<SEMI, L, A>(this IEnumerable<EitherUnsafe<L, A>> x, IEnumerable<EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this IEnumerable<EitherUnsafe<L, A>> x, IEnumerable<EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this IEnumerable<EitherUnsafe<L, A>> x, IEnumerable<EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `IEnumerable&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <returns>`IEnumerable&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, IEnumerable<EitherUnsafe<L, A>> fa) =>
            ApplEnumerable< EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MEnumerable< Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => ApplEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `IEnumerable&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `IEnumerable&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <returns>`IEnumerable&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, IEnumerable<EitherUnsafe<L, A>> fa, IEnumerable<EitherUnsafe<L, B>> fb) =>
            ApplEnumerable< EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MEnumerable< Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            ApplEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Seq&lt;EitherUnsafe&lt;L, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Seq<EitherUnsafe<L, C>> SelectMany<L, A, B, C>(
            this Seq<EitherUnsafe<L, A>> ma,
            Func<A, Seq<EitherUnsafe<L, B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MSeq<EitherUnsafe<L, A>>, Seq<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MSeq<EitherUnsafe<L, C>>, Seq<EitherUnsafe<L, C>>, MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(ma, a =>
                    SeqTrans<MSeq<EitherUnsafe<L, B>>, Seq<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>
                        .Inst.Bind<MSeq<EitherUnsafe<L, C>>, Seq<EitherUnsafe<L, C>>, MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(bind(a), b =>
                            default(MEitherUnsafe<L, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;EitherUnsafe&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<EitherUnsafe<L, A>> Where<L, A>(this Seq<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSeq<EitherUnsafe<L, A>>, Seq<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MSeq<EitherUnsafe<L, A>>, Seq<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<EitherUnsafe<L, B>> Select<L, A, B>(this Seq<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            SeqTrans<MSeq<EitherUnsafe<L, A>>, Seq<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MSeq<EitherUnsafe<L, B>>, Seq<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Seq&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Seq&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Seq<EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MSeq<EitherUnsafe<L, A>>, Seq<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Seq&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Seq&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this Seq<EitherUnsafe<L, A>> ma) =>
            SeqTrans<MSeq<EitherUnsafe<L, A>>, Seq<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Seq&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<EitherUnsafe<L, B>> BindT<L, A, B>(this Seq<EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            SeqTrans<MSeq<EitherUnsafe<L, A>>, Seq<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MSeq<EitherUnsafe<L, B>>, Seq<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Seq&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<EitherUnsafe<L, B>> BindT<L, A, B>(this Seq<EitherUnsafe<L, A>> ma, Func<A, Seq<EitherUnsafe<L, B>>> f) =>
            SeqTrans<MSeq<EitherUnsafe<L, A>>, Seq<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MSeq<EitherUnsafe<L, B>>, Seq<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Seq&lt;EitherUnsafe&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe&lt;L, Seq&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Seq&lt;B&gt;&gt;`</returns>
        [Pure]
        public static EitherUnsafe<L, Seq<B>> Traverse<L, A, B>(this Seq<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MSeq<EitherUnsafe<L, A>>, Seq<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, Seq<B>>, EitherUnsafe<L, Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Seq&lt;EitherUnsafe&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe&lt;L, Seq&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static EitherUnsafe<L, Seq<A>> Sequence<L, A>(this Seq<EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<EitherUnsafe<L, B>> MapT<L, A, B>(this Seq<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            SeqTrans<MSeq<EitherUnsafe<L, A>>, Seq<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MSeq<EitherUnsafe<L, B>>, Seq<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Seq<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSeq<EitherUnsafe<L, A>>, Seq<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Seq<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSeq<EitherUnsafe<L, A>>, Seq<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Seq<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            SeqTrans<MSeq<EitherUnsafe<L, A>>, Seq<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Seq<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            SeqTrans<MSeq<EitherUnsafe<L, A>>, Seq<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Seq&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Seq<EitherUnsafe<L, A>> ma, Action<A> f) =>
            SeqTrans<MSeq<EitherUnsafe<L, A>>, Seq<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;EitherUnsafe&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<EitherUnsafe<L, A>> FilterT<L, A>(this Seq<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSeq<EitherUnsafe<L, A>>, Seq<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MSeq<EitherUnsafe<L, A>>, Seq<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Seq<EitherUnsafe<L, A>> PlusT<NUM, L, A>(this Seq<EitherUnsafe<L, A>> x, Seq<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Seq<EitherUnsafe<L, A>> SubtractT<NUM, L, A>(this Seq<EitherUnsafe<L, A>> x, Seq<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Seq<EitherUnsafe<L, A>> ProductT<NUM, L, A>(this Seq<EitherUnsafe<L, A>> x, Seq<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Seq<EitherUnsafe<L, A>> DivideT<NUM, L, A>(this Seq<EitherUnsafe<L, A>> x, Seq<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Seq<EitherUnsafe<L, A>> AppendT<SEMI, L, A>(this Seq<EitherUnsafe<L, A>> x, Seq<EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Seq<EitherUnsafe<L, A>> x, Seq<EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Seq<EitherUnsafe<L, A>> x, Seq<EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Seq&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <returns>`Seq&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Seq<EitherUnsafe<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, Seq<EitherUnsafe<L, A>> fa) =>
            ApplSeq< EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MSeq< Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => ApplEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Seq&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Seq&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <returns>`Seq&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Seq<EitherUnsafe<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Seq<EitherUnsafe<L, A>> fa, Seq<EitherUnsafe<L, B>> fb) =>
            ApplSeq< EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MSeq< Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            ApplEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Set&lt;EitherUnsafe&lt;L, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Set<EitherUnsafe<L, C>> SelectMany<L, A, B, C>(
            this Set<EitherUnsafe<L, A>> ma,
            Func<A, Set<EitherUnsafe<L, B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MSet<EitherUnsafe<L, C>>, Set<EitherUnsafe<L, C>>, MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(ma, a =>
                    SeqTrans<MSet<EitherUnsafe<L, B>>, Set<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>
                        .Inst.Bind<MSet<EitherUnsafe<L, C>>, Set<EitherUnsafe<L, C>>, MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(bind(a), b =>
                            default(MEitherUnsafe<L, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;EitherUnsafe&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<EitherUnsafe<L, A>> Where<L, A>(this Set<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<EitherUnsafe<L, B>> Select<L, A, B>(this Set<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            SeqTrans<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MSet<EitherUnsafe<L, B>>, Set<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Set&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Set&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Set<EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Set&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Set&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this Set<EitherUnsafe<L, A>> ma) =>
            SeqTrans<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<EitherUnsafe<L, B>> BindT<L, A, B>(this Set<EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            SeqTrans<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MSet<EitherUnsafe<L, B>>, Set<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<EitherUnsafe<L, B>> BindT<L, A, B>(this Set<EitherUnsafe<L, A>> ma, Func<A, Set<EitherUnsafe<L, B>>> f) =>
            SeqTrans<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MSet<EitherUnsafe<L, B>>, Set<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Set&lt;EitherUnsafe&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe&lt;L, Set&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Set&lt;B&gt;&gt;`</returns>
        [Pure]
        public static EitherUnsafe<L, Set<B>> Traverse<L, A, B>(this Set<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, Set<B>>, EitherUnsafe<L, Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Set&lt;EitherUnsafe&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe&lt;L, Set&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static EitherUnsafe<L, Set<A>> Sequence<L, A>(this Set<EitherUnsafe<L, A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<EitherUnsafe<L, B>> MapT<L, A, B>(this Set<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            SeqTrans<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MSet<EitherUnsafe<L, B>>, Set<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Set<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Set<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Set<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            SeqTrans<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Set<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            SeqTrans<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Set&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Set<EitherUnsafe<L, A>> ma, Action<A> f) =>
            SeqTrans<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;EitherUnsafe&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<EitherUnsafe<L, A>> FilterT<L, A>(this Set<EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MSet<EitherUnsafe<L, A>>, Set<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Set<EitherUnsafe<L, A>> PlusT<NUM, L, A>(this Set<EitherUnsafe<L, A>> x, Set<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Set<EitherUnsafe<L, A>> SubtractT<NUM, L, A>(this Set<EitherUnsafe<L, A>> x, Set<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Set<EitherUnsafe<L, A>> ProductT<NUM, L, A>(this Set<EitherUnsafe<L, A>> x, Set<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Set<EitherUnsafe<L, A>> DivideT<NUM, L, A>(this Set<EitherUnsafe<L, A>> x, Set<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Set<EitherUnsafe<L, A>> AppendT<SEMI, L, A>(this Set<EitherUnsafe<L, A>> x, Set<EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Set<EitherUnsafe<L, A>> x, Set<EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Set<EitherUnsafe<L, A>> x, Set<EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Set&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <returns>`Set&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Set<EitherUnsafe<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, Set<EitherUnsafe<L, A>> fa) =>
            ApplSet< EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MSet< Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => ApplEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Set&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Set&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <returns>`Set&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Set<EitherUnsafe<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Set<EitherUnsafe<L, A>> fa, Set<EitherUnsafe<L, B>> fb) =>
            ApplSet< EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MSet< Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            ApplEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Validation&lt;FAIL, EitherUnsafe&lt;L, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Validation<FAIL, EitherUnsafe<L, C>> SelectMany<FAIL, L, A, B, C>(
            this Validation<FAIL, EitherUnsafe<L, A>> ma,
            Func<A, Validation<FAIL, EitherUnsafe<L, B>>> bind,
            Func<A, B, C> project) =>
            Trans<MValidation<FAIL, EitherUnsafe<L, A>>, Validation<FAIL, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MValidation<FAIL, EitherUnsafe<L, C>>, Validation<FAIL, EitherUnsafe<L, C>>, MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(ma, a =>
                    Trans<MValidation<FAIL, EitherUnsafe<L, B>>, Validation<FAIL, EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>
                        .Inst.Bind<MValidation<FAIL, EitherUnsafe<L, C>>, Validation<FAIL, EitherUnsafe<L, C>>, MEitherUnsafe<L, C>, EitherUnsafe<L, C>, C>(bind(a), b =>
                            default(MEitherUnsafe<L, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, EitherUnsafe&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, EitherUnsafe<L, A>> Where<FAIL, L, A>(this Validation<FAIL, EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MValidation<FAIL, EitherUnsafe<L, A>>, Validation<FAIL, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MValidation<FAIL, EitherUnsafe<L, A>>, Validation<FAIL, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, EitherUnsafe<L, B>> Select<FAIL, L, A, B>(this Validation<FAIL, EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MValidation<FAIL, EitherUnsafe<L, A>>, Validation<FAIL, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MValidation<FAIL, EitherUnsafe<L, B>>, Validation<FAIL, EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Validation&lt;FAIL, EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, EitherUnsafe&lt;L, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Validation&lt;FAIL, EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, FAIL, L, A>(this Validation<FAIL, EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MValidation<FAIL, EitherUnsafe<L, A>>, Validation<FAIL, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Validation&lt;FAIL, EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, EitherUnsafe&lt;L, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Validation&lt;FAIL, EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<FAIL, L, A>(this Validation<FAIL, EitherUnsafe<L, A>> ma) =>
            Trans<MValidation<FAIL, EitherUnsafe<L, A>>, Validation<FAIL, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Validation&lt;FAIL, EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, EitherUnsafe<L, B>> BindT<FAIL, L, A, B>(this Validation<FAIL, EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            Trans<MValidation<FAIL, EitherUnsafe<L, A>>, Validation<FAIL, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MValidation<FAIL, EitherUnsafe<L, B>>, Validation<FAIL, EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Validation&lt;FAIL, EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, EitherUnsafe<L, B>> BindT<FAIL, L, A, B>(this Validation<FAIL, EitherUnsafe<L, A>> ma, Func<A, Validation<FAIL, EitherUnsafe<L, B>>> f) =>
            Trans<MValidation<FAIL, EitherUnsafe<L, A>>, Validation<FAIL, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MValidation<FAIL, EitherUnsafe<L, B>>, Validation<FAIL, EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Validation&lt;FAIL, EitherUnsafe&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe&lt;L, Validation&lt;FAIL, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Validation&lt;FAIL, B&gt;&gt;`</returns>
        [Pure]
        public static EitherUnsafe<L, Validation<FAIL, B>> Traverse<FAIL, L, A, B>(this Validation<FAIL, EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MValidation<FAIL, EitherUnsafe<L, A>>, Validation<FAIL, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Traverse<MEitherUnsafe<L, Validation<FAIL, B>>, EitherUnsafe<L, Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Validation&lt;FAIL, EitherUnsafe&lt;L, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `EitherUnsafe&lt;L, Validation&lt;FAIL, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<FAIL, L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static EitherUnsafe<L, Validation<FAIL, A>> Sequence<FAIL, L, A>(this Validation<FAIL, EitherUnsafe<L, A>> ma) =>
            ma.Traverse<FAIL, L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, EitherUnsafe<L, B>> MapT<FAIL, L, A, B>(this Validation<FAIL, EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            Trans<MValidation<FAIL, EitherUnsafe<L, A>>, Validation<FAIL, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Map<MValidation<FAIL, EitherUnsafe<L, B>>, Validation<FAIL, EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, FAIL, L, A>(this Validation<FAIL, EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MValidation<FAIL, EitherUnsafe<L, A>>, Validation<FAIL, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, FAIL, L, A>(this Validation<FAIL, EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MValidation<FAIL, EitherUnsafe<L, A>>, Validation<FAIL, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<FAIL, L, A>(this Validation<FAIL, EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MValidation<FAIL, EitherUnsafe<L, A>>, Validation<FAIL, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<FAIL, L, A>(this Validation<FAIL, EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            Trans<MValidation<FAIL, EitherUnsafe<L, A>>, Validation<FAIL, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Validation&lt;FAIL, EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<FAIL, L, A>(this Validation<FAIL, EitherUnsafe<L, A>> ma, Action<A> f) =>
            Trans<MValidation<FAIL, EitherUnsafe<L, A>>, Validation<FAIL, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, EitherUnsafe&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, EitherUnsafe<L, A>> FilterT<FAIL, L, A>(this Validation<FAIL, EitherUnsafe<L, A>> ma, Func<A, bool> pred) =>
            Trans<MValidation<FAIL, EitherUnsafe<L, A>>, Validation<FAIL, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>
                .Inst.Bind<MValidation<FAIL, EitherUnsafe<L, A>>, Validation<FAIL, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>(ma, 
                    a => pred(a)
                        ? default(MEitherUnsafe<L, A>).Return(a)
                        : default(MEitherUnsafe<L, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Validation<FAIL, EitherUnsafe<L, A>> PlusT<NUM, FAIL, L, A>(this Validation<FAIL, EitherUnsafe<L, A>> x, Validation<FAIL, EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Validation<FAIL, EitherUnsafe<L, A>> SubtractT<NUM, FAIL, L, A>(this Validation<FAIL, EitherUnsafe<L, A>> x, Validation<FAIL, EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Validation<FAIL, EitherUnsafe<L, A>> ProductT<NUM, FAIL, L, A>(this Validation<FAIL, EitherUnsafe<L, A>> x, Validation<FAIL, EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Validation<FAIL, EitherUnsafe<L, A>> DivideT<NUM, FAIL, L, A>(this Validation<FAIL, EitherUnsafe<L, A>> x, Validation<FAIL, EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Validation<FAIL, EitherUnsafe<L, A>> AppendT<SEMI, FAIL, L, A>(this Validation<FAIL, EitherUnsafe<L, A>> x, Validation<FAIL, EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, FAIL, L, A>(this Validation<FAIL, EitherUnsafe<L, A>> x, Validation<FAIL, EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, FAIL, L, A>(this Validation<FAIL, EitherUnsafe<L, A>> x, Validation<FAIL, EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Validation&lt;FAIL, EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <returns>`Validation&lt;FAIL, EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Validation<FAIL, EitherUnsafe<L, B>> ApplyT<FAIL, L, A, B>(this Func<A, B> fab, Validation<FAIL, EitherUnsafe<L, A>> fa) =>
            ApplValidation<FAIL, EitherUnsafe<L, A>, EitherUnsafe<L, B>>.Inst.Apply(
                 MValidation<FAIL, Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>.Inst.Return((EitherUnsafe<L, A> a) => ApplEitherUnsafe<L, A, B>.Inst.Apply(
                     MEitherUnsafe<L, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Validation&lt;FAIL, EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Validation&lt;FAIL, EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <returns>`Validation&lt;FAIL, EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Validation<FAIL, EitherUnsafe<L, C>> ApplyT<FAIL, L, A, B, C>(this Func<A, B, C> fabc, Validation<FAIL, EitherUnsafe<L, A>> fa, Validation<FAIL, EitherUnsafe<L, B>> fb) =>
            ApplValidation<FAIL, EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>.Inst.Apply(
                MValidation<FAIL, Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>.Inst.Return(
                    (EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            ApplEitherUnsafe<L, A, B, C>.Inst.Apply(
                                MEitherUnsafe<L, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    /// <summary>
    /// Monad transformer for Try, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class TryT_Extensions
    {
        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Arr&lt;Try&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<Try<C>> SelectMany< A, B, C>(
            this Arr<Try<A>> ma,
            Func<A, Arr<Try<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MArr<Try<C>>, Arr<Try<C>>, MTry<C>, Try<C>, C>(ma, a =>
                    SeqTrans<MArr<Try<B>>, Arr<Try<B>>, MTry<B>, Try<B>, B>
                        .Inst.Bind<MArr<Try<C>>, Arr<Try<C>>, MTry<C>, Try<C>, C>(bind(a), b =>
                            default(MTry<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;Try&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<Try<A>> Where< A>(this Arr<Try<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Try<B>> Select< A, B>(this Arr<Try<A>> ma, Func<A, B> f) =>
            SeqTrans<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MArr<Try<B>>, Arr<Try<B>>, MTry<B>, Try<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Arr&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Try&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Arr&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Arr<Try<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Arr&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Try&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Arr&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Arr<Try<A>> ma) =>
            SeqTrans<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Try<B>> BindT< A, B>(this Arr<Try<A>> ma, Func<A, Try<B>> f) =>
            SeqTrans<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MArr<Try<B>>, Arr<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Try<B>> BindT< A, B>(this Arr<Try<A>> ma, Func<A, Arr<Try<B>>> f) =>
            SeqTrans<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MArr<Try<B>>, Arr<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Arr&lt;Try&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Try&lt;Arr&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;Arr&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Try<Arr<B>> Traverse< A, B>(this Arr<Try<A>> ma, Func<A, B> f) =>
            Trans<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<Arr<B>>, Try<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Arr&lt;Try&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Try&lt;Arr&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Try<Arr<A>> Sequence< A>(this Arr<Try<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Try<B>> MapT< A, B>(this Arr<Try<A>> ma, Func<A, B> f) =>
            SeqTrans<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MArr<Try<B>>, Arr<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Arr<Try<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Arr<Try<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Arr<Try<A>> ma, Func<A, bool> f) =>
            SeqTrans<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Arr<Try<A>> ma, Func<A, bool> f) =>
            SeqTrans<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Arr&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Arr<Try<A>> ma, Action<A> f) =>
            SeqTrans<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;Try&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<Try<A>> FilterT< A>(this Arr<Try<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MArr<Try<A>>, Arr<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Try&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Arr<Try<A>> PlusT<NUM,  A>(this Arr<Try<A>> x, Arr<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Try&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Arr<Try<A>> SubtractT<NUM,  A>(this Arr<Try<A>> x, Arr<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Try&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Arr<Try<A>> ProductT<NUM,  A>(this Arr<Try<A>> x, Arr<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Try&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Arr<Try<A>> DivideT<NUM,  A>(this Arr<Try<A>> x, Arr<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Try&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Arr<Try<A>> AppendT<SEMI,  A>(this Arr<Try<A>> x, Arr<Try<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Arr<Try<A>> x, Arr<Try<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Try&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Arr<Try<A>> x, Arr<Try<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Arr&lt;Try&lt;A&gt;&gt;`</param>
        /// <returns>`Arr&lt;Try&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Arr<Try<B>> ApplyT< A, B>(this Func<A, B> fab, Arr<Try<A>> fa) =>
            ApplArr< Try<A>, Try<B>>.Inst.Apply(
                 MArr< Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => ApplTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Arr&lt;Try&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Arr&lt;Try&lt;A&gt;&gt;`</param>
        /// <returns>`Arr&lt;Try&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Arr<Try<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Arr<Try<A>> fa, Arr<Try<B>> fb) =>
            ApplArr< Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MArr< Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            ApplTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`HashSet&lt;Try&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<Try<C>> SelectMany< A, B, C>(
            this HashSet<Try<A>> ma,
            Func<A, HashSet<Try<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MHashSet<Try<C>>, HashSet<Try<C>>, MTry<C>, Try<C>, C>(ma, a =>
                    SeqTrans<MHashSet<Try<B>>, HashSet<Try<B>>, MTry<B>, Try<B>, B>
                        .Inst.Bind<MHashSet<Try<C>>, HashSet<Try<C>>, MTry<C>, Try<C>, C>(bind(a), b =>
                            default(MTry<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;Try&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<Try<A>> Where< A>(this HashSet<Try<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Try<B>> Select< A, B>(this HashSet<Try<A>> ma, Func<A, B> f) =>
            SeqTrans<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MHashSet<Try<B>>, HashSet<Try<B>>, MTry<B>, Try<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `HashSet&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Try&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `HashSet&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this HashSet<Try<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `HashSet&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Try&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `HashSet&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this HashSet<Try<A>> ma) =>
            SeqTrans<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Try<B>> BindT< A, B>(this HashSet<Try<A>> ma, Func<A, Try<B>> f) =>
            SeqTrans<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MHashSet<Try<B>>, HashSet<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Try<B>> BindT< A, B>(this HashSet<Try<A>> ma, Func<A, HashSet<Try<B>>> f) =>
            SeqTrans<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MHashSet<Try<B>>, HashSet<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `HashSet&lt;Try&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Try&lt;HashSet&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;HashSet&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Try<HashSet<B>> Traverse< A, B>(this HashSet<Try<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<HashSet<B>>, Try<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `HashSet&lt;Try&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Try&lt;HashSet&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Try<HashSet<A>> Sequence< A>(this HashSet<Try<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Try<B>> MapT< A, B>(this HashSet<Try<A>> ma, Func<A, B> f) =>
            SeqTrans<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MHashSet<Try<B>>, HashSet<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this HashSet<Try<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this HashSet<Try<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this HashSet<Try<A>> ma, Func<A, bool> f) =>
            SeqTrans<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this HashSet<Try<A>> ma, Func<A, bool> f) =>
            SeqTrans<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `HashSet&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this HashSet<Try<A>> ma, Action<A> f) =>
            SeqTrans<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;Try&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<Try<A>> FilterT< A>(this HashSet<Try<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MHashSet<Try<A>>, HashSet<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Try&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<Try<A>> PlusT<NUM,  A>(this HashSet<Try<A>> x, HashSet<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Try&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<Try<A>> SubtractT<NUM,  A>(this HashSet<Try<A>> x, HashSet<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Try&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static HashSet<Try<A>> ProductT<NUM,  A>(this HashSet<Try<A>> x, HashSet<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Try&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static HashSet<Try<A>> DivideT<NUM,  A>(this HashSet<Try<A>> x, HashSet<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Try&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static HashSet<Try<A>> AppendT<SEMI,  A>(this HashSet<Try<A>> x, HashSet<Try<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this HashSet<Try<A>> x, HashSet<Try<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Try&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this HashSet<Try<A>> x, HashSet<Try<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `HashSet&lt;Try&lt;A&gt;&gt;`</param>
        /// <returns>`HashSet&lt;Try&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static HashSet<Try<B>> ApplyT< A, B>(this Func<A, B> fab, HashSet<Try<A>> fa) =>
            ApplHashSet< Try<A>, Try<B>>.Inst.Apply(
                 MHashSet< Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => ApplTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `HashSet&lt;Try&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `HashSet&lt;Try&lt;A&gt;&gt;`</param>
        /// <returns>`HashSet&lt;Try&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static HashSet<Try<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, HashSet<Try<A>> fa, HashSet<Try<B>> fb) =>
            ApplHashSet< Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MHashSet< Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            ApplTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Lst&lt;Try&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<Try<C>> SelectMany< A, B, C>(
            this Lst<Try<A>> ma,
            Func<A, Lst<Try<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MLst<Try<C>>, Lst<Try<C>>, MTry<C>, Try<C>, C>(ma, a =>
                    SeqTrans<MLst<Try<B>>, Lst<Try<B>>, MTry<B>, Try<B>, B>
                        .Inst.Bind<MLst<Try<C>>, Lst<Try<C>>, MTry<C>, Try<C>, C>(bind(a), b =>
                            default(MTry<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;Try&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<Try<A>> Where< A>(this Lst<Try<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Try<B>> Select< A, B>(this Lst<Try<A>> ma, Func<A, B> f) =>
            SeqTrans<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MLst<Try<B>>, Lst<Try<B>>, MTry<B>, Try<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Lst&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Try&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Lst&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Lst<Try<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Lst&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Try&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Lst&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Lst<Try<A>> ma) =>
            SeqTrans<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Try<B>> BindT< A, B>(this Lst<Try<A>> ma, Func<A, Try<B>> f) =>
            SeqTrans<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MLst<Try<B>>, Lst<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Try<B>> BindT< A, B>(this Lst<Try<A>> ma, Func<A, Lst<Try<B>>> f) =>
            SeqTrans<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MLst<Try<B>>, Lst<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Lst&lt;Try&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Try&lt;Lst&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;Lst&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Try<Lst<B>> Traverse< A, B>(this Lst<Try<A>> ma, Func<A, B> f) =>
            Trans<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<Lst<B>>, Try<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Lst&lt;Try&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Try&lt;Lst&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Try<Lst<A>> Sequence< A>(this Lst<Try<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Try<B>> MapT< A, B>(this Lst<Try<A>> ma, Func<A, B> f) =>
            SeqTrans<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MLst<Try<B>>, Lst<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Lst<Try<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Lst<Try<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Lst<Try<A>> ma, Func<A, bool> f) =>
            SeqTrans<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Lst<Try<A>> ma, Func<A, bool> f) =>
            SeqTrans<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Lst&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Lst<Try<A>> ma, Action<A> f) =>
            SeqTrans<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;Try&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<Try<A>> FilterT< A>(this Lst<Try<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MLst<Try<A>>, Lst<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Try&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Lst<Try<A>> PlusT<NUM,  A>(this Lst<Try<A>> x, Lst<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Try&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Lst<Try<A>> SubtractT<NUM,  A>(this Lst<Try<A>> x, Lst<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Try&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Lst<Try<A>> ProductT<NUM,  A>(this Lst<Try<A>> x, Lst<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Try&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Lst<Try<A>> DivideT<NUM,  A>(this Lst<Try<A>> x, Lst<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Try&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Lst<Try<A>> AppendT<SEMI,  A>(this Lst<Try<A>> x, Lst<Try<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Lst<Try<A>> x, Lst<Try<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Try&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Lst<Try<A>> x, Lst<Try<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Lst&lt;Try&lt;A&gt;&gt;`</param>
        /// <returns>`Lst&lt;Try&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Lst<Try<B>> ApplyT< A, B>(this Func<A, B> fab, Lst<Try<A>> fa) =>
            ApplLst< Try<A>, Try<B>>.Inst.Apply(
                 MLst< Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => ApplTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Lst&lt;Try&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Lst&lt;Try&lt;A&gt;&gt;`</param>
        /// <returns>`Lst&lt;Try&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Lst<Try<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Lst<Try<A>> fa, Lst<Try<B>> fb) =>
            ApplLst< Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MLst< Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            ApplTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Option&lt;Try&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Option<Try<C>> SelectMany< A, B, C>(
            this Option<Try<A>> ma,
            Func<A, Option<Try<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MOption<Try<C>>, Option<Try<C>>, MTry<C>, Try<C>, C>(ma, a =>
                    Trans<MOption<Try<B>>, Option<Try<B>>, MTry<B>, Try<B>, B>
                        .Inst.Bind<MOption<Try<C>>, Option<Try<C>>, MTry<C>, Try<C>, C>(bind(a), b =>
                            default(MTry<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;Try&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<Try<A>> Where< A>(this Option<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Try<B>> Select< A, B>(this Option<Try<A>> ma, Func<A, B> f) =>
            Trans<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MOption<Try<B>>, Option<Try<B>>, MTry<B>, Try<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Option&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Try&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Option&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Option<Try<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Option&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Try&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Option&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Option<Try<A>> ma) =>
            Trans<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Try<B>> BindT< A, B>(this Option<Try<A>> ma, Func<A, Try<B>> f) =>
            Trans<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MOption<Try<B>>, Option<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Try<B>> BindT< A, B>(this Option<Try<A>> ma, Func<A, Option<Try<B>>> f) =>
            Trans<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MOption<Try<B>>, Option<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Option&lt;Try&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Try&lt;Option&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;Option&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Try<Option<B>> Traverse< A, B>(this Option<Try<A>> ma, Func<A, B> f) =>
            Trans<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<Option<B>>, Try<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Option&lt;Try&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Try&lt;Option&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Try<Option<A>> Sequence< A>(this Option<Try<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Try<B>> MapT< A, B>(this Option<Try<A>> ma, Func<A, B> f) =>
            Trans<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MOption<Try<B>>, Option<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Option<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Option<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Option<Try<A>> ma, Func<A, bool> f) =>
            Trans<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Option<Try<A>> ma, Func<A, bool> f) =>
            Trans<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Option&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Option<Try<A>> ma, Action<A> f) =>
            Trans<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;Try&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<Try<A>> FilterT< A>(this Option<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MOption<Try<A>>, Option<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Try&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Option<Try<A>> PlusT<NUM,  A>(this Option<Try<A>> x, Option<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Try&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Option<Try<A>> SubtractT<NUM,  A>(this Option<Try<A>> x, Option<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Try&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Option<Try<A>> ProductT<NUM,  A>(this Option<Try<A>> x, Option<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Try&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Option<Try<A>> DivideT<NUM,  A>(this Option<Try<A>> x, Option<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Try&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Option<Try<A>> AppendT<SEMI,  A>(this Option<Try<A>> x, Option<Try<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Option<Try<A>> x, Option<Try<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Try&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Option<Try<A>> x, Option<Try<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Option&lt;Try&lt;A&gt;&gt;`</param>
        /// <returns>`Option&lt;Try&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Option<Try<B>> ApplyT< A, B>(this Func<A, B> fab, Option<Try<A>> fa) =>
            ApplOption< Try<A>, Try<B>>.Inst.Apply(
                 MOption< Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => ApplTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Option&lt;Try&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Option&lt;Try&lt;A&gt;&gt;`</param>
        /// <returns>`Option&lt;Try&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Option<Try<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Option<Try<A>> fa, Option<Try<B>> fb) =>
            ApplOption< Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MOption< Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            ApplTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionUnsafe&lt;Try&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<Try<C>> SelectMany< A, B, C>(
            this OptionUnsafe<Try<A>> ma,
            Func<A, OptionUnsafe<Try<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MOptionUnsafe<Try<C>>, OptionUnsafe<Try<C>>, MTry<C>, Try<C>, C>(ma, a =>
                    Trans<MOptionUnsafe<Try<B>>, OptionUnsafe<Try<B>>, MTry<B>, Try<B>, B>
                        .Inst.Bind<MOptionUnsafe<Try<C>>, OptionUnsafe<Try<C>>, MTry<C>, Try<C>, C>(bind(a), b =>
                            default(MTry<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;Try&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<Try<A>> Where< A>(this OptionUnsafe<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Try<B>> Select< A, B>(this OptionUnsafe<Try<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MOptionUnsafe<Try<B>>, OptionUnsafe<Try<B>>, MTry<B>, Try<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionUnsafe&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Try&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionUnsafe&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this OptionUnsafe<Try<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionUnsafe&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Try&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionUnsafe&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this OptionUnsafe<Try<A>> ma) =>
            Trans<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Try<B>> BindT< A, B>(this OptionUnsafe<Try<A>> ma, Func<A, Try<B>> f) =>
            Trans<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MOptionUnsafe<Try<B>>, OptionUnsafe<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Try<B>> BindT< A, B>(this OptionUnsafe<Try<A>> ma, Func<A, OptionUnsafe<Try<B>>> f) =>
            Trans<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MOptionUnsafe<Try<B>>, OptionUnsafe<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionUnsafe&lt;Try&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Try&lt;OptionUnsafe&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;OptionUnsafe&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Try<OptionUnsafe<B>> Traverse< A, B>(this OptionUnsafe<Try<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<OptionUnsafe<B>>, Try<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionUnsafe&lt;Try&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Try&lt;OptionUnsafe&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Try<OptionUnsafe<A>> Sequence< A>(this OptionUnsafe<Try<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Try<B>> MapT< A, B>(this OptionUnsafe<Try<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MOptionUnsafe<Try<B>>, OptionUnsafe<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this OptionUnsafe<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this OptionUnsafe<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this OptionUnsafe<Try<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this OptionUnsafe<Try<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionUnsafe&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this OptionUnsafe<Try<A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;Try&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<Try<A>> FilterT< A>(this OptionUnsafe<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MOptionUnsafe<Try<A>>, OptionUnsafe<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Try&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<Try<A>> PlusT<NUM,  A>(this OptionUnsafe<Try<A>> x, OptionUnsafe<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Try&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<Try<A>> SubtractT<NUM,  A>(this OptionUnsafe<Try<A>> x, OptionUnsafe<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Try&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionUnsafe<Try<A>> ProductT<NUM,  A>(this OptionUnsafe<Try<A>> x, OptionUnsafe<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Try&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionUnsafe<Try<A>> DivideT<NUM,  A>(this OptionUnsafe<Try<A>> x, OptionUnsafe<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Try&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionUnsafe<Try<A>> AppendT<SEMI,  A>(this OptionUnsafe<Try<A>> x, OptionUnsafe<Try<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this OptionUnsafe<Try<A>> x, OptionUnsafe<Try<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Try&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this OptionUnsafe<Try<A>> x, OptionUnsafe<Try<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe&lt;Try&lt;A&gt;&gt;`</param>
        /// <returns>`OptionUnsafe&lt;Try&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionUnsafe<Try<B>> ApplyT< A, B>(this Func<A, B> fab, OptionUnsafe<Try<A>> fa) =>
            ApplOptionUnsafe< Try<A>, Try<B>>.Inst.Apply(
                 MOptionUnsafe< Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => ApplTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe&lt;Try&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `OptionUnsafe&lt;Try&lt;A&gt;&gt;`</param>
        /// <returns>`OptionUnsafe&lt;Try&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionUnsafe<Try<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, OptionUnsafe<Try<A>> fa, OptionUnsafe<Try<B>> fb) =>
            ApplOptionUnsafe< Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MOptionUnsafe< Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            ApplTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Either&lt;L, Try&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, Try<C>> SelectMany<L, A, B, C>(
            this Either<L, Try<A>> ma,
            Func<A, Either<L, Try<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MEither<L, Try<C>>, Either<L, Try<C>>, MTry<C>, Try<C>, C>(ma, a =>
                    Trans<MEither<L, Try<B>>, Either<L, Try<B>>, MTry<B>, Try<B>, B>
                        .Inst.Bind<MEither<L, Try<C>>, Either<L, Try<C>>, MTry<C>, Try<C>, C>(bind(a), b =>
                            default(MTry<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, Try&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, Try<A>> Where<L, A>(this Either<L, Try<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Try<B>> Select<L, A, B>(this Either<L, Try<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MEither<L, Try<B>>, Either<L, Try<B>>, MTry<B>, Try<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Either&lt;L, Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Try&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Either&lt;L, Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Either<L, Try<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Either&lt;L, Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Try&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Either&lt;L, Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this Either<L, Try<A>> ma) =>
            Trans<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either&lt;L, Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Try<B>> BindT<L, A, B>(this Either<L, Try<A>> ma, Func<A, Try<B>> f) =>
            Trans<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MEither<L, Try<B>>, Either<L, Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either&lt;L, Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Try<B>> BindT<L, A, B>(this Either<L, Try<A>> ma, Func<A, Either<L, Try<B>>> f) =>
            Trans<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MEither<L, Try<B>>, Either<L, Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Either&lt;L, Try&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Try&lt;Either&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;Either&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static Try<Either<L, B>> Traverse<L, A, B>(this Either<L, Try<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<Either<L, B>>, Try<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Either&lt;L, Try&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Try&lt;Either&lt;L, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static Try<Either<L, A>> Sequence<L, A>(this Either<L, Try<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Try<B>> MapT<L, A, B>(this Either<L, Try<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MEither<L, Try<B>>, Either<L, Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Either<L, Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Either<L, Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Either<L, Try<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Either<L, Try<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Either&lt;L, Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Either<L, Try<A>> ma, Action<A> f) =>
            Trans<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, Try&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, Try<A>> FilterT<L, A>(this Either<L, Try<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MEither<L, Try<A>>, Either<L, Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Try&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, Try<A>> PlusT<NUM, L, A>(this Either<L, Try<A>> x, Either<L, Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Try&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, Try<A>> SubtractT<NUM, L, A>(this Either<L, Try<A>> x, Either<L, Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Try&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Either<L, Try<A>> ProductT<NUM, L, A>(this Either<L, Try<A>> x, Either<L, Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Try&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Either<L, Try<A>> DivideT<NUM, L, A>(this Either<L, Try<A>> x, Either<L, Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Try&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Either<L, Try<A>> AppendT<SEMI, L, A>(this Either<L, Try<A>> x, Either<L, Try<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Either<L, Try<A>> x, Either<L, Try<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Try&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Either<L, Try<A>> x, Either<L, Try<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Either&lt;L, Try&lt;A&gt;&gt;`</param>
        /// <returns>`Either&lt;L, Try&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Either<L, Try<B>> ApplyT<L, A, B>(this Func<A, B> fab, Either<L, Try<A>> fa) =>
            ApplEither<L, Try<A>, Try<B>>.Inst.Apply(
                 MEither<L, Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => ApplTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Either&lt;L, Try&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Either&lt;L, Try&lt;A&gt;&gt;`</param>
        /// <returns>`Either&lt;L, Try&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Either<L, Try<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Either<L, Try<A>> fa, Either<L, Try<B>> fb) =>
            ApplEither<L, Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MEither<L, Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            ApplTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`EitherUnsafe&lt;L, Try&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, Try<C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, Try<A>> ma,
            Func<A, EitherUnsafe<L, Try<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Try<C>>, EitherUnsafe<L, Try<C>>, MTry<C>, Try<C>, C>(ma, a =>
                    Trans<MEitherUnsafe<L, Try<B>>, EitherUnsafe<L, Try<B>>, MTry<B>, Try<B>, B>
                        .Inst.Bind<MEitherUnsafe<L, Try<C>>, EitherUnsafe<L, Try<C>>, MTry<C>, Try<C>, C>(bind(a), b =>
                            default(MTry<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, Try&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, Try<A>> Where<L, A>(this EitherUnsafe<L, Try<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Try<B>> Select<L, A, B>(this EitherUnsafe<L, Try<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MEitherUnsafe<L, Try<B>>, EitherUnsafe<L, Try<B>>, MTry<B>, Try<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherUnsafe&lt;L, Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Try&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherUnsafe&lt;L, Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this EitherUnsafe<L, Try<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherUnsafe&lt;L, Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Try&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherUnsafe&lt;L, Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this EitherUnsafe<L, Try<A>> ma) =>
            Trans<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Try<B>> BindT<L, A, B>(this EitherUnsafe<L, Try<A>> ma, Func<A, Try<B>> f) =>
            Trans<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Try<B>>, EitherUnsafe<L, Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Try<B>> BindT<L, A, B>(this EitherUnsafe<L, Try<A>> ma, Func<A, EitherUnsafe<L, Try<B>>> f) =>
            Trans<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Try<B>>, EitherUnsafe<L, Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `EitherUnsafe&lt;L, Try&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Try&lt;EitherUnsafe&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;EitherUnsafe&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static Try<EitherUnsafe<L, B>> Traverse<L, A, B>(this EitherUnsafe<L, Try<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<EitherUnsafe<L, B>>, Try<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `EitherUnsafe&lt;L, Try&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Try&lt;EitherUnsafe&lt;L, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static Try<EitherUnsafe<L, A>> Sequence<L, A>(this EitherUnsafe<L, Try<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Try<B>> MapT<L, A, B>(this EitherUnsafe<L, Try<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MEitherUnsafe<L, Try<B>>, EitherUnsafe<L, Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this EitherUnsafe<L, Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this EitherUnsafe<L, Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this EitherUnsafe<L, Try<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this EitherUnsafe<L, Try<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherUnsafe&lt;L, Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this EitherUnsafe<L, Try<A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, Try&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, Try<A>> FilterT<L, A>(this EitherUnsafe<L, Try<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Try<A>>, EitherUnsafe<L, Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Try&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, Try<A>> PlusT<NUM, L, A>(this EitherUnsafe<L, Try<A>> x, EitherUnsafe<L, Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Try&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, Try<A>> SubtractT<NUM, L, A>(this EitherUnsafe<L, Try<A>> x, EitherUnsafe<L, Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Try&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherUnsafe<L, Try<A>> ProductT<NUM, L, A>(this EitherUnsafe<L, Try<A>> x, EitherUnsafe<L, Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Try&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherUnsafe<L, Try<A>> DivideT<NUM, L, A>(this EitherUnsafe<L, Try<A>> x, EitherUnsafe<L, Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Try&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherUnsafe<L, Try<A>> AppendT<SEMI, L, A>(this EitherUnsafe<L, Try<A>> x, EitherUnsafe<L, Try<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this EitherUnsafe<L, Try<A>> x, EitherUnsafe<L, Try<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Try&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this EitherUnsafe<L, Try<A>> x, EitherUnsafe<L, Try<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe&lt;L, Try&lt;A&gt;&gt;`</param>
        /// <returns>`EitherUnsafe&lt;L, Try&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherUnsafe<L, Try<B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherUnsafe<L, Try<A>> fa) =>
            ApplEitherUnsafe<L, Try<A>, Try<B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => ApplTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe&lt;L, Try&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `EitherUnsafe&lt;L, Try&lt;A&gt;&gt;`</param>
        /// <returns>`EitherUnsafe&lt;L, Try&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherUnsafe<L, Try<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherUnsafe<L, Try<A>> fa, EitherUnsafe<L, Try<B>> fb) =>
            ApplEitherUnsafe<L, Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MEitherUnsafe<L, Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            ApplTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Try&lt;Try&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Try<Try<C>> SelectMany< A, B, C>(
            this Try<Try<A>> ma,
            Func<A, Try<Try<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MTry<Try<C>>, Try<Try<C>>, MTry<C>, Try<C>, C>(ma, a =>
                    Trans<MTry<Try<B>>, Try<Try<B>>, MTry<B>, Try<B>, B>
                        .Inst.Bind<MTry<Try<C>>, Try<Try<C>>, MTry<C>, Try<C>, C>(bind(a), b =>
                            default(MTry<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;Try&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<Try<A>> Where< A>(this Try<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Try<B>> Select< A, B>(this Try<Try<A>> ma, Func<A, B> f) =>
            Trans<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MTry<Try<B>>, Try<Try<B>>, MTry<B>, Try<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Try&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Try&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Try&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Try<Try<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Try&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Try&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Try&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Try<Try<A>> ma) =>
            Trans<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Try<B>> BindT< A, B>(this Try<Try<A>> ma, Func<A, Try<B>> f) =>
            Trans<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MTry<Try<B>>, Try<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Try<B>> BindT< A, B>(this Try<Try<A>> ma, Func<A, Try<Try<B>>> f) =>
            Trans<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MTry<Try<B>>, Try<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Try&lt;Try&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Try&lt;Try&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;Try&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Try<Try<B>> Traverse< A, B>(this Try<Try<A>> ma, Func<A, B> f) =>
            Trans<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<Try<B>>, Try<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Try&lt;Try&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Try&lt;Try&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Try<Try<A>> Sequence< A>(this Try<Try<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Try<B>> MapT< A, B>(this Try<Try<A>> ma, Func<A, B> f) =>
            Trans<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MTry<Try<B>>, Try<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Try<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Try<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Try<Try<A>> ma, Func<A, bool> f) =>
            Trans<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Try<Try<A>> ma, Func<A, bool> f) =>
            Trans<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Try&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Try<Try<A>> ma, Action<A> f) =>
            Trans<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;Try&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<Try<A>> FilterT< A>(this Try<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MTry<Try<A>>, Try<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Try&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Try<Try<A>> PlusT<NUM,  A>(this Try<Try<A>> x, Try<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Try&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Try<Try<A>> SubtractT<NUM,  A>(this Try<Try<A>> x, Try<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Try&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Try<Try<A>> ProductT<NUM,  A>(this Try<Try<A>> x, Try<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Try&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Try<Try<A>> DivideT<NUM,  A>(this Try<Try<A>> x, Try<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Try&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Try<Try<A>> AppendT<SEMI,  A>(this Try<Try<A>> x, Try<Try<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Try<Try<A>> x, Try<Try<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Try&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Try<Try<A>> x, Try<Try<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Try&lt;Try&lt;A&gt;&gt;`</param>
        /// <returns>`Try&lt;Try&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Try<Try<B>> ApplyT< A, B>(this Func<A, B> fab, Try<Try<A>> fa) =>
            ApplTry< Try<A>, Try<B>>.Inst.Apply(
                 MTry< Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => ApplTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Try&lt;Try&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Try&lt;Try&lt;A&gt;&gt;`</param>
        /// <returns>`Try&lt;Try&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Try<Try<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Try<Try<A>> fa, Try<Try<B>> fb) =>
            ApplTry< Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MTry< Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            ApplTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOption&lt;Try&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<Try<C>> SelectMany< A, B, C>(
            this TryOption<Try<A>> ma,
            Func<A, TryOption<Try<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MTryOption<Try<C>>, TryOption<Try<C>>, MTry<C>, Try<C>, C>(ma, a =>
                    Trans<MTryOption<Try<B>>, TryOption<Try<B>>, MTry<B>, Try<B>, B>
                        .Inst.Bind<MTryOption<Try<C>>, TryOption<Try<C>>, MTry<C>, Try<C>, C>(bind(a), b =>
                            default(MTry<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;Try&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<Try<A>> Where< A>(this TryOption<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Try<B>> Select< A, B>(this TryOption<Try<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MTryOption<Try<B>>, TryOption<Try<B>>, MTry<B>, Try<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOption&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Try&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOption&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryOption<Try<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOption&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Try&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOption&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this TryOption<Try<A>> ma) =>
            Trans<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Try<B>> BindT< A, B>(this TryOption<Try<A>> ma, Func<A, Try<B>> f) =>
            Trans<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MTryOption<Try<B>>, TryOption<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Try<B>> BindT< A, B>(this TryOption<Try<A>> ma, Func<A, TryOption<Try<B>>> f) =>
            Trans<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MTryOption<Try<B>>, TryOption<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOption&lt;Try&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Try&lt;TryOption&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;TryOption&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Try<TryOption<B>> Traverse< A, B>(this TryOption<Try<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<TryOption<B>>, Try<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOption&lt;Try&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Try&lt;TryOption&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Try<TryOption<A>> Sequence< A>(this TryOption<Try<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Try<B>> MapT< A, B>(this TryOption<Try<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MTryOption<Try<B>>, TryOption<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryOption<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryOption<Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryOption<Try<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryOption<Try<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOption&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryOption<Try<A>> ma, Action<A> f) =>
            Trans<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;Try&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<Try<A>> FilterT< A>(this TryOption<Try<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MTryOption<Try<A>>, TryOption<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Try&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<Try<A>> PlusT<NUM,  A>(this TryOption<Try<A>> x, TryOption<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Try&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<Try<A>> SubtractT<NUM,  A>(this TryOption<Try<A>> x, TryOption<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Try&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOption<Try<A>> ProductT<NUM,  A>(this TryOption<Try<A>> x, TryOption<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Try&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOption<Try<A>> DivideT<NUM,  A>(this TryOption<Try<A>> x, TryOption<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Try&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOption<Try<A>> AppendT<SEMI,  A>(this TryOption<Try<A>> x, TryOption<Try<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryOption<Try<A>> x, TryOption<Try<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Try&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryOption<Try<A>> x, TryOption<Try<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOption&lt;Try&lt;A&gt;&gt;`</param>
        /// <returns>`TryOption&lt;Try&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOption<Try<B>> ApplyT< A, B>(this Func<A, B> fab, TryOption<Try<A>> fa) =>
            ApplTryOption< Try<A>, Try<B>>.Inst.Apply(
                 MTryOption< Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => ApplTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOption&lt;Try&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryOption&lt;Try&lt;A&gt;&gt;`</param>
        /// <returns>`TryOption&lt;Try&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOption<Try<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOption<Try<A>> fa, TryOption<Try<B>> fb) =>
            ApplTryOption< Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MTryOption< Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            ApplTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`IEnumerable&lt;Try&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<Try<C>> SelectMany< A, B, C>(
            this IEnumerable<Try<A>> ma,
            Func<A, IEnumerable<Try<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MEnumerable<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MEnumerable<Try<C>>, IEnumerable<Try<C>>, MTry<C>, Try<C>, C>(ma, a =>
                    SeqTrans<MEnumerable<Try<B>>, IEnumerable<Try<B>>, MTry<B>, Try<B>, B>
                        .Inst.Bind<MEnumerable<Try<C>>, IEnumerable<Try<C>>, MTry<C>, Try<C>, C>(bind(a), b =>
                            default(MTry<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;Try&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<Try<A>> Where< A>(this IEnumerable<Try<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MEnumerable<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MEnumerable<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Try<B>> Select< A, B>(this IEnumerable<Try<A>> ma, Func<A, B> f) =>
            SeqTrans<MEnumerable<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MEnumerable<Try<B>>, IEnumerable<Try<B>>, MTry<B>, Try<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `IEnumerable&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Try&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `IEnumerable&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this IEnumerable<Try<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MEnumerable<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `IEnumerable&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Try&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `IEnumerable&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this IEnumerable<Try<A>> ma) =>
            SeqTrans<MEnumerable<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Try<B>> BindT< A, B>(this IEnumerable<Try<A>> ma, Func<A, Try<B>> f) =>
            SeqTrans<MEnumerable<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MEnumerable<Try<B>>, IEnumerable<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Try<B>> BindT< A, B>(this IEnumerable<Try<A>> ma, Func<A, IEnumerable<Try<B>>> f) =>
            SeqTrans<MEnumerable<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MEnumerable<Try<B>>, IEnumerable<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `IEnumerable&lt;Try&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Try&lt;IEnumerable&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;IEnumerable&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Try<IEnumerable<B>> Traverse< A, B>(this IEnumerable<Try<A>> ma, Func<A, B> f) =>
            Trans<MEnumerable<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<IEnumerable<B>>, Try<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `IEnumerable&lt;Try&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Try&lt;IEnumerable&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Try<IEnumerable<A>> Sequence< A>(this IEnumerable<Try<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Try<B>> MapT< A, B>(this IEnumerable<Try<A>> ma, Func<A, B> f) =>
            SeqTrans<MEnumerable<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MEnumerable<Try<B>>, IEnumerable<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this IEnumerable<Try<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MEnumerable<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this IEnumerable<Try<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MEnumerable<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this IEnumerable<Try<A>> ma, Func<A, bool> f) =>
            SeqTrans<MEnumerable<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this IEnumerable<Try<A>> ma, Func<A, bool> f) =>
            SeqTrans<MEnumerable<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `IEnumerable&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this IEnumerable<Try<A>> ma, Action<A> f) =>
            SeqTrans<MEnumerable<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;Try&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<Try<A>> FilterT< A>(this IEnumerable<Try<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MEnumerable<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MEnumerable<Try<A>>, IEnumerable<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Try&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<Try<A>> PlusT<NUM,  A>(this IEnumerable<Try<A>> x, IEnumerable<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Try&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<Try<A>> SubtractT<NUM,  A>(this IEnumerable<Try<A>> x, IEnumerable<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Try&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static IEnumerable<Try<A>> ProductT<NUM,  A>(this IEnumerable<Try<A>> x, IEnumerable<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Try&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static IEnumerable<Try<A>> DivideT<NUM,  A>(this IEnumerable<Try<A>> x, IEnumerable<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Try&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static IEnumerable<Try<A>> AppendT<SEMI,  A>(this IEnumerable<Try<A>> x, IEnumerable<Try<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this IEnumerable<Try<A>> x, IEnumerable<Try<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Try&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this IEnumerable<Try<A>> x, IEnumerable<Try<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `IEnumerable&lt;Try&lt;A&gt;&gt;`</param>
        /// <returns>`IEnumerable&lt;Try&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static IEnumerable<Try<B>> ApplyT< A, B>(this Func<A, B> fab, IEnumerable<Try<A>> fa) =>
            ApplEnumerable< Try<A>, Try<B>>.Inst.Apply(
                 MEnumerable< Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => ApplTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `IEnumerable&lt;Try&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `IEnumerable&lt;Try&lt;A&gt;&gt;`</param>
        /// <returns>`IEnumerable&lt;Try&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static IEnumerable<Try<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, IEnumerable<Try<A>> fa, IEnumerable<Try<B>> fb) =>
            ApplEnumerable< Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MEnumerable< Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            ApplTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Seq&lt;Try&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Seq<Try<C>> SelectMany< A, B, C>(
            this Seq<Try<A>> ma,
            Func<A, Seq<Try<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MSeq<Try<A>>, Seq<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MSeq<Try<C>>, Seq<Try<C>>, MTry<C>, Try<C>, C>(ma, a =>
                    SeqTrans<MSeq<Try<B>>, Seq<Try<B>>, MTry<B>, Try<B>, B>
                        .Inst.Bind<MSeq<Try<C>>, Seq<Try<C>>, MTry<C>, Try<C>, C>(bind(a), b =>
                            default(MTry<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;Try&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<Try<A>> Where< A>(this Seq<Try<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSeq<Try<A>>, Seq<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MSeq<Try<A>>, Seq<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<Try<B>> Select< A, B>(this Seq<Try<A>> ma, Func<A, B> f) =>
            SeqTrans<MSeq<Try<A>>, Seq<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MSeq<Try<B>>, Seq<Try<B>>, MTry<B>, Try<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Seq&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Try&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Seq&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Seq<Try<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MSeq<Try<A>>, Seq<Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Seq&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Try&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Seq&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Seq<Try<A>> ma) =>
            SeqTrans<MSeq<Try<A>>, Seq<Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Seq&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<Try<B>> BindT< A, B>(this Seq<Try<A>> ma, Func<A, Try<B>> f) =>
            SeqTrans<MSeq<Try<A>>, Seq<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MSeq<Try<B>>, Seq<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Seq&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<Try<B>> BindT< A, B>(this Seq<Try<A>> ma, Func<A, Seq<Try<B>>> f) =>
            SeqTrans<MSeq<Try<A>>, Seq<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MSeq<Try<B>>, Seq<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Seq&lt;Try&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Try&lt;Seq&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;Seq&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Try<Seq<B>> Traverse< A, B>(this Seq<Try<A>> ma, Func<A, B> f) =>
            Trans<MSeq<Try<A>>, Seq<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<Seq<B>>, Try<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Seq&lt;Try&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Try&lt;Seq&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Try<Seq<A>> Sequence< A>(this Seq<Try<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<Try<B>> MapT< A, B>(this Seq<Try<A>> ma, Func<A, B> f) =>
            SeqTrans<MSeq<Try<A>>, Seq<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MSeq<Try<B>>, Seq<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Seq<Try<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSeq<Try<A>>, Seq<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Seq<Try<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSeq<Try<A>>, Seq<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Seq<Try<A>> ma, Func<A, bool> f) =>
            SeqTrans<MSeq<Try<A>>, Seq<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Seq<Try<A>> ma, Func<A, bool> f) =>
            SeqTrans<MSeq<Try<A>>, Seq<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Seq&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Seq<Try<A>> ma, Action<A> f) =>
            SeqTrans<MSeq<Try<A>>, Seq<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;Try&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<Try<A>> FilterT< A>(this Seq<Try<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSeq<Try<A>>, Seq<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MSeq<Try<A>>, Seq<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Try&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Seq<Try<A>> PlusT<NUM,  A>(this Seq<Try<A>> x, Seq<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Try&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Seq<Try<A>> SubtractT<NUM,  A>(this Seq<Try<A>> x, Seq<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Try&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Seq<Try<A>> ProductT<NUM,  A>(this Seq<Try<A>> x, Seq<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Try&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Seq<Try<A>> DivideT<NUM,  A>(this Seq<Try<A>> x, Seq<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Try&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Seq<Try<A>> AppendT<SEMI,  A>(this Seq<Try<A>> x, Seq<Try<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Seq<Try<A>> x, Seq<Try<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Try&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Seq<Try<A>> x, Seq<Try<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Seq&lt;Try&lt;A&gt;&gt;`</param>
        /// <returns>`Seq&lt;Try&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Seq<Try<B>> ApplyT< A, B>(this Func<A, B> fab, Seq<Try<A>> fa) =>
            ApplSeq< Try<A>, Try<B>>.Inst.Apply(
                 MSeq< Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => ApplTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Seq&lt;Try&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Seq&lt;Try&lt;A&gt;&gt;`</param>
        /// <returns>`Seq&lt;Try&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Seq<Try<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Seq<Try<A>> fa, Seq<Try<B>> fb) =>
            ApplSeq< Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MSeq< Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            ApplTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Set&lt;Try&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Set<Try<C>> SelectMany< A, B, C>(
            this Set<Try<A>> ma,
            Func<A, Set<Try<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MSet<Try<C>>, Set<Try<C>>, MTry<C>, Try<C>, C>(ma, a =>
                    SeqTrans<MSet<Try<B>>, Set<Try<B>>, MTry<B>, Try<B>, B>
                        .Inst.Bind<MSet<Try<C>>, Set<Try<C>>, MTry<C>, Try<C>, C>(bind(a), b =>
                            default(MTry<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;Try&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<Try<A>> Where< A>(this Set<Try<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Try<B>> Select< A, B>(this Set<Try<A>> ma, Func<A, B> f) =>
            SeqTrans<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MSet<Try<B>>, Set<Try<B>>, MTry<B>, Try<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Set&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Try&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Set&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Set<Try<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Set&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Try&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Set&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Set<Try<A>> ma) =>
            SeqTrans<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Try<B>> BindT< A, B>(this Set<Try<A>> ma, Func<A, Try<B>> f) =>
            SeqTrans<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MSet<Try<B>>, Set<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Try<B>> BindT< A, B>(this Set<Try<A>> ma, Func<A, Set<Try<B>>> f) =>
            SeqTrans<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MSet<Try<B>>, Set<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Set&lt;Try&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Try&lt;Set&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;Set&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Try<Set<B>> Traverse< A, B>(this Set<Try<A>> ma, Func<A, B> f) =>
            Trans<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<Set<B>>, Try<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Set&lt;Try&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Try&lt;Set&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Try<Set<A>> Sequence< A>(this Set<Try<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Try<B>> MapT< A, B>(this Set<Try<A>> ma, Func<A, B> f) =>
            SeqTrans<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MSet<Try<B>>, Set<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Set<Try<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Set<Try<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Set<Try<A>> ma, Func<A, bool> f) =>
            SeqTrans<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Set<Try<A>> ma, Func<A, bool> f) =>
            SeqTrans<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Set&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Set<Try<A>> ma, Action<A> f) =>
            SeqTrans<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;Try&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<Try<A>> FilterT< A>(this Set<Try<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MSet<Try<A>>, Set<Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Try&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Set<Try<A>> PlusT<NUM,  A>(this Set<Try<A>> x, Set<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Try&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Set<Try<A>> SubtractT<NUM,  A>(this Set<Try<A>> x, Set<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Try&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Set<Try<A>> ProductT<NUM,  A>(this Set<Try<A>> x, Set<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Try&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Set<Try<A>> DivideT<NUM,  A>(this Set<Try<A>> x, Set<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Try&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Set<Try<A>> AppendT<SEMI,  A>(this Set<Try<A>> x, Set<Try<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Set<Try<A>> x, Set<Try<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Try&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Set<Try<A>> x, Set<Try<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Set&lt;Try&lt;A&gt;&gt;`</param>
        /// <returns>`Set&lt;Try&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Set<Try<B>> ApplyT< A, B>(this Func<A, B> fab, Set<Try<A>> fa) =>
            ApplSet< Try<A>, Try<B>>.Inst.Apply(
                 MSet< Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => ApplTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Set&lt;Try&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Set&lt;Try&lt;A&gt;&gt;`</param>
        /// <returns>`Set&lt;Try&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Set<Try<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Set<Try<A>> fa, Set<Try<B>> fb) =>
            ApplSet< Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MSet< Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            ApplTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Validation&lt;FAIL, Try&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Validation<FAIL, Try<C>> SelectMany<FAIL, A, B, C>(
            this Validation<FAIL, Try<A>> ma,
            Func<A, Validation<FAIL, Try<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MValidation<FAIL, Try<A>>, Validation<FAIL, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MValidation<FAIL, Try<C>>, Validation<FAIL, Try<C>>, MTry<C>, Try<C>, C>(ma, a =>
                    Trans<MValidation<FAIL, Try<B>>, Validation<FAIL, Try<B>>, MTry<B>, Try<B>, B>
                        .Inst.Bind<MValidation<FAIL, Try<C>>, Validation<FAIL, Try<C>>, MTry<C>, Try<C>, C>(bind(a), b =>
                            default(MTry<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, Try&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, Try<A>> Where<FAIL, A>(this Validation<FAIL, Try<A>> ma, Func<A, bool> pred) =>
            Trans<MValidation<FAIL, Try<A>>, Validation<FAIL, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MValidation<FAIL, Try<A>>, Validation<FAIL, Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, Try<B>> Select<FAIL, A, B>(this Validation<FAIL, Try<A>> ma, Func<A, B> f) =>
            Trans<MValidation<FAIL, Try<A>>, Validation<FAIL, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MValidation<FAIL, Try<B>>, Validation<FAIL, Try<B>>, MTry<B>, Try<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Validation&lt;FAIL, Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Try&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Validation&lt;FAIL, Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, FAIL, A>(this Validation<FAIL, Try<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MValidation<FAIL, Try<A>>, Validation<FAIL, Try<A>>, MTry<A>, Try<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Validation&lt;FAIL, Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Try&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Validation&lt;FAIL, Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<FAIL, A>(this Validation<FAIL, Try<A>> ma) =>
            Trans<MValidation<FAIL, Try<A>>, Validation<FAIL, Try<A>>, MTry<A>, Try<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Validation&lt;FAIL, Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, Try<B>> BindT<FAIL, A, B>(this Validation<FAIL, Try<A>> ma, Func<A, Try<B>> f) =>
            Trans<MValidation<FAIL, Try<A>>, Validation<FAIL, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MValidation<FAIL, Try<B>>, Validation<FAIL, Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Validation&lt;FAIL, Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, Try<B>> BindT<FAIL, A, B>(this Validation<FAIL, Try<A>> ma, Func<A, Validation<FAIL, Try<B>>> f) =>
            Trans<MValidation<FAIL, Try<A>>, Validation<FAIL, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MValidation<FAIL, Try<B>>, Validation<FAIL, Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Validation&lt;FAIL, Try&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Try&lt;Validation&lt;FAIL, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;Validation&lt;FAIL, B&gt;&gt;`</returns>
        [Pure]
        public static Try<Validation<FAIL, B>> Traverse<FAIL, A, B>(this Validation<FAIL, Try<A>> ma, Func<A, B> f) =>
            Trans<MValidation<FAIL, Try<A>>, Validation<FAIL, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Traverse<MTry<Validation<FAIL, B>>, Try<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Validation&lt;FAIL, Try&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Try&lt;Validation&lt;FAIL, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<FAIL, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static Try<Validation<FAIL, A>> Sequence<FAIL, A>(this Validation<FAIL, Try<A>> ma) =>
            ma.Traverse<FAIL, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, Try<B>> MapT<FAIL, A, B>(this Validation<FAIL, Try<A>> ma, Func<A, B> f) =>
            Trans<MValidation<FAIL, Try<A>>, Validation<FAIL, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Map<MValidation<FAIL, Try<B>>, Validation<FAIL, Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, FAIL, A>(this Validation<FAIL, Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MValidation<FAIL, Try<A>>, Validation<FAIL, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, FAIL, A>(this Validation<FAIL, Try<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MValidation<FAIL, Try<A>>, Validation<FAIL, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<FAIL, A>(this Validation<FAIL, Try<A>> ma, Func<A, bool> f) =>
            Trans<MValidation<FAIL, Try<A>>, Validation<FAIL, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<FAIL, A>(this Validation<FAIL, Try<A>> ma, Func<A, bool> f) =>
            Trans<MValidation<FAIL, Try<A>>, Validation<FAIL, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Validation&lt;FAIL, Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<FAIL, A>(this Validation<FAIL, Try<A>> ma, Action<A> f) =>
            Trans<MValidation<FAIL, Try<A>>, Validation<FAIL, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, Try&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, Try<A>> FilterT<FAIL, A>(this Validation<FAIL, Try<A>> ma, Func<A, bool> pred) =>
            Trans<MValidation<FAIL, Try<A>>, Validation<FAIL, Try<A>>, MTry<A>, Try<A>, A>
                .Inst.Bind<MValidation<FAIL, Try<A>>, Validation<FAIL, Try<A>>, MTry<A>, Try<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTry<A>).Return(a)
                        : default(MTry<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Try&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Validation<FAIL, Try<A>> PlusT<NUM, FAIL, A>(this Validation<FAIL, Try<A>> x, Validation<FAIL, Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Try&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Validation<FAIL, Try<A>> SubtractT<NUM, FAIL, A>(this Validation<FAIL, Try<A>> x, Validation<FAIL, Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Try&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Validation<FAIL, Try<A>> ProductT<NUM, FAIL, A>(this Validation<FAIL, Try<A>> x, Validation<FAIL, Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Try&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Validation<FAIL, Try<A>> DivideT<NUM, FAIL, A>(this Validation<FAIL, Try<A>> x, Validation<FAIL, Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Try&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Validation<FAIL, Try<A>> AppendT<SEMI, FAIL, A>(this Validation<FAIL, Try<A>> x, Validation<FAIL, Try<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, FAIL, A>(this Validation<FAIL, Try<A>> x, Validation<FAIL, Try<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Try&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, FAIL, A>(this Validation<FAIL, Try<A>> x, Validation<FAIL, Try<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Validation&lt;FAIL, Try&lt;A&gt;&gt;`</param>
        /// <returns>`Validation&lt;FAIL, Try&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Validation<FAIL, Try<B>> ApplyT<FAIL, A, B>(this Func<A, B> fab, Validation<FAIL, Try<A>> fa) =>
            ApplValidation<FAIL, Try<A>, Try<B>>.Inst.Apply(
                 MValidation<FAIL, Func<Try<A>, Try<B>>>.Inst.Return((Try<A> a) => ApplTry< A, B>.Inst.Apply(
                     MTry< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Validation&lt;FAIL, Try&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Validation&lt;FAIL, Try&lt;A&gt;&gt;`</param>
        /// <returns>`Validation&lt;FAIL, Try&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Validation<FAIL, Try<C>> ApplyT<FAIL, A, B, C>(this Func<A, B, C> fabc, Validation<FAIL, Try<A>> fa, Validation<FAIL, Try<B>> fb) =>
            ApplValidation<FAIL, Try<A>, Try<B>, Try<C>>.Inst.Apply(
                MValidation<FAIL, Func<Try<A>, Func<Try<B>, Try<C>>>>.Inst.Return(
                    (Try<A> a) =>
                        (Try<B> b) =>
                            ApplTry< A, B, C>.Inst.Apply(
                                MTry< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    /// <summary>
    /// Monad transformer for TryOption, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class TryOptionT_Extensions
    {
        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Arr&lt;TryOption&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<TryOption<C>> SelectMany< A, B, C>(
            this Arr<TryOption<A>> ma,
            Func<A, Arr<TryOption<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MArr<TryOption<C>>, Arr<TryOption<C>>, MTryOption<C>, TryOption<C>, C>(ma, a =>
                    SeqTrans<MArr<TryOption<B>>, Arr<TryOption<B>>, MTryOption<B>, TryOption<B>, B>
                        .Inst.Bind<MArr<TryOption<C>>, Arr<TryOption<C>>, MTryOption<C>, TryOption<C>, C>(bind(a), b =>
                            default(MTryOption<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;TryOption&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<TryOption<A>> Where< A>(this Arr<TryOption<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<TryOption<B>> Select< A, B>(this Arr<TryOption<A>> ma, Func<A, B> f) =>
            SeqTrans<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MArr<TryOption<B>>, Arr<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Arr&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryOption&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Arr&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Arr<TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Arr&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryOption&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Arr&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Arr<TryOption<A>> ma) =>
            SeqTrans<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<TryOption<B>> BindT< A, B>(this Arr<TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            SeqTrans<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MArr<TryOption<B>>, Arr<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<TryOption<B>> BindT< A, B>(this Arr<TryOption<A>> ma, Func<A, Arr<TryOption<B>>> f) =>
            SeqTrans<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MArr<TryOption<B>>, Arr<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Arr&lt;TryOption&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOption&lt;Arr&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;Arr&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryOption<Arr<B>> Traverse< A, B>(this Arr<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<Arr<B>>, TryOption<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Arr&lt;TryOption&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOption&lt;Arr&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static TryOption<Arr<A>> Sequence< A>(this Arr<TryOption<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<TryOption<B>> MapT< A, B>(this Arr<TryOption<A>> ma, Func<A, B> f) =>
            SeqTrans<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MArr<TryOption<B>>, Arr<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Arr<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Arr<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Arr<TryOption<A>> ma, Func<A, bool> f) =>
            SeqTrans<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Arr<TryOption<A>> ma, Func<A, bool> f) =>
            SeqTrans<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Arr&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Arr<TryOption<A>> ma, Action<A> f) =>
            SeqTrans<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;TryOption&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<TryOption<A>> FilterT< A>(this Arr<TryOption<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MArr<TryOption<A>>, Arr<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;TryOption&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Arr<TryOption<A>> PlusT<NUM,  A>(this Arr<TryOption<A>> x, Arr<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;TryOption&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Arr<TryOption<A>> SubtractT<NUM,  A>(this Arr<TryOption<A>> x, Arr<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Arr<TryOption<A>> ProductT<NUM,  A>(this Arr<TryOption<A>> x, Arr<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Arr<TryOption<A>> DivideT<NUM,  A>(this Arr<TryOption<A>> x, Arr<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Arr<TryOption<A>> AppendT<SEMI,  A>(this Arr<TryOption<A>> x, Arr<TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Arr<TryOption<A>> x, Arr<TryOption<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Arr<TryOption<A>> x, Arr<TryOption<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Arr&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <returns>`Arr&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Arr<TryOption<B>> ApplyT< A, B>(this Func<A, B> fab, Arr<TryOption<A>> fa) =>
            ApplArr< TryOption<A>, TryOption<B>>.Inst.Apply(
                 MArr< Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => ApplTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Arr&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Arr&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <returns>`Arr&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Arr<TryOption<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Arr<TryOption<A>> fa, Arr<TryOption<B>> fb) =>
            ApplArr< TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MArr< Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            ApplTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`HashSet&lt;TryOption&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<TryOption<C>> SelectMany< A, B, C>(
            this HashSet<TryOption<A>> ma,
            Func<A, HashSet<TryOption<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MHashSet<TryOption<C>>, HashSet<TryOption<C>>, MTryOption<C>, TryOption<C>, C>(ma, a =>
                    SeqTrans<MHashSet<TryOption<B>>, HashSet<TryOption<B>>, MTryOption<B>, TryOption<B>, B>
                        .Inst.Bind<MHashSet<TryOption<C>>, HashSet<TryOption<C>>, MTryOption<C>, TryOption<C>, C>(bind(a), b =>
                            default(MTryOption<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;TryOption&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<TryOption<A>> Where< A>(this HashSet<TryOption<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<TryOption<B>> Select< A, B>(this HashSet<TryOption<A>> ma, Func<A, B> f) =>
            SeqTrans<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MHashSet<TryOption<B>>, HashSet<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `HashSet&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryOption&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `HashSet&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this HashSet<TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `HashSet&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryOption&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `HashSet&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this HashSet<TryOption<A>> ma) =>
            SeqTrans<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<TryOption<B>> BindT< A, B>(this HashSet<TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            SeqTrans<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MHashSet<TryOption<B>>, HashSet<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<TryOption<B>> BindT< A, B>(this HashSet<TryOption<A>> ma, Func<A, HashSet<TryOption<B>>> f) =>
            SeqTrans<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MHashSet<TryOption<B>>, HashSet<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `HashSet&lt;TryOption&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOption&lt;HashSet&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;HashSet&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryOption<HashSet<B>> Traverse< A, B>(this HashSet<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<HashSet<B>>, TryOption<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `HashSet&lt;TryOption&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOption&lt;HashSet&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static TryOption<HashSet<A>> Sequence< A>(this HashSet<TryOption<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<TryOption<B>> MapT< A, B>(this HashSet<TryOption<A>> ma, Func<A, B> f) =>
            SeqTrans<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MHashSet<TryOption<B>>, HashSet<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this HashSet<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this HashSet<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this HashSet<TryOption<A>> ma, Func<A, bool> f) =>
            SeqTrans<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this HashSet<TryOption<A>> ma, Func<A, bool> f) =>
            SeqTrans<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `HashSet&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this HashSet<TryOption<A>> ma, Action<A> f) =>
            SeqTrans<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;TryOption&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<TryOption<A>> FilterT< A>(this HashSet<TryOption<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MHashSet<TryOption<A>>, HashSet<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;TryOption&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<TryOption<A>> PlusT<NUM,  A>(this HashSet<TryOption<A>> x, HashSet<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;TryOption&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<TryOption<A>> SubtractT<NUM,  A>(this HashSet<TryOption<A>> x, HashSet<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static HashSet<TryOption<A>> ProductT<NUM,  A>(this HashSet<TryOption<A>> x, HashSet<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static HashSet<TryOption<A>> DivideT<NUM,  A>(this HashSet<TryOption<A>> x, HashSet<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static HashSet<TryOption<A>> AppendT<SEMI,  A>(this HashSet<TryOption<A>> x, HashSet<TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this HashSet<TryOption<A>> x, HashSet<TryOption<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this HashSet<TryOption<A>> x, HashSet<TryOption<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `HashSet&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <returns>`HashSet&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static HashSet<TryOption<B>> ApplyT< A, B>(this Func<A, B> fab, HashSet<TryOption<A>> fa) =>
            ApplHashSet< TryOption<A>, TryOption<B>>.Inst.Apply(
                 MHashSet< Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => ApplTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `HashSet&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `HashSet&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <returns>`HashSet&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static HashSet<TryOption<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, HashSet<TryOption<A>> fa, HashSet<TryOption<B>> fb) =>
            ApplHashSet< TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MHashSet< Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            ApplTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Lst&lt;TryOption&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<TryOption<C>> SelectMany< A, B, C>(
            this Lst<TryOption<A>> ma,
            Func<A, Lst<TryOption<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MLst<TryOption<C>>, Lst<TryOption<C>>, MTryOption<C>, TryOption<C>, C>(ma, a =>
                    SeqTrans<MLst<TryOption<B>>, Lst<TryOption<B>>, MTryOption<B>, TryOption<B>, B>
                        .Inst.Bind<MLst<TryOption<C>>, Lst<TryOption<C>>, MTryOption<C>, TryOption<C>, C>(bind(a), b =>
                            default(MTryOption<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;TryOption&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<TryOption<A>> Where< A>(this Lst<TryOption<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<TryOption<B>> Select< A, B>(this Lst<TryOption<A>> ma, Func<A, B> f) =>
            SeqTrans<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MLst<TryOption<B>>, Lst<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Lst&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryOption&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Lst&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Lst<TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Lst&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryOption&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Lst&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Lst<TryOption<A>> ma) =>
            SeqTrans<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<TryOption<B>> BindT< A, B>(this Lst<TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            SeqTrans<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MLst<TryOption<B>>, Lst<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<TryOption<B>> BindT< A, B>(this Lst<TryOption<A>> ma, Func<A, Lst<TryOption<B>>> f) =>
            SeqTrans<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MLst<TryOption<B>>, Lst<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Lst&lt;TryOption&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOption&lt;Lst&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;Lst&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryOption<Lst<B>> Traverse< A, B>(this Lst<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<Lst<B>>, TryOption<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Lst&lt;TryOption&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOption&lt;Lst&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static TryOption<Lst<A>> Sequence< A>(this Lst<TryOption<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<TryOption<B>> MapT< A, B>(this Lst<TryOption<A>> ma, Func<A, B> f) =>
            SeqTrans<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MLst<TryOption<B>>, Lst<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Lst<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Lst<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Lst<TryOption<A>> ma, Func<A, bool> f) =>
            SeqTrans<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Lst<TryOption<A>> ma, Func<A, bool> f) =>
            SeqTrans<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Lst&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Lst<TryOption<A>> ma, Action<A> f) =>
            SeqTrans<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;TryOption&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<TryOption<A>> FilterT< A>(this Lst<TryOption<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MLst<TryOption<A>>, Lst<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;TryOption&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Lst<TryOption<A>> PlusT<NUM,  A>(this Lst<TryOption<A>> x, Lst<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;TryOption&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Lst<TryOption<A>> SubtractT<NUM,  A>(this Lst<TryOption<A>> x, Lst<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Lst<TryOption<A>> ProductT<NUM,  A>(this Lst<TryOption<A>> x, Lst<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Lst<TryOption<A>> DivideT<NUM,  A>(this Lst<TryOption<A>> x, Lst<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Lst<TryOption<A>> AppendT<SEMI,  A>(this Lst<TryOption<A>> x, Lst<TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Lst<TryOption<A>> x, Lst<TryOption<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Lst<TryOption<A>> x, Lst<TryOption<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Lst&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <returns>`Lst&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Lst<TryOption<B>> ApplyT< A, B>(this Func<A, B> fab, Lst<TryOption<A>> fa) =>
            ApplLst< TryOption<A>, TryOption<B>>.Inst.Apply(
                 MLst< Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => ApplTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Lst&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Lst&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <returns>`Lst&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Lst<TryOption<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Lst<TryOption<A>> fa, Lst<TryOption<B>> fb) =>
            ApplLst< TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MLst< Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            ApplTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Option&lt;TryOption&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Option<TryOption<C>> SelectMany< A, B, C>(
            this Option<TryOption<A>> ma,
            Func<A, Option<TryOption<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MOption<TryOption<C>>, Option<TryOption<C>>, MTryOption<C>, TryOption<C>, C>(ma, a =>
                    Trans<MOption<TryOption<B>>, Option<TryOption<B>>, MTryOption<B>, TryOption<B>, B>
                        .Inst.Bind<MOption<TryOption<C>>, Option<TryOption<C>>, MTryOption<C>, TryOption<C>, C>(bind(a), b =>
                            default(MTryOption<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;TryOption&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<TryOption<A>> Where< A>(this Option<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<TryOption<B>> Select< A, B>(this Option<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MOption<TryOption<B>>, Option<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Option&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryOption&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Option&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Option<TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Option&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryOption&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Option&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Option<TryOption<A>> ma) =>
            Trans<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<TryOption<B>> BindT< A, B>(this Option<TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            Trans<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MOption<TryOption<B>>, Option<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<TryOption<B>> BindT< A, B>(this Option<TryOption<A>> ma, Func<A, Option<TryOption<B>>> f) =>
            Trans<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MOption<TryOption<B>>, Option<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Option&lt;TryOption&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOption&lt;Option&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;Option&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryOption<Option<B>> Traverse< A, B>(this Option<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<Option<B>>, TryOption<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Option&lt;TryOption&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOption&lt;Option&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static TryOption<Option<A>> Sequence< A>(this Option<TryOption<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<TryOption<B>> MapT< A, B>(this Option<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MOption<TryOption<B>>, Option<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Option<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Option<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Option<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Option<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Option&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Option<TryOption<A>> ma, Action<A> f) =>
            Trans<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;TryOption&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<TryOption<A>> FilterT< A>(this Option<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MOption<TryOption<A>>, Option<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;TryOption&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Option<TryOption<A>> PlusT<NUM,  A>(this Option<TryOption<A>> x, Option<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;TryOption&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Option<TryOption<A>> SubtractT<NUM,  A>(this Option<TryOption<A>> x, Option<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Option<TryOption<A>> ProductT<NUM,  A>(this Option<TryOption<A>> x, Option<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Option<TryOption<A>> DivideT<NUM,  A>(this Option<TryOption<A>> x, Option<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Option<TryOption<A>> AppendT<SEMI,  A>(this Option<TryOption<A>> x, Option<TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Option<TryOption<A>> x, Option<TryOption<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Option<TryOption<A>> x, Option<TryOption<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Option&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <returns>`Option&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Option<TryOption<B>> ApplyT< A, B>(this Func<A, B> fab, Option<TryOption<A>> fa) =>
            ApplOption< TryOption<A>, TryOption<B>>.Inst.Apply(
                 MOption< Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => ApplTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Option&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Option&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <returns>`Option&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Option<TryOption<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Option<TryOption<A>> fa, Option<TryOption<B>> fb) =>
            ApplOption< TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MOption< Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            ApplTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionUnsafe&lt;TryOption&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<TryOption<C>> SelectMany< A, B, C>(
            this OptionUnsafe<TryOption<A>> ma,
            Func<A, OptionUnsafe<TryOption<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MOptionUnsafe<TryOption<C>>, OptionUnsafe<TryOption<C>>, MTryOption<C>, TryOption<C>, C>(ma, a =>
                    Trans<MOptionUnsafe<TryOption<B>>, OptionUnsafe<TryOption<B>>, MTryOption<B>, TryOption<B>, B>
                        .Inst.Bind<MOptionUnsafe<TryOption<C>>, OptionUnsafe<TryOption<C>>, MTryOption<C>, TryOption<C>, C>(bind(a), b =>
                            default(MTryOption<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;TryOption&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<TryOption<A>> Where< A>(this OptionUnsafe<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<TryOption<B>> Select< A, B>(this OptionUnsafe<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MOptionUnsafe<TryOption<B>>, OptionUnsafe<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionUnsafe&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryOption&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionUnsafe&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this OptionUnsafe<TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionUnsafe&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryOption&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionUnsafe&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this OptionUnsafe<TryOption<A>> ma) =>
            Trans<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<TryOption<B>> BindT< A, B>(this OptionUnsafe<TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            Trans<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MOptionUnsafe<TryOption<B>>, OptionUnsafe<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<TryOption<B>> BindT< A, B>(this OptionUnsafe<TryOption<A>> ma, Func<A, OptionUnsafe<TryOption<B>>> f) =>
            Trans<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MOptionUnsafe<TryOption<B>>, OptionUnsafe<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionUnsafe&lt;TryOption&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOption&lt;OptionUnsafe&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;OptionUnsafe&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryOption<OptionUnsafe<B>> Traverse< A, B>(this OptionUnsafe<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<OptionUnsafe<B>>, TryOption<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionUnsafe&lt;TryOption&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOption&lt;OptionUnsafe&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static TryOption<OptionUnsafe<A>> Sequence< A>(this OptionUnsafe<TryOption<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<TryOption<B>> MapT< A, B>(this OptionUnsafe<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MOptionUnsafe<TryOption<B>>, OptionUnsafe<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this OptionUnsafe<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this OptionUnsafe<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this OptionUnsafe<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this OptionUnsafe<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionUnsafe&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this OptionUnsafe<TryOption<A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;TryOption&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<TryOption<A>> FilterT< A>(this OptionUnsafe<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MOptionUnsafe<TryOption<A>>, OptionUnsafe<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;TryOption&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<TryOption<A>> PlusT<NUM,  A>(this OptionUnsafe<TryOption<A>> x, OptionUnsafe<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;TryOption&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<TryOption<A>> SubtractT<NUM,  A>(this OptionUnsafe<TryOption<A>> x, OptionUnsafe<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionUnsafe<TryOption<A>> ProductT<NUM,  A>(this OptionUnsafe<TryOption<A>> x, OptionUnsafe<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionUnsafe<TryOption<A>> DivideT<NUM,  A>(this OptionUnsafe<TryOption<A>> x, OptionUnsafe<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionUnsafe<TryOption<A>> AppendT<SEMI,  A>(this OptionUnsafe<TryOption<A>> x, OptionUnsafe<TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this OptionUnsafe<TryOption<A>> x, OptionUnsafe<TryOption<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this OptionUnsafe<TryOption<A>> x, OptionUnsafe<TryOption<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <returns>`OptionUnsafe&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionUnsafe<TryOption<B>> ApplyT< A, B>(this Func<A, B> fab, OptionUnsafe<TryOption<A>> fa) =>
            ApplOptionUnsafe< TryOption<A>, TryOption<B>>.Inst.Apply(
                 MOptionUnsafe< Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => ApplTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `OptionUnsafe&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <returns>`OptionUnsafe&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionUnsafe<TryOption<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, OptionUnsafe<TryOption<A>> fa, OptionUnsafe<TryOption<B>> fb) =>
            ApplOptionUnsafe< TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MOptionUnsafe< Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            ApplTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Either&lt;L, TryOption&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, TryOption<C>> SelectMany<L, A, B, C>(
            this Either<L, TryOption<A>> ma,
            Func<A, Either<L, TryOption<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MEither<L, TryOption<C>>, Either<L, TryOption<C>>, MTryOption<C>, TryOption<C>, C>(ma, a =>
                    Trans<MEither<L, TryOption<B>>, Either<L, TryOption<B>>, MTryOption<B>, TryOption<B>, B>
                        .Inst.Bind<MEither<L, TryOption<C>>, Either<L, TryOption<C>>, MTryOption<C>, TryOption<C>, C>(bind(a), b =>
                            default(MTryOption<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, TryOption&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, TryOption<A>> Where<L, A>(this Either<L, TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, TryOption<B>> Select<L, A, B>(this Either<L, TryOption<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MEither<L, TryOption<B>>, Either<L, TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Either&lt;L, TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryOption&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Either&lt;L, TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Either<L, TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Either&lt;L, TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryOption&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Either&lt;L, TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this Either<L, TryOption<A>> ma) =>
            Trans<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either&lt;L, TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, TryOption<B>> BindT<L, A, B>(this Either<L, TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            Trans<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MEither<L, TryOption<B>>, Either<L, TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either&lt;L, TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, TryOption<B>> BindT<L, A, B>(this Either<L, TryOption<A>> ma, Func<A, Either<L, TryOption<B>>> f) =>
            Trans<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MEither<L, TryOption<B>>, Either<L, TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Either&lt;L, TryOption&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOption&lt;Either&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;Either&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static TryOption<Either<L, B>> Traverse<L, A, B>(this Either<L, TryOption<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<Either<L, B>>, TryOption<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Either&lt;L, TryOption&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOption&lt;Either&lt;L, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static TryOption<Either<L, A>> Sequence<L, A>(this Either<L, TryOption<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, TryOption<B>> MapT<L, A, B>(this Either<L, TryOption<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MEither<L, TryOption<B>>, Either<L, TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Either<L, TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Either<L, TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Either<L, TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Either<L, TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Either&lt;L, TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Either<L, TryOption<A>> ma, Action<A> f) =>
            Trans<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, TryOption&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, TryOption<A>> FilterT<L, A>(this Either<L, TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MEither<L, TryOption<A>>, Either<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, TryOption&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, TryOption<A>> PlusT<NUM, L, A>(this Either<L, TryOption<A>> x, Either<L, TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, TryOption&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, TryOption<A>> SubtractT<NUM, L, A>(this Either<L, TryOption<A>> x, Either<L, TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, TryOption&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Either<L, TryOption<A>> ProductT<NUM, L, A>(this Either<L, TryOption<A>> x, Either<L, TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, TryOption&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Either<L, TryOption<A>> DivideT<NUM, L, A>(this Either<L, TryOption<A>> x, Either<L, TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, TryOption&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Either<L, TryOption<A>> AppendT<SEMI, L, A>(this Either<L, TryOption<A>> x, Either<L, TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Either<L, TryOption<A>> x, Either<L, TryOption<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, TryOption&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Either<L, TryOption<A>> x, Either<L, TryOption<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Either&lt;L, TryOption&lt;A&gt;&gt;`</param>
        /// <returns>`Either&lt;L, TryOption&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Either<L, TryOption<B>> ApplyT<L, A, B>(this Func<A, B> fab, Either<L, TryOption<A>> fa) =>
            ApplEither<L, TryOption<A>, TryOption<B>>.Inst.Apply(
                 MEither<L, Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => ApplTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Either&lt;L, TryOption&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Either&lt;L, TryOption&lt;A&gt;&gt;`</param>
        /// <returns>`Either&lt;L, TryOption&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Either<L, TryOption<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Either<L, TryOption<A>> fa, Either<L, TryOption<B>> fb) =>
            ApplEither<L, TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MEither<L, Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            ApplTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`EitherUnsafe&lt;L, TryOption&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, TryOption<A>> ma,
            Func<A, EitherUnsafe<L, TryOption<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MEitherUnsafe<L, TryOption<C>>, EitherUnsafe<L, TryOption<C>>, MTryOption<C>, TryOption<C>, C>(ma, a =>
                    Trans<MEitherUnsafe<L, TryOption<B>>, EitherUnsafe<L, TryOption<B>>, MTryOption<B>, TryOption<B>, B>
                        .Inst.Bind<MEitherUnsafe<L, TryOption<C>>, EitherUnsafe<L, TryOption<C>>, MTryOption<C>, TryOption<C>, C>(bind(a), b =>
                            default(MTryOption<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, TryOption&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<A>> Where<L, A>(this EitherUnsafe<L, TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<B>> Select<L, A, B>(this EitherUnsafe<L, TryOption<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MEitherUnsafe<L, TryOption<B>>, EitherUnsafe<L, TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherUnsafe&lt;L, TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryOption&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherUnsafe&lt;L, TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this EitherUnsafe<L, TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherUnsafe&lt;L, TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryOption&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherUnsafe&lt;L, TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this EitherUnsafe<L, TryOption<A>> ma) =>
            Trans<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<B>> BindT<L, A, B>(this EitherUnsafe<L, TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            Trans<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MEitherUnsafe<L, TryOption<B>>, EitherUnsafe<L, TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<B>> BindT<L, A, B>(this EitherUnsafe<L, TryOption<A>> ma, Func<A, EitherUnsafe<L, TryOption<B>>> f) =>
            Trans<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MEitherUnsafe<L, TryOption<B>>, EitherUnsafe<L, TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `EitherUnsafe&lt;L, TryOption&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOption&lt;EitherUnsafe&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;EitherUnsafe&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, B>> Traverse<L, A, B>(this EitherUnsafe<L, TryOption<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<EitherUnsafe<L, B>>, TryOption<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `EitherUnsafe&lt;L, TryOption&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOption&lt;EitherUnsafe&lt;L, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static TryOption<EitherUnsafe<L, A>> Sequence<L, A>(this EitherUnsafe<L, TryOption<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<B>> MapT<L, A, B>(this EitherUnsafe<L, TryOption<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MEitherUnsafe<L, TryOption<B>>, EitherUnsafe<L, TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this EitherUnsafe<L, TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this EitherUnsafe<L, TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this EitherUnsafe<L, TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this EitherUnsafe<L, TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherUnsafe&lt;L, TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this EitherUnsafe<L, TryOption<A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, TryOption&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<A>> FilterT<L, A>(this EitherUnsafe<L, TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MEitherUnsafe<L, TryOption<A>>, EitherUnsafe<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, TryOption&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<A>> PlusT<NUM, L, A>(this EitherUnsafe<L, TryOption<A>> x, EitherUnsafe<L, TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, TryOption&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<A>> SubtractT<NUM, L, A>(this EitherUnsafe<L, TryOption<A>> x, EitherUnsafe<L, TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, TryOption&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<A>> ProductT<NUM, L, A>(this EitherUnsafe<L, TryOption<A>> x, EitherUnsafe<L, TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, TryOption&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<A>> DivideT<NUM, L, A>(this EitherUnsafe<L, TryOption<A>> x, EitherUnsafe<L, TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, TryOption&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<A>> AppendT<SEMI, L, A>(this EitherUnsafe<L, TryOption<A>> x, EitherUnsafe<L, TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this EitherUnsafe<L, TryOption<A>> x, EitherUnsafe<L, TryOption<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, TryOption&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this EitherUnsafe<L, TryOption<A>> x, EitherUnsafe<L, TryOption<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe&lt;L, TryOption&lt;A&gt;&gt;`</param>
        /// <returns>`EitherUnsafe&lt;L, TryOption&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherUnsafe<L, TryOption<A>> fa) =>
            ApplEitherUnsafe<L, TryOption<A>, TryOption<B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => ApplTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe&lt;L, TryOption&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `EitherUnsafe&lt;L, TryOption&lt;A&gt;&gt;`</param>
        /// <returns>`EitherUnsafe&lt;L, TryOption&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherUnsafe<L, TryOption<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherUnsafe<L, TryOption<A>> fa, EitherUnsafe<L, TryOption<B>> fb) =>
            ApplEitherUnsafe<L, TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MEitherUnsafe<L, Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            ApplTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Try&lt;TryOption&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Try<TryOption<C>> SelectMany< A, B, C>(
            this Try<TryOption<A>> ma,
            Func<A, Try<TryOption<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MTry<TryOption<C>>, Try<TryOption<C>>, MTryOption<C>, TryOption<C>, C>(ma, a =>
                    Trans<MTry<TryOption<B>>, Try<TryOption<B>>, MTryOption<B>, TryOption<B>, B>
                        .Inst.Bind<MTry<TryOption<C>>, Try<TryOption<C>>, MTryOption<C>, TryOption<C>, C>(bind(a), b =>
                            default(MTryOption<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;TryOption&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<TryOption<A>> Where< A>(this Try<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<TryOption<B>> Select< A, B>(this Try<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MTry<TryOption<B>>, Try<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Try&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryOption&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Try&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Try<TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Try&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryOption&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Try&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Try<TryOption<A>> ma) =>
            Trans<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<TryOption<B>> BindT< A, B>(this Try<TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            Trans<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MTry<TryOption<B>>, Try<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<TryOption<B>> BindT< A, B>(this Try<TryOption<A>> ma, Func<A, Try<TryOption<B>>> f) =>
            Trans<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MTry<TryOption<B>>, Try<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Try&lt;TryOption&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOption&lt;Try&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;Try&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryOption<Try<B>> Traverse< A, B>(this Try<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<Try<B>>, TryOption<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Try&lt;TryOption&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOption&lt;Try&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static TryOption<Try<A>> Sequence< A>(this Try<TryOption<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<TryOption<B>> MapT< A, B>(this Try<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MTry<TryOption<B>>, Try<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Try<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Try<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Try<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Try<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Try&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Try<TryOption<A>> ma, Action<A> f) =>
            Trans<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;TryOption&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<TryOption<A>> FilterT< A>(this Try<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MTry<TryOption<A>>, Try<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;TryOption&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Try<TryOption<A>> PlusT<NUM,  A>(this Try<TryOption<A>> x, Try<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;TryOption&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Try<TryOption<A>> SubtractT<NUM,  A>(this Try<TryOption<A>> x, Try<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Try<TryOption<A>> ProductT<NUM,  A>(this Try<TryOption<A>> x, Try<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Try<TryOption<A>> DivideT<NUM,  A>(this Try<TryOption<A>> x, Try<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Try<TryOption<A>> AppendT<SEMI,  A>(this Try<TryOption<A>> x, Try<TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Try<TryOption<A>> x, Try<TryOption<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Try<TryOption<A>> x, Try<TryOption<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Try&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <returns>`Try&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Try<TryOption<B>> ApplyT< A, B>(this Func<A, B> fab, Try<TryOption<A>> fa) =>
            ApplTry< TryOption<A>, TryOption<B>>.Inst.Apply(
                 MTry< Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => ApplTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Try&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Try&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <returns>`Try&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Try<TryOption<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Try<TryOption<A>> fa, Try<TryOption<B>> fb) =>
            ApplTry< TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MTry< Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            ApplTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOption&lt;TryOption&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<TryOption<C>> SelectMany< A, B, C>(
            this TryOption<TryOption<A>> ma,
            Func<A, TryOption<TryOption<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MTryOption<TryOption<C>>, TryOption<TryOption<C>>, MTryOption<C>, TryOption<C>, C>(ma, a =>
                    Trans<MTryOption<TryOption<B>>, TryOption<TryOption<B>>, MTryOption<B>, TryOption<B>, B>
                        .Inst.Bind<MTryOption<TryOption<C>>, TryOption<TryOption<C>>, MTryOption<C>, TryOption<C>, C>(bind(a), b =>
                            default(MTryOption<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;TryOption&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<TryOption<A>> Where< A>(this TryOption<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<TryOption<B>> Select< A, B>(this TryOption<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MTryOption<TryOption<B>>, TryOption<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOption&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryOption&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOption&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryOption<TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOption&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryOption&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOption&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this TryOption<TryOption<A>> ma) =>
            Trans<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<TryOption<B>> BindT< A, B>(this TryOption<TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            Trans<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MTryOption<TryOption<B>>, TryOption<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<TryOption<B>> BindT< A, B>(this TryOption<TryOption<A>> ma, Func<A, TryOption<TryOption<B>>> f) =>
            Trans<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MTryOption<TryOption<B>>, TryOption<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOption&lt;TryOption&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOption&lt;TryOption&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;TryOption&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryOption<TryOption<B>> Traverse< A, B>(this TryOption<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<TryOption<B>>, TryOption<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOption&lt;TryOption&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOption&lt;TryOption&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static TryOption<TryOption<A>> Sequence< A>(this TryOption<TryOption<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<TryOption<B>> MapT< A, B>(this TryOption<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MTryOption<TryOption<B>>, TryOption<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryOption<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryOption<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryOption<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryOption<TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOption&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryOption<TryOption<A>> ma, Action<A> f) =>
            Trans<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;TryOption&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<TryOption<A>> FilterT< A>(this TryOption<TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MTryOption<TryOption<A>>, TryOption<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;TryOption&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<TryOption<A>> PlusT<NUM,  A>(this TryOption<TryOption<A>> x, TryOption<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;TryOption&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<TryOption<A>> SubtractT<NUM,  A>(this TryOption<TryOption<A>> x, TryOption<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOption<TryOption<A>> ProductT<NUM,  A>(this TryOption<TryOption<A>> x, TryOption<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOption<TryOption<A>> DivideT<NUM,  A>(this TryOption<TryOption<A>> x, TryOption<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOption<TryOption<A>> AppendT<SEMI,  A>(this TryOption<TryOption<A>> x, TryOption<TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryOption<TryOption<A>> x, TryOption<TryOption<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryOption<TryOption<A>> x, TryOption<TryOption<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOption&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <returns>`TryOption&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOption<TryOption<B>> ApplyT< A, B>(this Func<A, B> fab, TryOption<TryOption<A>> fa) =>
            ApplTryOption< TryOption<A>, TryOption<B>>.Inst.Apply(
                 MTryOption< Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => ApplTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOption&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryOption&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <returns>`TryOption&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOption<TryOption<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOption<TryOption<A>> fa, TryOption<TryOption<B>> fb) =>
            ApplTryOption< TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MTryOption< Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            ApplTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`IEnumerable&lt;TryOption&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<TryOption<C>> SelectMany< A, B, C>(
            this IEnumerable<TryOption<A>> ma,
            Func<A, IEnumerable<TryOption<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MEnumerable<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MEnumerable<TryOption<C>>, IEnumerable<TryOption<C>>, MTryOption<C>, TryOption<C>, C>(ma, a =>
                    SeqTrans<MEnumerable<TryOption<B>>, IEnumerable<TryOption<B>>, MTryOption<B>, TryOption<B>, B>
                        .Inst.Bind<MEnumerable<TryOption<C>>, IEnumerable<TryOption<C>>, MTryOption<C>, TryOption<C>, C>(bind(a), b =>
                            default(MTryOption<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;TryOption&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<TryOption<A>> Where< A>(this IEnumerable<TryOption<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MEnumerable<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MEnumerable<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<TryOption<B>> Select< A, B>(this IEnumerable<TryOption<A>> ma, Func<A, B> f) =>
            SeqTrans<MEnumerable<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MEnumerable<TryOption<B>>, IEnumerable<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `IEnumerable&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryOption&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `IEnumerable&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this IEnumerable<TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MEnumerable<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `IEnumerable&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryOption&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `IEnumerable&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this IEnumerable<TryOption<A>> ma) =>
            SeqTrans<MEnumerable<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<TryOption<B>> BindT< A, B>(this IEnumerable<TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            SeqTrans<MEnumerable<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MEnumerable<TryOption<B>>, IEnumerable<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<TryOption<B>> BindT< A, B>(this IEnumerable<TryOption<A>> ma, Func<A, IEnumerable<TryOption<B>>> f) =>
            SeqTrans<MEnumerable<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MEnumerable<TryOption<B>>, IEnumerable<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `IEnumerable&lt;TryOption&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOption&lt;IEnumerable&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;IEnumerable&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryOption<IEnumerable<B>> Traverse< A, B>(this IEnumerable<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MEnumerable<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<IEnumerable<B>>, TryOption<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `IEnumerable&lt;TryOption&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOption&lt;IEnumerable&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static TryOption<IEnumerable<A>> Sequence< A>(this IEnumerable<TryOption<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<TryOption<B>> MapT< A, B>(this IEnumerable<TryOption<A>> ma, Func<A, B> f) =>
            SeqTrans<MEnumerable<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MEnumerable<TryOption<B>>, IEnumerable<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this IEnumerable<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MEnumerable<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this IEnumerable<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MEnumerable<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this IEnumerable<TryOption<A>> ma, Func<A, bool> f) =>
            SeqTrans<MEnumerable<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this IEnumerable<TryOption<A>> ma, Func<A, bool> f) =>
            SeqTrans<MEnumerable<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `IEnumerable&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this IEnumerable<TryOption<A>> ma, Action<A> f) =>
            SeqTrans<MEnumerable<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;TryOption&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<TryOption<A>> FilterT< A>(this IEnumerable<TryOption<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MEnumerable<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MEnumerable<TryOption<A>>, IEnumerable<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;TryOption&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<TryOption<A>> PlusT<NUM,  A>(this IEnumerable<TryOption<A>> x, IEnumerable<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;TryOption&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<TryOption<A>> SubtractT<NUM,  A>(this IEnumerable<TryOption<A>> x, IEnumerable<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static IEnumerable<TryOption<A>> ProductT<NUM,  A>(this IEnumerable<TryOption<A>> x, IEnumerable<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static IEnumerable<TryOption<A>> DivideT<NUM,  A>(this IEnumerable<TryOption<A>> x, IEnumerable<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static IEnumerable<TryOption<A>> AppendT<SEMI,  A>(this IEnumerable<TryOption<A>> x, IEnumerable<TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this IEnumerable<TryOption<A>> x, IEnumerable<TryOption<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this IEnumerable<TryOption<A>> x, IEnumerable<TryOption<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `IEnumerable&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <returns>`IEnumerable&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static IEnumerable<TryOption<B>> ApplyT< A, B>(this Func<A, B> fab, IEnumerable<TryOption<A>> fa) =>
            ApplEnumerable< TryOption<A>, TryOption<B>>.Inst.Apply(
                 MEnumerable< Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => ApplTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `IEnumerable&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `IEnumerable&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <returns>`IEnumerable&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static IEnumerable<TryOption<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, IEnumerable<TryOption<A>> fa, IEnumerable<TryOption<B>> fb) =>
            ApplEnumerable< TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MEnumerable< Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            ApplTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Seq&lt;TryOption&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Seq<TryOption<C>> SelectMany< A, B, C>(
            this Seq<TryOption<A>> ma,
            Func<A, Seq<TryOption<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MSeq<TryOption<A>>, Seq<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MSeq<TryOption<C>>, Seq<TryOption<C>>, MTryOption<C>, TryOption<C>, C>(ma, a =>
                    SeqTrans<MSeq<TryOption<B>>, Seq<TryOption<B>>, MTryOption<B>, TryOption<B>, B>
                        .Inst.Bind<MSeq<TryOption<C>>, Seq<TryOption<C>>, MTryOption<C>, TryOption<C>, C>(bind(a), b =>
                            default(MTryOption<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;TryOption&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<TryOption<A>> Where< A>(this Seq<TryOption<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSeq<TryOption<A>>, Seq<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MSeq<TryOption<A>>, Seq<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<TryOption<B>> Select< A, B>(this Seq<TryOption<A>> ma, Func<A, B> f) =>
            SeqTrans<MSeq<TryOption<A>>, Seq<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MSeq<TryOption<B>>, Seq<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Seq&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryOption&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Seq&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Seq<TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MSeq<TryOption<A>>, Seq<TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Seq&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryOption&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Seq&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Seq<TryOption<A>> ma) =>
            SeqTrans<MSeq<TryOption<A>>, Seq<TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Seq&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<TryOption<B>> BindT< A, B>(this Seq<TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            SeqTrans<MSeq<TryOption<A>>, Seq<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MSeq<TryOption<B>>, Seq<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Seq&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<TryOption<B>> BindT< A, B>(this Seq<TryOption<A>> ma, Func<A, Seq<TryOption<B>>> f) =>
            SeqTrans<MSeq<TryOption<A>>, Seq<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MSeq<TryOption<B>>, Seq<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Seq&lt;TryOption&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOption&lt;Seq&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;Seq&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryOption<Seq<B>> Traverse< A, B>(this Seq<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MSeq<TryOption<A>>, Seq<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<Seq<B>>, TryOption<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Seq&lt;TryOption&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOption&lt;Seq&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static TryOption<Seq<A>> Sequence< A>(this Seq<TryOption<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<TryOption<B>> MapT< A, B>(this Seq<TryOption<A>> ma, Func<A, B> f) =>
            SeqTrans<MSeq<TryOption<A>>, Seq<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MSeq<TryOption<B>>, Seq<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Seq<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSeq<TryOption<A>>, Seq<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Seq<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSeq<TryOption<A>>, Seq<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Seq<TryOption<A>> ma, Func<A, bool> f) =>
            SeqTrans<MSeq<TryOption<A>>, Seq<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Seq<TryOption<A>> ma, Func<A, bool> f) =>
            SeqTrans<MSeq<TryOption<A>>, Seq<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Seq&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Seq<TryOption<A>> ma, Action<A> f) =>
            SeqTrans<MSeq<TryOption<A>>, Seq<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;TryOption&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<TryOption<A>> FilterT< A>(this Seq<TryOption<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSeq<TryOption<A>>, Seq<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MSeq<TryOption<A>>, Seq<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;TryOption&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Seq<TryOption<A>> PlusT<NUM,  A>(this Seq<TryOption<A>> x, Seq<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;TryOption&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Seq<TryOption<A>> SubtractT<NUM,  A>(this Seq<TryOption<A>> x, Seq<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Seq<TryOption<A>> ProductT<NUM,  A>(this Seq<TryOption<A>> x, Seq<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Seq<TryOption<A>> DivideT<NUM,  A>(this Seq<TryOption<A>> x, Seq<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Seq<TryOption<A>> AppendT<SEMI,  A>(this Seq<TryOption<A>> x, Seq<TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Seq<TryOption<A>> x, Seq<TryOption<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Seq<TryOption<A>> x, Seq<TryOption<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Seq&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <returns>`Seq&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Seq<TryOption<B>> ApplyT< A, B>(this Func<A, B> fab, Seq<TryOption<A>> fa) =>
            ApplSeq< TryOption<A>, TryOption<B>>.Inst.Apply(
                 MSeq< Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => ApplTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Seq&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Seq&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <returns>`Seq&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Seq<TryOption<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Seq<TryOption<A>> fa, Seq<TryOption<B>> fb) =>
            ApplSeq< TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MSeq< Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            ApplTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Set&lt;TryOption&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Set<TryOption<C>> SelectMany< A, B, C>(
            this Set<TryOption<A>> ma,
            Func<A, Set<TryOption<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MSet<TryOption<C>>, Set<TryOption<C>>, MTryOption<C>, TryOption<C>, C>(ma, a =>
                    SeqTrans<MSet<TryOption<B>>, Set<TryOption<B>>, MTryOption<B>, TryOption<B>, B>
                        .Inst.Bind<MSet<TryOption<C>>, Set<TryOption<C>>, MTryOption<C>, TryOption<C>, C>(bind(a), b =>
                            default(MTryOption<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;TryOption&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<TryOption<A>> Where< A>(this Set<TryOption<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<TryOption<B>> Select< A, B>(this Set<TryOption<A>> ma, Func<A, B> f) =>
            SeqTrans<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MSet<TryOption<B>>, Set<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Set&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryOption&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Set&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Set<TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Set&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryOption&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Set&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Set<TryOption<A>> ma) =>
            SeqTrans<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<TryOption<B>> BindT< A, B>(this Set<TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            SeqTrans<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MSet<TryOption<B>>, Set<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<TryOption<B>> BindT< A, B>(this Set<TryOption<A>> ma, Func<A, Set<TryOption<B>>> f) =>
            SeqTrans<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MSet<TryOption<B>>, Set<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Set&lt;TryOption&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOption&lt;Set&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;Set&lt;B&gt;&gt;`</returns>
        [Pure]
        public static TryOption<Set<B>> Traverse< A, B>(this Set<TryOption<A>> ma, Func<A, B> f) =>
            Trans<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<Set<B>>, TryOption<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Set&lt;TryOption&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOption&lt;Set&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static TryOption<Set<A>> Sequence< A>(this Set<TryOption<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<TryOption<B>> MapT< A, B>(this Set<TryOption<A>> ma, Func<A, B> f) =>
            SeqTrans<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MSet<TryOption<B>>, Set<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Set<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Set<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Set<TryOption<A>> ma, Func<A, bool> f) =>
            SeqTrans<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Set<TryOption<A>> ma, Func<A, bool> f) =>
            SeqTrans<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Set&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Set<TryOption<A>> ma, Action<A> f) =>
            SeqTrans<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;TryOption&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<TryOption<A>> FilterT< A>(this Set<TryOption<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MSet<TryOption<A>>, Set<TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;TryOption&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Set<TryOption<A>> PlusT<NUM,  A>(this Set<TryOption<A>> x, Set<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;TryOption&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Set<TryOption<A>> SubtractT<NUM,  A>(this Set<TryOption<A>> x, Set<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Set<TryOption<A>> ProductT<NUM,  A>(this Set<TryOption<A>> x, Set<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Set<TryOption<A>> DivideT<NUM,  A>(this Set<TryOption<A>> x, Set<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Set<TryOption<A>> AppendT<SEMI,  A>(this Set<TryOption<A>> x, Set<TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Set<TryOption<A>> x, Set<TryOption<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Set<TryOption<A>> x, Set<TryOption<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Set&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <returns>`Set&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Set<TryOption<B>> ApplyT< A, B>(this Func<A, B> fab, Set<TryOption<A>> fa) =>
            ApplSet< TryOption<A>, TryOption<B>>.Inst.Apply(
                 MSet< Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => ApplTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Set&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Set&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <returns>`Set&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Set<TryOption<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Set<TryOption<A>> fa, Set<TryOption<B>> fb) =>
            ApplSet< TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MSet< Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            ApplTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Validation&lt;FAIL, TryOption&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Validation<FAIL, TryOption<C>> SelectMany<FAIL, A, B, C>(
            this Validation<FAIL, TryOption<A>> ma,
            Func<A, Validation<FAIL, TryOption<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MValidation<FAIL, TryOption<A>>, Validation<FAIL, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MValidation<FAIL, TryOption<C>>, Validation<FAIL, TryOption<C>>, MTryOption<C>, TryOption<C>, C>(ma, a =>
                    Trans<MValidation<FAIL, TryOption<B>>, Validation<FAIL, TryOption<B>>, MTryOption<B>, TryOption<B>, B>
                        .Inst.Bind<MValidation<FAIL, TryOption<C>>, Validation<FAIL, TryOption<C>>, MTryOption<C>, TryOption<C>, C>(bind(a), b =>
                            default(MTryOption<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, TryOption&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, TryOption<A>> Where<FAIL, A>(this Validation<FAIL, TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MValidation<FAIL, TryOption<A>>, Validation<FAIL, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MValidation<FAIL, TryOption<A>>, Validation<FAIL, TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, TryOption<B>> Select<FAIL, A, B>(this Validation<FAIL, TryOption<A>> ma, Func<A, B> f) =>
            Trans<MValidation<FAIL, TryOption<A>>, Validation<FAIL, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MValidation<FAIL, TryOption<B>>, Validation<FAIL, TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Validation&lt;FAIL, TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryOption&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Validation&lt;FAIL, TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, FAIL, A>(this Validation<FAIL, TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MValidation<FAIL, TryOption<A>>, Validation<FAIL, TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Validation&lt;FAIL, TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryOption&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Validation&lt;FAIL, TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<FAIL, A>(this Validation<FAIL, TryOption<A>> ma) =>
            Trans<MValidation<FAIL, TryOption<A>>, Validation<FAIL, TryOption<A>>, MTryOption<A>, TryOption<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Validation&lt;FAIL, TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, TryOption<B>> BindT<FAIL, A, B>(this Validation<FAIL, TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            Trans<MValidation<FAIL, TryOption<A>>, Validation<FAIL, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MValidation<FAIL, TryOption<B>>, Validation<FAIL, TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Validation&lt;FAIL, TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, TryOption<B>> BindT<FAIL, A, B>(this Validation<FAIL, TryOption<A>> ma, Func<A, Validation<FAIL, TryOption<B>>> f) =>
            Trans<MValidation<FAIL, TryOption<A>>, Validation<FAIL, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MValidation<FAIL, TryOption<B>>, Validation<FAIL, TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Validation&lt;FAIL, TryOption&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOption&lt;Validation&lt;FAIL, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;Validation&lt;FAIL, B&gt;&gt;`</returns>
        [Pure]
        public static TryOption<Validation<FAIL, B>> Traverse<FAIL, A, B>(this Validation<FAIL, TryOption<A>> ma, Func<A, B> f) =>
            Trans<MValidation<FAIL, TryOption<A>>, Validation<FAIL, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Traverse<MTryOption<Validation<FAIL, B>>, TryOption<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Validation&lt;FAIL, TryOption&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `TryOption&lt;Validation&lt;FAIL, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<FAIL, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static TryOption<Validation<FAIL, A>> Sequence<FAIL, A>(this Validation<FAIL, TryOption<A>> ma) =>
            ma.Traverse<FAIL, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, TryOption<B>> MapT<FAIL, A, B>(this Validation<FAIL, TryOption<A>> ma, Func<A, B> f) =>
            Trans<MValidation<FAIL, TryOption<A>>, Validation<FAIL, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Map<MValidation<FAIL, TryOption<B>>, Validation<FAIL, TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, FAIL, A>(this Validation<FAIL, TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MValidation<FAIL, TryOption<A>>, Validation<FAIL, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, FAIL, A>(this Validation<FAIL, TryOption<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MValidation<FAIL, TryOption<A>>, Validation<FAIL, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<FAIL, A>(this Validation<FAIL, TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MValidation<FAIL, TryOption<A>>, Validation<FAIL, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<FAIL, A>(this Validation<FAIL, TryOption<A>> ma, Func<A, bool> f) =>
            Trans<MValidation<FAIL, TryOption<A>>, Validation<FAIL, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Validation&lt;FAIL, TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<FAIL, A>(this Validation<FAIL, TryOption<A>> ma, Action<A> f) =>
            Trans<MValidation<FAIL, TryOption<A>>, Validation<FAIL, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, TryOption&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, TryOption<A>> FilterT<FAIL, A>(this Validation<FAIL, TryOption<A>> ma, Func<A, bool> pred) =>
            Trans<MValidation<FAIL, TryOption<A>>, Validation<FAIL, TryOption<A>>, MTryOption<A>, TryOption<A>, A>
                .Inst.Bind<MValidation<FAIL, TryOption<A>>, Validation<FAIL, TryOption<A>>, MTryOption<A>, TryOption<A>, A>(ma, 
                    a => pred(a)
                        ? default(MTryOption<A>).Return(a)
                        : default(MTryOption<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, TryOption&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Validation<FAIL, TryOption<A>> PlusT<NUM, FAIL, A>(this Validation<FAIL, TryOption<A>> x, Validation<FAIL, TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, TryOption&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Validation<FAIL, TryOption<A>> SubtractT<NUM, FAIL, A>(this Validation<FAIL, TryOption<A>> x, Validation<FAIL, TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, TryOption&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Validation<FAIL, TryOption<A>> ProductT<NUM, FAIL, A>(this Validation<FAIL, TryOption<A>> x, Validation<FAIL, TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, TryOption&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Validation<FAIL, TryOption<A>> DivideT<NUM, FAIL, A>(this Validation<FAIL, TryOption<A>> x, Validation<FAIL, TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, TryOption&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Validation<FAIL, TryOption<A>> AppendT<SEMI, FAIL, A>(this Validation<FAIL, TryOption<A>> x, Validation<FAIL, TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, FAIL, A>(this Validation<FAIL, TryOption<A>> x, Validation<FAIL, TryOption<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, TryOption&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, FAIL, A>(this Validation<FAIL, TryOption<A>> x, Validation<FAIL, TryOption<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Validation&lt;FAIL, TryOption&lt;A&gt;&gt;`</param>
        /// <returns>`Validation&lt;FAIL, TryOption&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Validation<FAIL, TryOption<B>> ApplyT<FAIL, A, B>(this Func<A, B> fab, Validation<FAIL, TryOption<A>> fa) =>
            ApplValidation<FAIL, TryOption<A>, TryOption<B>>.Inst.Apply(
                 MValidation<FAIL, Func<TryOption<A>, TryOption<B>>>.Inst.Return((TryOption<A> a) => ApplTryOption< A, B>.Inst.Apply(
                     MTryOption< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Validation&lt;FAIL, TryOption&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Validation&lt;FAIL, TryOption&lt;A&gt;&gt;`</param>
        /// <returns>`Validation&lt;FAIL, TryOption&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Validation<FAIL, TryOption<C>> ApplyT<FAIL, A, B, C>(this Func<A, B, C> fabc, Validation<FAIL, TryOption<A>> fa, Validation<FAIL, TryOption<B>> fb) =>
            ApplValidation<FAIL, TryOption<A>, TryOption<B>, TryOption<C>>.Inst.Apply(
                MValidation<FAIL, Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>.Inst.Return(
                    (TryOption<A> a) =>
                        (TryOption<B> b) =>
                            ApplTryOption< A, B, C>.Inst.Apply(
                                MTryOption< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    /// <summary>
    /// Monad transformer for IEnumerable, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class IEnumerableT_Extensions
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Arr&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;IEnumerable&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Arr&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Arr<IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Arr&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;IEnumerable&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Arr&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Arr<IEnumerable<A>> ma) =>
            SeqTrans<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<IEnumerable<B>> BindT< A, B>(this Arr<IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            SeqTrans<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Bind<MArr<IEnumerable<B>>, Arr<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<IEnumerable<B>> BindT< A, B>(this Arr<IEnumerable<A>> ma, Func<A, Arr<IEnumerable<B>>> f) =>
            SeqTrans<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Bind<MArr<IEnumerable<B>>, Arr<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Arr&lt;IEnumerable&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `IEnumerable&lt;Arr&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;Arr&lt;B&gt;&gt;`</returns>
        [Pure]
        public static IEnumerable<Arr<B>> Traverse< A, B>(this Arr<IEnumerable<A>> ma, Func<A, B> f) =>
            SeqTrans<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Traverse<MEnumerable<Arr<B>>, IEnumerable<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Arr&lt;IEnumerable&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `IEnumerable&lt;Arr&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static IEnumerable<Arr<A>> Sequence< A>(this Arr<IEnumerable<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<IEnumerable<B>> MapT< A, B>(this Arr<IEnumerable<A>> ma, Func<A, B> f) =>
            SeqTrans<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Map<MArr<IEnumerable<B>>, Arr<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Arr<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Arr<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Arr<IEnumerable<A>> ma, Func<A, bool> f) =>
            SeqTrans<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Arr<IEnumerable<A>> ma, Func<A, bool> f) =>
            SeqTrans<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Arr&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Arr<IEnumerable<A>> ma, Action<A> f) =>
            SeqTrans<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;IEnumerable&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<IEnumerable<A>> FilterT< A>(this Arr<IEnumerable<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Bind<MArr<IEnumerable<A>>, Arr<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MEnumerable<A>).Return(a)
                        : default(MEnumerable<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Arr<IEnumerable<A>> PlusT<NUM,  A>(this Arr<IEnumerable<A>> x, Arr<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Arr<IEnumerable<A>> SubtractT<NUM,  A>(this Arr<IEnumerable<A>> x, Arr<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Arr<IEnumerable<A>> ProductT<NUM,  A>(this Arr<IEnumerable<A>> x, Arr<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Arr<IEnumerable<A>> DivideT<NUM,  A>(this Arr<IEnumerable<A>> x, Arr<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Arr<IEnumerable<A>> AppendT<SEMI,  A>(this Arr<IEnumerable<A>> x, Arr<IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Arr<IEnumerable<A>> x, Arr<IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Arr<IEnumerable<A>> x, Arr<IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Arr&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <returns>`Arr&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Arr<IEnumerable<B>> ApplyT< A, B>(this Func<A, B> fab, Arr<IEnumerable<A>> fa) =>
            ApplArr< IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MArr< Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => ApplEnumerable< A, B>.Inst.Apply(
                     MEnumerable< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Arr&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Arr&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <returns>`Arr&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Arr<IEnumerable<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Arr<IEnumerable<A>> fa, Arr<IEnumerable<B>> fb) =>
            ApplArr< IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MArr< Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            ApplEnumerable< A, B, C>.Inst.Apply(
                                MEnumerable< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the `Num<A>`s in `HashSet&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;IEnumerable&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `HashSet&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this HashSet<IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `HashSet&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;IEnumerable&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `HashSet&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this HashSet<IEnumerable<A>> ma) =>
            SeqTrans<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<IEnumerable<B>> BindT< A, B>(this HashSet<IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            SeqTrans<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Bind<MHashSet<IEnumerable<B>>, HashSet<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<IEnumerable<B>> BindT< A, B>(this HashSet<IEnumerable<A>> ma, Func<A, HashSet<IEnumerable<B>>> f) =>
            SeqTrans<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Bind<MHashSet<IEnumerable<B>>, HashSet<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `HashSet&lt;IEnumerable&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `IEnumerable&lt;HashSet&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;HashSet&lt;B&gt;&gt;`</returns>
        [Pure]
        public static IEnumerable<HashSet<B>> Traverse< A, B>(this HashSet<IEnumerable<A>> ma, Func<A, B> f) =>
            SeqTrans<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Traverse<MEnumerable<HashSet<B>>, IEnumerable<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `HashSet&lt;IEnumerable&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `IEnumerable&lt;HashSet&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static IEnumerable<HashSet<A>> Sequence< A>(this HashSet<IEnumerable<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<IEnumerable<B>> MapT< A, B>(this HashSet<IEnumerable<A>> ma, Func<A, B> f) =>
            SeqTrans<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Map<MHashSet<IEnumerable<B>>, HashSet<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this HashSet<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this HashSet<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this HashSet<IEnumerable<A>> ma, Func<A, bool> f) =>
            SeqTrans<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this HashSet<IEnumerable<A>> ma, Func<A, bool> f) =>
            SeqTrans<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `HashSet&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this HashSet<IEnumerable<A>> ma, Action<A> f) =>
            SeqTrans<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;IEnumerable&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<IEnumerable<A>> FilterT< A>(this HashSet<IEnumerable<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Bind<MHashSet<IEnumerable<A>>, HashSet<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MEnumerable<A>).Return(a)
                        : default(MEnumerable<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<IEnumerable<A>> PlusT<NUM,  A>(this HashSet<IEnumerable<A>> x, HashSet<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<IEnumerable<A>> SubtractT<NUM,  A>(this HashSet<IEnumerable<A>> x, HashSet<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static HashSet<IEnumerable<A>> ProductT<NUM,  A>(this HashSet<IEnumerable<A>> x, HashSet<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static HashSet<IEnumerable<A>> DivideT<NUM,  A>(this HashSet<IEnumerable<A>> x, HashSet<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static HashSet<IEnumerable<A>> AppendT<SEMI,  A>(this HashSet<IEnumerable<A>> x, HashSet<IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this HashSet<IEnumerable<A>> x, HashSet<IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this HashSet<IEnumerable<A>> x, HashSet<IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `HashSet&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <returns>`HashSet&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static HashSet<IEnumerable<B>> ApplyT< A, B>(this Func<A, B> fab, HashSet<IEnumerable<A>> fa) =>
            ApplHashSet< IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MHashSet< Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => ApplEnumerable< A, B>.Inst.Apply(
                     MEnumerable< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `HashSet&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `HashSet&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <returns>`HashSet&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static HashSet<IEnumerable<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, HashSet<IEnumerable<A>> fa, HashSet<IEnumerable<B>> fb) =>
            ApplHashSet< IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MHashSet< Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            ApplEnumerable< A, B, C>.Inst.Apply(
                                MEnumerable< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the `Num<A>`s in `Lst&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;IEnumerable&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Lst&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Lst<IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Lst&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;IEnumerable&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Lst&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Lst<IEnumerable<A>> ma) =>
            SeqTrans<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<IEnumerable<B>> BindT< A, B>(this Lst<IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            SeqTrans<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Bind<MLst<IEnumerable<B>>, Lst<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<IEnumerable<B>> BindT< A, B>(this Lst<IEnumerable<A>> ma, Func<A, Lst<IEnumerable<B>>> f) =>
            SeqTrans<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Bind<MLst<IEnumerable<B>>, Lst<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Lst&lt;IEnumerable&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `IEnumerable&lt;Lst&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;Lst&lt;B&gt;&gt;`</returns>
        [Pure]
        public static IEnumerable<Lst<B>> Traverse< A, B>(this Lst<IEnumerable<A>> ma, Func<A, B> f) =>
            SeqTrans<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Traverse<MEnumerable<Lst<B>>, IEnumerable<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Lst&lt;IEnumerable&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `IEnumerable&lt;Lst&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static IEnumerable<Lst<A>> Sequence< A>(this Lst<IEnumerable<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<IEnumerable<B>> MapT< A, B>(this Lst<IEnumerable<A>> ma, Func<A, B> f) =>
            SeqTrans<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Map<MLst<IEnumerable<B>>, Lst<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Lst<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Lst<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Lst<IEnumerable<A>> ma, Func<A, bool> f) =>
            SeqTrans<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Lst<IEnumerable<A>> ma, Func<A, bool> f) =>
            SeqTrans<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Lst&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Lst<IEnumerable<A>> ma, Action<A> f) =>
            SeqTrans<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;IEnumerable&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<IEnumerable<A>> FilterT< A>(this Lst<IEnumerable<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Bind<MLst<IEnumerable<A>>, Lst<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MEnumerable<A>).Return(a)
                        : default(MEnumerable<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Lst<IEnumerable<A>> PlusT<NUM,  A>(this Lst<IEnumerable<A>> x, Lst<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Lst<IEnumerable<A>> SubtractT<NUM,  A>(this Lst<IEnumerable<A>> x, Lst<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Lst<IEnumerable<A>> ProductT<NUM,  A>(this Lst<IEnumerable<A>> x, Lst<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Lst<IEnumerable<A>> DivideT<NUM,  A>(this Lst<IEnumerable<A>> x, Lst<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Lst<IEnumerable<A>> AppendT<SEMI,  A>(this Lst<IEnumerable<A>> x, Lst<IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Lst<IEnumerable<A>> x, Lst<IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Lst<IEnumerable<A>> x, Lst<IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Lst&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <returns>`Lst&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Lst<IEnumerable<B>> ApplyT< A, B>(this Func<A, B> fab, Lst<IEnumerable<A>> fa) =>
            ApplLst< IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MLst< Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => ApplEnumerable< A, B>.Inst.Apply(
                     MEnumerable< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Lst&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Lst&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <returns>`Lst&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Lst<IEnumerable<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Lst<IEnumerable<A>> fa, Lst<IEnumerable<B>> fb) =>
            ApplLst< IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MLst< Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            ApplEnumerable< A, B, C>.Inst.Apply(
                                MEnumerable< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the `Num<A>`s in `Option&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;IEnumerable&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Option&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Option<IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Option&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;IEnumerable&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Option&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Option<IEnumerable<A>> ma) =>
            Trans<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<IEnumerable<B>> BindT< A, B>(this Option<IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            Trans<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Bind<MOption<IEnumerable<B>>, Option<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<IEnumerable<B>> BindT< A, B>(this Option<IEnumerable<A>> ma, Func<A, Option<IEnumerable<B>>> f) =>
            Trans<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Bind<MOption<IEnumerable<B>>, Option<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Option&lt;IEnumerable&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `IEnumerable&lt;Option&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;Option&lt;B&gt;&gt;`</returns>
        [Pure]
        public static IEnumerable<Option<B>> Traverse< A, B>(this Option<IEnumerable<A>> ma, Func<A, B> f) =>
            SeqTrans<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Traverse<MEnumerable<Option<B>>, IEnumerable<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Option&lt;IEnumerable&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `IEnumerable&lt;Option&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static IEnumerable<Option<A>> Sequence< A>(this Option<IEnumerable<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<IEnumerable<B>> MapT< A, B>(this Option<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Map<MOption<IEnumerable<B>>, Option<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Option<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Option<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Option<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Option<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Option&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Option<IEnumerable<A>> ma, Action<A> f) =>
            Trans<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;IEnumerable&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<IEnumerable<A>> FilterT< A>(this Option<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Bind<MOption<IEnumerable<A>>, Option<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MEnumerable<A>).Return(a)
                        : default(MEnumerable<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Option<IEnumerable<A>> PlusT<NUM,  A>(this Option<IEnumerable<A>> x, Option<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Option<IEnumerable<A>> SubtractT<NUM,  A>(this Option<IEnumerable<A>> x, Option<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Option<IEnumerable<A>> ProductT<NUM,  A>(this Option<IEnumerable<A>> x, Option<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Option<IEnumerable<A>> DivideT<NUM,  A>(this Option<IEnumerable<A>> x, Option<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Option<IEnumerable<A>> AppendT<SEMI,  A>(this Option<IEnumerable<A>> x, Option<IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Option<IEnumerable<A>> x, Option<IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Option<IEnumerable<A>> x, Option<IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Option&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <returns>`Option&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Option<IEnumerable<B>> ApplyT< A, B>(this Func<A, B> fab, Option<IEnumerable<A>> fa) =>
            ApplOption< IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MOption< Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => ApplEnumerable< A, B>.Inst.Apply(
                     MEnumerable< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Option&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Option&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <returns>`Option&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Option<IEnumerable<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Option<IEnumerable<A>> fa, Option<IEnumerable<B>> fb) =>
            ApplOption< IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MOption< Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            ApplEnumerable< A, B, C>.Inst.Apply(
                                MEnumerable< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionUnsafe&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;IEnumerable&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionUnsafe&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this OptionUnsafe<IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionUnsafe&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;IEnumerable&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionUnsafe&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this OptionUnsafe<IEnumerable<A>> ma) =>
            Trans<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<IEnumerable<B>> BindT< A, B>(this OptionUnsafe<IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            Trans<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Bind<MOptionUnsafe<IEnumerable<B>>, OptionUnsafe<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<IEnumerable<B>> BindT< A, B>(this OptionUnsafe<IEnumerable<A>> ma, Func<A, OptionUnsafe<IEnumerable<B>>> f) =>
            Trans<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Bind<MOptionUnsafe<IEnumerable<B>>, OptionUnsafe<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionUnsafe&lt;IEnumerable&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `IEnumerable&lt;OptionUnsafe&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;OptionUnsafe&lt;B&gt;&gt;`</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<B>> Traverse< A, B>(this OptionUnsafe<IEnumerable<A>> ma, Func<A, B> f) =>
            SeqTrans<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Traverse<MEnumerable<OptionUnsafe<B>>, IEnumerable<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionUnsafe&lt;IEnumerable&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `IEnumerable&lt;OptionUnsafe&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static IEnumerable<OptionUnsafe<A>> Sequence< A>(this OptionUnsafe<IEnumerable<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<IEnumerable<B>> MapT< A, B>(this OptionUnsafe<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Map<MOptionUnsafe<IEnumerable<B>>, OptionUnsafe<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this OptionUnsafe<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this OptionUnsafe<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this OptionUnsafe<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this OptionUnsafe<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionUnsafe&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this OptionUnsafe<IEnumerable<A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;IEnumerable&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<IEnumerable<A>> FilterT< A>(this OptionUnsafe<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Bind<MOptionUnsafe<IEnumerable<A>>, OptionUnsafe<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MEnumerable<A>).Return(a)
                        : default(MEnumerable<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<IEnumerable<A>> PlusT<NUM,  A>(this OptionUnsafe<IEnumerable<A>> x, OptionUnsafe<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<IEnumerable<A>> SubtractT<NUM,  A>(this OptionUnsafe<IEnumerable<A>> x, OptionUnsafe<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionUnsafe<IEnumerable<A>> ProductT<NUM,  A>(this OptionUnsafe<IEnumerable<A>> x, OptionUnsafe<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionUnsafe<IEnumerable<A>> DivideT<NUM,  A>(this OptionUnsafe<IEnumerable<A>> x, OptionUnsafe<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionUnsafe<IEnumerable<A>> AppendT<SEMI,  A>(this OptionUnsafe<IEnumerable<A>> x, OptionUnsafe<IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this OptionUnsafe<IEnumerable<A>> x, OptionUnsafe<IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this OptionUnsafe<IEnumerable<A>> x, OptionUnsafe<IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <returns>`OptionUnsafe&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionUnsafe<IEnumerable<B>> ApplyT< A, B>(this Func<A, B> fab, OptionUnsafe<IEnumerable<A>> fa) =>
            ApplOptionUnsafe< IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MOptionUnsafe< Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => ApplEnumerable< A, B>.Inst.Apply(
                     MEnumerable< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `OptionUnsafe&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <returns>`OptionUnsafe&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionUnsafe<IEnumerable<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, OptionUnsafe<IEnumerable<A>> fa, OptionUnsafe<IEnumerable<B>> fb) =>
            ApplOptionUnsafe< IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MOptionUnsafe< Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            ApplEnumerable< A, B, C>.Inst.Apply(
                                MEnumerable< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the `Num<A>`s in `Either&lt;L, IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, IEnumerable&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Either&lt;L, IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Either<L, IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Either&lt;L, IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, IEnumerable&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Either&lt;L, IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this Either<L, IEnumerable<A>> ma) =>
            Trans<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either&lt;L, IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, IEnumerable<B>> BindT<L, A, B>(this Either<L, IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            Trans<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Bind<MEither<L, IEnumerable<B>>, Either<L, IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either&lt;L, IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, IEnumerable<B>> BindT<L, A, B>(this Either<L, IEnumerable<A>> ma, Func<A, Either<L, IEnumerable<B>>> f) =>
            Trans<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Bind<MEither<L, IEnumerable<B>>, Either<L, IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Either&lt;L, IEnumerable&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `IEnumerable&lt;Either&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;Either&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static IEnumerable<Either<L, B>> Traverse<L, A, B>(this Either<L, IEnumerable<A>> ma, Func<A, B> f) =>
            SeqTrans<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Traverse<MEnumerable<Either<L, B>>, IEnumerable<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Either&lt;L, IEnumerable&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `IEnumerable&lt;Either&lt;L, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static IEnumerable<Either<L, A>> Sequence<L, A>(this Either<L, IEnumerable<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, IEnumerable<B>> MapT<L, A, B>(this Either<L, IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Map<MEither<L, IEnumerable<B>>, Either<L, IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Either<L, IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Either<L, IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Either<L, IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Either<L, IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Either&lt;L, IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Either<L, IEnumerable<A>> ma, Action<A> f) =>
            Trans<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, IEnumerable&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, IEnumerable<A>> FilterT<L, A>(this Either<L, IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Bind<MEither<L, IEnumerable<A>>, Either<L, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MEnumerable<A>).Return(a)
                        : default(MEnumerable<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, IEnumerable&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, IEnumerable<A>> PlusT<NUM, L, A>(this Either<L, IEnumerable<A>> x, Either<L, IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, IEnumerable&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, IEnumerable<A>> SubtractT<NUM, L, A>(this Either<L, IEnumerable<A>> x, Either<L, IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, IEnumerable&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Either<L, IEnumerable<A>> ProductT<NUM, L, A>(this Either<L, IEnumerable<A>> x, Either<L, IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, IEnumerable&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Either<L, IEnumerable<A>> DivideT<NUM, L, A>(this Either<L, IEnumerable<A>> x, Either<L, IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, IEnumerable&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Either<L, IEnumerable<A>> AppendT<SEMI, L, A>(this Either<L, IEnumerable<A>> x, Either<L, IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Either<L, IEnumerable<A>> x, Either<L, IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, IEnumerable&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Either<L, IEnumerable<A>> x, Either<L, IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Either&lt;L, IEnumerable&lt;A&gt;&gt;`</param>
        /// <returns>`Either&lt;L, IEnumerable&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Either<L, IEnumerable<B>> ApplyT<L, A, B>(this Func<A, B> fab, Either<L, IEnumerable<A>> fa) =>
            ApplEither<L, IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MEither<L, Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => ApplEnumerable< A, B>.Inst.Apply(
                     MEnumerable< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Either&lt;L, IEnumerable&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Either&lt;L, IEnumerable&lt;A&gt;&gt;`</param>
        /// <returns>`Either&lt;L, IEnumerable&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Either<L, IEnumerable<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Either<L, IEnumerable<A>> fa, Either<L, IEnumerable<B>> fb) =>
            ApplEither<L, IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MEither<L, Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            ApplEnumerable< A, B, C>.Inst.Apply(
                                MEnumerable< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherUnsafe&lt;L, IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, IEnumerable&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherUnsafe&lt;L, IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this EitherUnsafe<L, IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherUnsafe&lt;L, IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, IEnumerable&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherUnsafe&lt;L, IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this EitherUnsafe<L, IEnumerable<A>> ma) =>
            Trans<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, IEnumerable<B>> BindT<L, A, B>(this EitherUnsafe<L, IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            Trans<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Bind<MEitherUnsafe<L, IEnumerable<B>>, EitherUnsafe<L, IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, IEnumerable<B>> BindT<L, A, B>(this EitherUnsafe<L, IEnumerable<A>> ma, Func<A, EitherUnsafe<L, IEnumerable<B>>> f) =>
            Trans<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Bind<MEitherUnsafe<L, IEnumerable<B>>, EitherUnsafe<L, IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `EitherUnsafe&lt;L, IEnumerable&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `IEnumerable&lt;EitherUnsafe&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;EitherUnsafe&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, B>> Traverse<L, A, B>(this EitherUnsafe<L, IEnumerable<A>> ma, Func<A, B> f) =>
            SeqTrans<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Traverse<MEnumerable<EitherUnsafe<L, B>>, IEnumerable<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `EitherUnsafe&lt;L, IEnumerable&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `IEnumerable&lt;EitherUnsafe&lt;L, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static IEnumerable<EitherUnsafe<L, A>> Sequence<L, A>(this EitherUnsafe<L, IEnumerable<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, IEnumerable<B>> MapT<L, A, B>(this EitherUnsafe<L, IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Map<MEitherUnsafe<L, IEnumerable<B>>, EitherUnsafe<L, IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this EitherUnsafe<L, IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this EitherUnsafe<L, IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this EitherUnsafe<L, IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this EitherUnsafe<L, IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherUnsafe&lt;L, IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this EitherUnsafe<L, IEnumerable<A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, IEnumerable&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, IEnumerable<A>> FilterT<L, A>(this EitherUnsafe<L, IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Bind<MEitherUnsafe<L, IEnumerable<A>>, EitherUnsafe<L, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MEnumerable<A>).Return(a)
                        : default(MEnumerable<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, IEnumerable&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, IEnumerable<A>> PlusT<NUM, L, A>(this EitherUnsafe<L, IEnumerable<A>> x, EitherUnsafe<L, IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, IEnumerable&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, IEnumerable<A>> SubtractT<NUM, L, A>(this EitherUnsafe<L, IEnumerable<A>> x, EitherUnsafe<L, IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, IEnumerable&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherUnsafe<L, IEnumerable<A>> ProductT<NUM, L, A>(this EitherUnsafe<L, IEnumerable<A>> x, EitherUnsafe<L, IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, IEnumerable&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherUnsafe<L, IEnumerable<A>> DivideT<NUM, L, A>(this EitherUnsafe<L, IEnumerable<A>> x, EitherUnsafe<L, IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, IEnumerable&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherUnsafe<L, IEnumerable<A>> AppendT<SEMI, L, A>(this EitherUnsafe<L, IEnumerable<A>> x, EitherUnsafe<L, IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this EitherUnsafe<L, IEnumerable<A>> x, EitherUnsafe<L, IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, IEnumerable&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this EitherUnsafe<L, IEnumerable<A>> x, EitherUnsafe<L, IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe&lt;L, IEnumerable&lt;A&gt;&gt;`</param>
        /// <returns>`EitherUnsafe&lt;L, IEnumerable&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherUnsafe<L, IEnumerable<B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherUnsafe<L, IEnumerable<A>> fa) =>
            ApplEitherUnsafe<L, IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => ApplEnumerable< A, B>.Inst.Apply(
                     MEnumerable< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe&lt;L, IEnumerable&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `EitherUnsafe&lt;L, IEnumerable&lt;A&gt;&gt;`</param>
        /// <returns>`EitherUnsafe&lt;L, IEnumerable&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherUnsafe<L, IEnumerable<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherUnsafe<L, IEnumerable<A>> fa, EitherUnsafe<L, IEnumerable<B>> fb) =>
            ApplEitherUnsafe<L, IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MEitherUnsafe<L, Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            ApplEnumerable< A, B, C>.Inst.Apply(
                                MEnumerable< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the `Num<A>`s in `Try&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;IEnumerable&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Try&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Try<IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Try&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;IEnumerable&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Try&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Try<IEnumerable<A>> ma) =>
            Trans<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<IEnumerable<B>> BindT< A, B>(this Try<IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            Trans<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Bind<MTry<IEnumerable<B>>, Try<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<IEnumerable<B>> BindT< A, B>(this Try<IEnumerable<A>> ma, Func<A, Try<IEnumerable<B>>> f) =>
            Trans<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Bind<MTry<IEnumerable<B>>, Try<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Try&lt;IEnumerable&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `IEnumerable&lt;Try&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;Try&lt;B&gt;&gt;`</returns>
        [Pure]
        public static IEnumerable<Try<B>> Traverse< A, B>(this Try<IEnumerable<A>> ma, Func<A, B> f) =>
            SeqTrans<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Traverse<MEnumerable<Try<B>>, IEnumerable<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Try&lt;IEnumerable&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `IEnumerable&lt;Try&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static IEnumerable<Try<A>> Sequence< A>(this Try<IEnumerable<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<IEnumerable<B>> MapT< A, B>(this Try<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Map<MTry<IEnumerable<B>>, Try<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Try<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Try<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Try<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Try<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Try&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Try<IEnumerable<A>> ma, Action<A> f) =>
            Trans<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;IEnumerable&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<IEnumerable<A>> FilterT< A>(this Try<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Bind<MTry<IEnumerable<A>>, Try<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MEnumerable<A>).Return(a)
                        : default(MEnumerable<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Try<IEnumerable<A>> PlusT<NUM,  A>(this Try<IEnumerable<A>> x, Try<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Try<IEnumerable<A>> SubtractT<NUM,  A>(this Try<IEnumerable<A>> x, Try<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Try<IEnumerable<A>> ProductT<NUM,  A>(this Try<IEnumerable<A>> x, Try<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Try<IEnumerable<A>> DivideT<NUM,  A>(this Try<IEnumerable<A>> x, Try<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Try<IEnumerable<A>> AppendT<SEMI,  A>(this Try<IEnumerable<A>> x, Try<IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Try<IEnumerable<A>> x, Try<IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Try<IEnumerable<A>> x, Try<IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Try&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <returns>`Try&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Try<IEnumerable<B>> ApplyT< A, B>(this Func<A, B> fab, Try<IEnumerable<A>> fa) =>
            ApplTry< IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MTry< Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => ApplEnumerable< A, B>.Inst.Apply(
                     MEnumerable< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Try&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Try&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <returns>`Try&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Try<IEnumerable<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Try<IEnumerable<A>> fa, Try<IEnumerable<B>> fb) =>
            ApplTry< IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MTry< Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            ApplEnumerable< A, B, C>.Inst.Apply(
                                MEnumerable< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOption&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;IEnumerable&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOption&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryOption<IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOption&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;IEnumerable&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOption&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this TryOption<IEnumerable<A>> ma) =>
            Trans<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<IEnumerable<B>> BindT< A, B>(this TryOption<IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            Trans<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Bind<MTryOption<IEnumerable<B>>, TryOption<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<IEnumerable<B>> BindT< A, B>(this TryOption<IEnumerable<A>> ma, Func<A, TryOption<IEnumerable<B>>> f) =>
            Trans<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Bind<MTryOption<IEnumerable<B>>, TryOption<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOption&lt;IEnumerable&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `IEnumerable&lt;TryOption&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;TryOption&lt;B&gt;&gt;`</returns>
        [Pure]
        public static IEnumerable<TryOption<B>> Traverse< A, B>(this TryOption<IEnumerable<A>> ma, Func<A, B> f) =>
            SeqTrans<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Traverse<MEnumerable<TryOption<B>>, IEnumerable<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOption&lt;IEnumerable&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `IEnumerable&lt;TryOption&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static IEnumerable<TryOption<A>> Sequence< A>(this TryOption<IEnumerable<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<IEnumerable<B>> MapT< A, B>(this TryOption<IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Map<MTryOption<IEnumerable<B>>, TryOption<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryOption<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryOption<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryOption<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryOption<IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOption&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryOption<IEnumerable<A>> ma, Action<A> f) =>
            Trans<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;IEnumerable&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<IEnumerable<A>> FilterT< A>(this TryOption<IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Bind<MTryOption<IEnumerable<A>>, TryOption<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MEnumerable<A>).Return(a)
                        : default(MEnumerable<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<IEnumerable<A>> PlusT<NUM,  A>(this TryOption<IEnumerable<A>> x, TryOption<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<IEnumerable<A>> SubtractT<NUM,  A>(this TryOption<IEnumerable<A>> x, TryOption<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOption<IEnumerable<A>> ProductT<NUM,  A>(this TryOption<IEnumerable<A>> x, TryOption<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOption<IEnumerable<A>> DivideT<NUM,  A>(this TryOption<IEnumerable<A>> x, TryOption<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOption<IEnumerable<A>> AppendT<SEMI,  A>(this TryOption<IEnumerable<A>> x, TryOption<IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryOption<IEnumerable<A>> x, TryOption<IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryOption<IEnumerable<A>> x, TryOption<IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOption&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <returns>`TryOption&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOption<IEnumerable<B>> ApplyT< A, B>(this Func<A, B> fab, TryOption<IEnumerable<A>> fa) =>
            ApplTryOption< IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MTryOption< Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => ApplEnumerable< A, B>.Inst.Apply(
                     MEnumerable< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOption&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryOption&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <returns>`TryOption&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOption<IEnumerable<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOption<IEnumerable<A>> fa, TryOption<IEnumerable<B>> fb) =>
            ApplTryOption< IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MTryOption< Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            ApplEnumerable< A, B, C>.Inst.Apply(
                                MEnumerable< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the `Num<A>`s in `IEnumerable&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;IEnumerable&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `IEnumerable&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this IEnumerable<IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MEnumerable<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `IEnumerable&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;IEnumerable&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `IEnumerable&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this IEnumerable<IEnumerable<A>> ma) =>
            SeqTrans<MEnumerable<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<IEnumerable<B>> BindT< A, B>(this IEnumerable<IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            SeqTrans<MEnumerable<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Bind<MEnumerable<IEnumerable<B>>, IEnumerable<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<IEnumerable<B>> BindT< A, B>(this IEnumerable<IEnumerable<A>> ma, Func<A, IEnumerable<IEnumerable<B>>> f) =>
            SeqTrans<MEnumerable<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Bind<MEnumerable<IEnumerable<B>>, IEnumerable<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `IEnumerable&lt;IEnumerable&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `IEnumerable&lt;IEnumerable&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;IEnumerable&lt;B&gt;&gt;`</returns>
        [Pure]
        public static IEnumerable<IEnumerable<B>> Traverse< A, B>(this IEnumerable<IEnumerable<A>> ma, Func<A, B> f) =>
            SeqTrans<MEnumerable<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Traverse<MEnumerable<IEnumerable<B>>, IEnumerable<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `IEnumerable&lt;IEnumerable&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `IEnumerable&lt;IEnumerable&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static IEnumerable<IEnumerable<A>> Sequence< A>(this IEnumerable<IEnumerable<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<IEnumerable<B>> MapT< A, B>(this IEnumerable<IEnumerable<A>> ma, Func<A, B> f) =>
            SeqTrans<MEnumerable<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Map<MEnumerable<IEnumerable<B>>, IEnumerable<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this IEnumerable<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MEnumerable<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this IEnumerable<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MEnumerable<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this IEnumerable<IEnumerable<A>> ma, Func<A, bool> f) =>
            SeqTrans<MEnumerable<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this IEnumerable<IEnumerable<A>> ma, Func<A, bool> f) =>
            SeqTrans<MEnumerable<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `IEnumerable&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this IEnumerable<IEnumerable<A>> ma, Action<A> f) =>
            SeqTrans<MEnumerable<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;IEnumerable&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<IEnumerable<A>> FilterT< A>(this IEnumerable<IEnumerable<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MEnumerable<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Bind<MEnumerable<IEnumerable<A>>, IEnumerable<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MEnumerable<A>).Return(a)
                        : default(MEnumerable<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<IEnumerable<A>> PlusT<NUM,  A>(this IEnumerable<IEnumerable<A>> x, IEnumerable<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<IEnumerable<A>> SubtractT<NUM,  A>(this IEnumerable<IEnumerable<A>> x, IEnumerable<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static IEnumerable<IEnumerable<A>> ProductT<NUM,  A>(this IEnumerable<IEnumerable<A>> x, IEnumerable<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static IEnumerable<IEnumerable<A>> DivideT<NUM,  A>(this IEnumerable<IEnumerable<A>> x, IEnumerable<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static IEnumerable<IEnumerable<A>> AppendT<SEMI,  A>(this IEnumerable<IEnumerable<A>> x, IEnumerable<IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this IEnumerable<IEnumerable<A>> x, IEnumerable<IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this IEnumerable<IEnumerable<A>> x, IEnumerable<IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `IEnumerable&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <returns>`IEnumerable&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static IEnumerable<IEnumerable<B>> ApplyT< A, B>(this Func<A, B> fab, IEnumerable<IEnumerable<A>> fa) =>
            ApplEnumerable< IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MEnumerable< Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => ApplEnumerable< A, B>.Inst.Apply(
                     MEnumerable< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `IEnumerable&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `IEnumerable&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <returns>`IEnumerable&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static IEnumerable<IEnumerable<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, IEnumerable<IEnumerable<A>> fa, IEnumerable<IEnumerable<B>> fb) =>
            ApplEnumerable< IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MEnumerable< Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            ApplEnumerable< A, B, C>.Inst.Apply(
                                MEnumerable< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the `Num<A>`s in `Seq&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;IEnumerable&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Seq&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Seq<IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MSeq<IEnumerable<A>>, Seq<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Seq&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;IEnumerable&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Seq&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Seq<IEnumerable<A>> ma) =>
            SeqTrans<MSeq<IEnumerable<A>>, Seq<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Seq&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<IEnumerable<B>> BindT< A, B>(this Seq<IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            SeqTrans<MSeq<IEnumerable<A>>, Seq<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Bind<MSeq<IEnumerable<B>>, Seq<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Seq&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<IEnumerable<B>> BindT< A, B>(this Seq<IEnumerable<A>> ma, Func<A, Seq<IEnumerable<B>>> f) =>
            SeqTrans<MSeq<IEnumerable<A>>, Seq<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Bind<MSeq<IEnumerable<B>>, Seq<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Seq&lt;IEnumerable&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `IEnumerable&lt;Seq&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;Seq&lt;B&gt;&gt;`</returns>
        [Pure]
        public static IEnumerable<Seq<B>> Traverse< A, B>(this Seq<IEnumerable<A>> ma, Func<A, B> f) =>
            SeqTrans<MSeq<IEnumerable<A>>, Seq<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Traverse<MEnumerable<Seq<B>>, IEnumerable<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Seq&lt;IEnumerable&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `IEnumerable&lt;Seq&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static IEnumerable<Seq<A>> Sequence< A>(this Seq<IEnumerable<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<IEnumerable<B>> MapT< A, B>(this Seq<IEnumerable<A>> ma, Func<A, B> f) =>
            SeqTrans<MSeq<IEnumerable<A>>, Seq<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Map<MSeq<IEnumerable<B>>, Seq<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Seq<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSeq<IEnumerable<A>>, Seq<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Seq<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSeq<IEnumerable<A>>, Seq<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Seq<IEnumerable<A>> ma, Func<A, bool> f) =>
            SeqTrans<MSeq<IEnumerable<A>>, Seq<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Seq<IEnumerable<A>> ma, Func<A, bool> f) =>
            SeqTrans<MSeq<IEnumerable<A>>, Seq<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Seq&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Seq<IEnumerable<A>> ma, Action<A> f) =>
            SeqTrans<MSeq<IEnumerable<A>>, Seq<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;IEnumerable&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<IEnumerable<A>> FilterT< A>(this Seq<IEnumerable<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSeq<IEnumerable<A>>, Seq<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Bind<MSeq<IEnumerable<A>>, Seq<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MEnumerable<A>).Return(a)
                        : default(MEnumerable<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Seq<IEnumerable<A>> PlusT<NUM,  A>(this Seq<IEnumerable<A>> x, Seq<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Seq<IEnumerable<A>> SubtractT<NUM,  A>(this Seq<IEnumerable<A>> x, Seq<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Seq<IEnumerable<A>> ProductT<NUM,  A>(this Seq<IEnumerable<A>> x, Seq<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Seq<IEnumerable<A>> DivideT<NUM,  A>(this Seq<IEnumerable<A>> x, Seq<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Seq<IEnumerable<A>> AppendT<SEMI,  A>(this Seq<IEnumerable<A>> x, Seq<IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Seq<IEnumerable<A>> x, Seq<IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Seq<IEnumerable<A>> x, Seq<IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Seq&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <returns>`Seq&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Seq<IEnumerable<B>> ApplyT< A, B>(this Func<A, B> fab, Seq<IEnumerable<A>> fa) =>
            ApplSeq< IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MSeq< Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => ApplEnumerable< A, B>.Inst.Apply(
                     MEnumerable< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Seq&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Seq&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <returns>`Seq&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Seq<IEnumerable<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Seq<IEnumerable<A>> fa, Seq<IEnumerable<B>> fb) =>
            ApplSeq< IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MSeq< Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            ApplEnumerable< A, B, C>.Inst.Apply(
                                MEnumerable< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the `Num<A>`s in `Set&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;IEnumerable&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Set&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Set<IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Set&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;IEnumerable&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Set&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Set<IEnumerable<A>> ma) =>
            SeqTrans<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<IEnumerable<B>> BindT< A, B>(this Set<IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            SeqTrans<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Bind<MSet<IEnumerable<B>>, Set<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<IEnumerable<B>> BindT< A, B>(this Set<IEnumerable<A>> ma, Func<A, Set<IEnumerable<B>>> f) =>
            SeqTrans<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Bind<MSet<IEnumerable<B>>, Set<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Set&lt;IEnumerable&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `IEnumerable&lt;Set&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;Set&lt;B&gt;&gt;`</returns>
        [Pure]
        public static IEnumerable<Set<B>> Traverse< A, B>(this Set<IEnumerable<A>> ma, Func<A, B> f) =>
            SeqTrans<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Traverse<MEnumerable<Set<B>>, IEnumerable<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Set&lt;IEnumerable&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `IEnumerable&lt;Set&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static IEnumerable<Set<A>> Sequence< A>(this Set<IEnumerable<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<IEnumerable<B>> MapT< A, B>(this Set<IEnumerable<A>> ma, Func<A, B> f) =>
            SeqTrans<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Map<MSet<IEnumerable<B>>, Set<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Set<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Set<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Set<IEnumerable<A>> ma, Func<A, bool> f) =>
            SeqTrans<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Set<IEnumerable<A>> ma, Func<A, bool> f) =>
            SeqTrans<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Set&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Set<IEnumerable<A>> ma, Action<A> f) =>
            SeqTrans<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;IEnumerable&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<IEnumerable<A>> FilterT< A>(this Set<IEnumerable<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Bind<MSet<IEnumerable<A>>, Set<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MEnumerable<A>).Return(a)
                        : default(MEnumerable<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Set<IEnumerable<A>> PlusT<NUM,  A>(this Set<IEnumerable<A>> x, Set<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Set<IEnumerable<A>> SubtractT<NUM,  A>(this Set<IEnumerable<A>> x, Set<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Set<IEnumerable<A>> ProductT<NUM,  A>(this Set<IEnumerable<A>> x, Set<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Set<IEnumerable<A>> DivideT<NUM,  A>(this Set<IEnumerable<A>> x, Set<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Set<IEnumerable<A>> AppendT<SEMI,  A>(this Set<IEnumerable<A>> x, Set<IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Set<IEnumerable<A>> x, Set<IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Set<IEnumerable<A>> x, Set<IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Set&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <returns>`Set&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Set<IEnumerable<B>> ApplyT< A, B>(this Func<A, B> fab, Set<IEnumerable<A>> fa) =>
            ApplSet< IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MSet< Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => ApplEnumerable< A, B>.Inst.Apply(
                     MEnumerable< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Set&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Set&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <returns>`Set&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Set<IEnumerable<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Set<IEnumerable<A>> fa, Set<IEnumerable<B>> fb) =>
            ApplSet< IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MSet< Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            ApplEnumerable< A, B, C>.Inst.Apply(
                                MEnumerable< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Finds total of all the `Num<A>`s in `Validation&lt;FAIL, IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, IEnumerable&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Validation&lt;FAIL, IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, FAIL, A>(this Validation<FAIL, IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MValidation<FAIL, IEnumerable<A>>, Validation<FAIL, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Validation&lt;FAIL, IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, IEnumerable&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Validation&lt;FAIL, IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<FAIL, A>(this Validation<FAIL, IEnumerable<A>> ma) =>
            Trans<MValidation<FAIL, IEnumerable<A>>, Validation<FAIL, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Validation&lt;FAIL, IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, IEnumerable<B>> BindT<FAIL, A, B>(this Validation<FAIL, IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            Trans<MValidation<FAIL, IEnumerable<A>>, Validation<FAIL, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Bind<MValidation<FAIL, IEnumerable<B>>, Validation<FAIL, IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Validation&lt;FAIL, IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, IEnumerable<B>> BindT<FAIL, A, B>(this Validation<FAIL, IEnumerable<A>> ma, Func<A, Validation<FAIL, IEnumerable<B>>> f) =>
            Trans<MValidation<FAIL, IEnumerable<A>>, Validation<FAIL, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Bind<MValidation<FAIL, IEnumerable<B>>, Validation<FAIL, IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Validation&lt;FAIL, IEnumerable&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `IEnumerable&lt;Validation&lt;FAIL, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;Validation&lt;FAIL, B&gt;&gt;`</returns>
        [Pure]
        public static IEnumerable<Validation<FAIL, B>> Traverse<FAIL, A, B>(this Validation<FAIL, IEnumerable<A>> ma, Func<A, B> f) =>
            SeqTrans<MValidation<FAIL, IEnumerable<A>>, Validation<FAIL, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Traverse<MEnumerable<Validation<FAIL, B>>, IEnumerable<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Validation&lt;FAIL, IEnumerable&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `IEnumerable&lt;Validation&lt;FAIL, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<FAIL, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static IEnumerable<Validation<FAIL, A>> Sequence<FAIL, A>(this Validation<FAIL, IEnumerable<A>> ma) =>
            ma.Traverse<FAIL, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, IEnumerable<B>> MapT<FAIL, A, B>(this Validation<FAIL, IEnumerable<A>> ma, Func<A, B> f) =>
            Trans<MValidation<FAIL, IEnumerable<A>>, Validation<FAIL, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Map<MValidation<FAIL, IEnumerable<B>>, Validation<FAIL, IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, FAIL, A>(this Validation<FAIL, IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MValidation<FAIL, IEnumerable<A>>, Validation<FAIL, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, FAIL, A>(this Validation<FAIL, IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MValidation<FAIL, IEnumerable<A>>, Validation<FAIL, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<FAIL, A>(this Validation<FAIL, IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MValidation<FAIL, IEnumerable<A>>, Validation<FAIL, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<FAIL, A>(this Validation<FAIL, IEnumerable<A>> ma, Func<A, bool> f) =>
            Trans<MValidation<FAIL, IEnumerable<A>>, Validation<FAIL, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Validation&lt;FAIL, IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<FAIL, A>(this Validation<FAIL, IEnumerable<A>> ma, Action<A> f) =>
            Trans<MValidation<FAIL, IEnumerable<A>>, Validation<FAIL, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, IEnumerable&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, IEnumerable<A>> FilterT<FAIL, A>(this Validation<FAIL, IEnumerable<A>> ma, Func<A, bool> pred) =>
            Trans<MValidation<FAIL, IEnumerable<A>>, Validation<FAIL, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>
                .Inst.Bind<MValidation<FAIL, IEnumerable<A>>, Validation<FAIL, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>(ma, 
                    a => pred(a)
                        ? default(MEnumerable<A>).Return(a)
                        : default(MEnumerable<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, IEnumerable&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Validation<FAIL, IEnumerable<A>> PlusT<NUM, FAIL, A>(this Validation<FAIL, IEnumerable<A>> x, Validation<FAIL, IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, IEnumerable&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Validation<FAIL, IEnumerable<A>> SubtractT<NUM, FAIL, A>(this Validation<FAIL, IEnumerable<A>> x, Validation<FAIL, IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, IEnumerable&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Validation<FAIL, IEnumerable<A>> ProductT<NUM, FAIL, A>(this Validation<FAIL, IEnumerable<A>> x, Validation<FAIL, IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, IEnumerable&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Validation<FAIL, IEnumerable<A>> DivideT<NUM, FAIL, A>(this Validation<FAIL, IEnumerable<A>> x, Validation<FAIL, IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, IEnumerable&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Validation<FAIL, IEnumerable<A>> AppendT<SEMI, FAIL, A>(this Validation<FAIL, IEnumerable<A>> x, Validation<FAIL, IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, FAIL, A>(this Validation<FAIL, IEnumerable<A>> x, Validation<FAIL, IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, IEnumerable&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, FAIL, A>(this Validation<FAIL, IEnumerable<A>> x, Validation<FAIL, IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Validation&lt;FAIL, IEnumerable&lt;A&gt;&gt;`</param>
        /// <returns>`Validation&lt;FAIL, IEnumerable&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Validation<FAIL, IEnumerable<B>> ApplyT<FAIL, A, B>(this Func<A, B> fab, Validation<FAIL, IEnumerable<A>> fa) =>
            ApplValidation<FAIL, IEnumerable<A>, IEnumerable<B>>.Inst.Apply(
                 MValidation<FAIL, Func<IEnumerable<A>, IEnumerable<B>>>.Inst.Return((IEnumerable<A> a) => ApplEnumerable< A, B>.Inst.Apply(
                     MEnumerable< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Validation&lt;FAIL, IEnumerable&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Validation&lt;FAIL, IEnumerable&lt;A&gt;&gt;`</param>
        /// <returns>`Validation&lt;FAIL, IEnumerable&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Validation<FAIL, IEnumerable<C>> ApplyT<FAIL, A, B, C>(this Func<A, B, C> fabc, Validation<FAIL, IEnumerable<A>> fa, Validation<FAIL, IEnumerable<B>> fb) =>
            ApplValidation<FAIL, IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>.Inst.Apply(
                MValidation<FAIL, Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>.Inst.Return(
                    (IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            ApplEnumerable< A, B, C>.Inst.Apply(
                                MEnumerable< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    /// <summary>
    /// Monad transformer for Seq, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class SeqT_Extensions
    {
        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Arr&lt;Seq&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<Seq<C>> SelectMany< A, B, C>(
            this Arr<Seq<A>> ma,
            Func<A, Arr<Seq<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MArr<Seq<A>>, Arr<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MArr<Seq<C>>, Arr<Seq<C>>, MSeq<C>, Seq<C>, C>(ma, a =>
                    SeqTrans<MArr<Seq<B>>, Arr<Seq<B>>, MSeq<B>, Seq<B>, B>
                        .Inst.Bind<MArr<Seq<C>>, Arr<Seq<C>>, MSeq<C>, Seq<C>, C>(bind(a), b =>
                            default(MSeq<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;Seq&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<Seq<A>> Where< A>(this Arr<Seq<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MArr<Seq<A>>, Arr<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MArr<Seq<A>>, Arr<Seq<A>>, MSeq<A>, Seq<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Seq<B>> Select< A, B>(this Arr<Seq<A>> ma, Func<A, B> f) =>
            SeqTrans<MArr<Seq<A>>, Arr<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Map<MArr<Seq<B>>, Arr<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Arr&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Seq&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Arr&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Arr<Seq<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MArr<Seq<A>>, Arr<Seq<A>>, MSeq<A>, Seq<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Arr&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Seq&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Arr&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Arr<Seq<A>> ma) =>
            SeqTrans<MArr<Seq<A>>, Arr<Seq<A>>, MSeq<A>, Seq<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Seq<B>> BindT< A, B>(this Arr<Seq<A>> ma, Func<A, Seq<B>> f) =>
            SeqTrans<MArr<Seq<A>>, Arr<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MArr<Seq<B>>, Arr<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Seq<B>> BindT< A, B>(this Arr<Seq<A>> ma, Func<A, Arr<Seq<B>>> f) =>
            SeqTrans<MArr<Seq<A>>, Arr<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MArr<Seq<B>>, Arr<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Arr&lt;Seq&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Seq&lt;Arr&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;Arr&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Seq<Arr<B>> Traverse< A, B>(this Arr<Seq<A>> ma, Func<A, B> f) =>
            SeqTrans<MArr<Seq<A>>, Arr<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Traverse<MSeq<Arr<B>>, Seq<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Arr&lt;Seq&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Seq&lt;Arr&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Seq<Arr<A>> Sequence< A>(this Arr<Seq<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Seq<B>> MapT< A, B>(this Arr<Seq<A>> ma, Func<A, B> f) =>
            SeqTrans<MArr<Seq<A>>, Arr<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Map<MArr<Seq<B>>, Arr<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Arr<Seq<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MArr<Seq<A>>, Arr<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Arr<Seq<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MArr<Seq<A>>, Arr<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Arr<Seq<A>> ma, Func<A, bool> f) =>
            SeqTrans<MArr<Seq<A>>, Arr<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Arr<Seq<A>> ma, Func<A, bool> f) =>
            SeqTrans<MArr<Seq<A>>, Arr<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Arr&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Arr<Seq<A>> ma, Action<A> f) =>
            SeqTrans<MArr<Seq<A>>, Arr<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;Seq&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<Seq<A>> FilterT< A>(this Arr<Seq<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MArr<Seq<A>>, Arr<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MArr<Seq<A>>, Arr<Seq<A>>, MSeq<A>, Seq<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Seq&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Arr<Seq<A>> PlusT<NUM,  A>(this Arr<Seq<A>> x, Arr<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Seq&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Arr<Seq<A>> SubtractT<NUM,  A>(this Arr<Seq<A>> x, Arr<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Arr<Seq<A>> ProductT<NUM,  A>(this Arr<Seq<A>> x, Arr<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Arr<Seq<A>> DivideT<NUM,  A>(this Arr<Seq<A>> x, Arr<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Arr<Seq<A>> AppendT<SEMI,  A>(this Arr<Seq<A>> x, Arr<Seq<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Arr<Seq<A>> x, Arr<Seq<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Arr<Seq<A>> x, Arr<Seq<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Arr&lt;Seq&lt;A&gt;&gt;`</param>
        /// <returns>`Arr&lt;Seq&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Arr<Seq<B>> ApplyT< A, B>(this Func<A, B> fab, Arr<Seq<A>> fa) =>
            ApplArr< Seq<A>, Seq<B>>.Inst.Apply(
                 MArr< Func<Seq<A>, Seq<B>>>.Inst.Return((Seq<A> a) => ApplSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Arr&lt;Seq&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Arr&lt;Seq&lt;A&gt;&gt;`</param>
        /// <returns>`Arr&lt;Seq&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Arr<Seq<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Arr<Seq<A>> fa, Arr<Seq<B>> fb) =>
            ApplArr< Seq<A>, Seq<B>, Seq<C>>.Inst.Apply(
                MArr< Func<Seq<A>, Func<Seq<B>, Seq<C>>>>.Inst.Return(
                    (Seq<A> a) =>
                        (Seq<B> b) =>
                            ApplSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`HashSet&lt;Seq&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<Seq<C>> SelectMany< A, B, C>(
            this HashSet<Seq<A>> ma,
            Func<A, HashSet<Seq<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MHashSet<Seq<A>>, HashSet<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MHashSet<Seq<C>>, HashSet<Seq<C>>, MSeq<C>, Seq<C>, C>(ma, a =>
                    SeqTrans<MHashSet<Seq<B>>, HashSet<Seq<B>>, MSeq<B>, Seq<B>, B>
                        .Inst.Bind<MHashSet<Seq<C>>, HashSet<Seq<C>>, MSeq<C>, Seq<C>, C>(bind(a), b =>
                            default(MSeq<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;Seq&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<Seq<A>> Where< A>(this HashSet<Seq<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MHashSet<Seq<A>>, HashSet<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MHashSet<Seq<A>>, HashSet<Seq<A>>, MSeq<A>, Seq<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Seq<B>> Select< A, B>(this HashSet<Seq<A>> ma, Func<A, B> f) =>
            SeqTrans<MHashSet<Seq<A>>, HashSet<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Map<MHashSet<Seq<B>>, HashSet<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `HashSet&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Seq&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `HashSet&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this HashSet<Seq<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MHashSet<Seq<A>>, HashSet<Seq<A>>, MSeq<A>, Seq<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `HashSet&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Seq&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `HashSet&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this HashSet<Seq<A>> ma) =>
            SeqTrans<MHashSet<Seq<A>>, HashSet<Seq<A>>, MSeq<A>, Seq<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Seq<B>> BindT< A, B>(this HashSet<Seq<A>> ma, Func<A, Seq<B>> f) =>
            SeqTrans<MHashSet<Seq<A>>, HashSet<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MHashSet<Seq<B>>, HashSet<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Seq<B>> BindT< A, B>(this HashSet<Seq<A>> ma, Func<A, HashSet<Seq<B>>> f) =>
            SeqTrans<MHashSet<Seq<A>>, HashSet<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MHashSet<Seq<B>>, HashSet<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `HashSet&lt;Seq&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Seq&lt;HashSet&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;HashSet&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Seq<HashSet<B>> Traverse< A, B>(this HashSet<Seq<A>> ma, Func<A, B> f) =>
            SeqTrans<MHashSet<Seq<A>>, HashSet<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Traverse<MSeq<HashSet<B>>, Seq<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `HashSet&lt;Seq&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Seq&lt;HashSet&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Seq<HashSet<A>> Sequence< A>(this HashSet<Seq<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Seq<B>> MapT< A, B>(this HashSet<Seq<A>> ma, Func<A, B> f) =>
            SeqTrans<MHashSet<Seq<A>>, HashSet<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Map<MHashSet<Seq<B>>, HashSet<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this HashSet<Seq<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MHashSet<Seq<A>>, HashSet<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this HashSet<Seq<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MHashSet<Seq<A>>, HashSet<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this HashSet<Seq<A>> ma, Func<A, bool> f) =>
            SeqTrans<MHashSet<Seq<A>>, HashSet<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this HashSet<Seq<A>> ma, Func<A, bool> f) =>
            SeqTrans<MHashSet<Seq<A>>, HashSet<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `HashSet&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this HashSet<Seq<A>> ma, Action<A> f) =>
            SeqTrans<MHashSet<Seq<A>>, HashSet<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;Seq&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<Seq<A>> FilterT< A>(this HashSet<Seq<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MHashSet<Seq<A>>, HashSet<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MHashSet<Seq<A>>, HashSet<Seq<A>>, MSeq<A>, Seq<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Seq&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<Seq<A>> PlusT<NUM,  A>(this HashSet<Seq<A>> x, HashSet<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Seq&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<Seq<A>> SubtractT<NUM,  A>(this HashSet<Seq<A>> x, HashSet<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static HashSet<Seq<A>> ProductT<NUM,  A>(this HashSet<Seq<A>> x, HashSet<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static HashSet<Seq<A>> DivideT<NUM,  A>(this HashSet<Seq<A>> x, HashSet<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static HashSet<Seq<A>> AppendT<SEMI,  A>(this HashSet<Seq<A>> x, HashSet<Seq<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this HashSet<Seq<A>> x, HashSet<Seq<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this HashSet<Seq<A>> x, HashSet<Seq<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `HashSet&lt;Seq&lt;A&gt;&gt;`</param>
        /// <returns>`HashSet&lt;Seq&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static HashSet<Seq<B>> ApplyT< A, B>(this Func<A, B> fab, HashSet<Seq<A>> fa) =>
            ApplHashSet< Seq<A>, Seq<B>>.Inst.Apply(
                 MHashSet< Func<Seq<A>, Seq<B>>>.Inst.Return((Seq<A> a) => ApplSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `HashSet&lt;Seq&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `HashSet&lt;Seq&lt;A&gt;&gt;`</param>
        /// <returns>`HashSet&lt;Seq&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static HashSet<Seq<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, HashSet<Seq<A>> fa, HashSet<Seq<B>> fb) =>
            ApplHashSet< Seq<A>, Seq<B>, Seq<C>>.Inst.Apply(
                MHashSet< Func<Seq<A>, Func<Seq<B>, Seq<C>>>>.Inst.Return(
                    (Seq<A> a) =>
                        (Seq<B> b) =>
                            ApplSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Lst&lt;Seq&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<Seq<C>> SelectMany< A, B, C>(
            this Lst<Seq<A>> ma,
            Func<A, Lst<Seq<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MLst<Seq<A>>, Lst<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MLst<Seq<C>>, Lst<Seq<C>>, MSeq<C>, Seq<C>, C>(ma, a =>
                    SeqTrans<MLst<Seq<B>>, Lst<Seq<B>>, MSeq<B>, Seq<B>, B>
                        .Inst.Bind<MLst<Seq<C>>, Lst<Seq<C>>, MSeq<C>, Seq<C>, C>(bind(a), b =>
                            default(MSeq<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;Seq&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<Seq<A>> Where< A>(this Lst<Seq<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MLst<Seq<A>>, Lst<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MLst<Seq<A>>, Lst<Seq<A>>, MSeq<A>, Seq<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Seq<B>> Select< A, B>(this Lst<Seq<A>> ma, Func<A, B> f) =>
            SeqTrans<MLst<Seq<A>>, Lst<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Map<MLst<Seq<B>>, Lst<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Lst&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Seq&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Lst&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Lst<Seq<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MLst<Seq<A>>, Lst<Seq<A>>, MSeq<A>, Seq<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Lst&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Seq&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Lst&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Lst<Seq<A>> ma) =>
            SeqTrans<MLst<Seq<A>>, Lst<Seq<A>>, MSeq<A>, Seq<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Seq<B>> BindT< A, B>(this Lst<Seq<A>> ma, Func<A, Seq<B>> f) =>
            SeqTrans<MLst<Seq<A>>, Lst<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MLst<Seq<B>>, Lst<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Seq<B>> BindT< A, B>(this Lst<Seq<A>> ma, Func<A, Lst<Seq<B>>> f) =>
            SeqTrans<MLst<Seq<A>>, Lst<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MLst<Seq<B>>, Lst<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Lst&lt;Seq&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Seq&lt;Lst&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;Lst&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Seq<Lst<B>> Traverse< A, B>(this Lst<Seq<A>> ma, Func<A, B> f) =>
            SeqTrans<MLst<Seq<A>>, Lst<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Traverse<MSeq<Lst<B>>, Seq<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Lst&lt;Seq&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Seq&lt;Lst&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Seq<Lst<A>> Sequence< A>(this Lst<Seq<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Seq<B>> MapT< A, B>(this Lst<Seq<A>> ma, Func<A, B> f) =>
            SeqTrans<MLst<Seq<A>>, Lst<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Map<MLst<Seq<B>>, Lst<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Lst<Seq<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MLst<Seq<A>>, Lst<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Lst<Seq<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MLst<Seq<A>>, Lst<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Lst<Seq<A>> ma, Func<A, bool> f) =>
            SeqTrans<MLst<Seq<A>>, Lst<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Lst<Seq<A>> ma, Func<A, bool> f) =>
            SeqTrans<MLst<Seq<A>>, Lst<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Lst&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Lst<Seq<A>> ma, Action<A> f) =>
            SeqTrans<MLst<Seq<A>>, Lst<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;Seq&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<Seq<A>> FilterT< A>(this Lst<Seq<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MLst<Seq<A>>, Lst<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MLst<Seq<A>>, Lst<Seq<A>>, MSeq<A>, Seq<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Seq&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Lst<Seq<A>> PlusT<NUM,  A>(this Lst<Seq<A>> x, Lst<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Seq&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Lst<Seq<A>> SubtractT<NUM,  A>(this Lst<Seq<A>> x, Lst<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Lst<Seq<A>> ProductT<NUM,  A>(this Lst<Seq<A>> x, Lst<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Lst<Seq<A>> DivideT<NUM,  A>(this Lst<Seq<A>> x, Lst<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Lst<Seq<A>> AppendT<SEMI,  A>(this Lst<Seq<A>> x, Lst<Seq<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Lst<Seq<A>> x, Lst<Seq<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Lst<Seq<A>> x, Lst<Seq<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Lst&lt;Seq&lt;A&gt;&gt;`</param>
        /// <returns>`Lst&lt;Seq&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Lst<Seq<B>> ApplyT< A, B>(this Func<A, B> fab, Lst<Seq<A>> fa) =>
            ApplLst< Seq<A>, Seq<B>>.Inst.Apply(
                 MLst< Func<Seq<A>, Seq<B>>>.Inst.Return((Seq<A> a) => ApplSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Lst&lt;Seq&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Lst&lt;Seq&lt;A&gt;&gt;`</param>
        /// <returns>`Lst&lt;Seq&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Lst<Seq<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Lst<Seq<A>> fa, Lst<Seq<B>> fb) =>
            ApplLst< Seq<A>, Seq<B>, Seq<C>>.Inst.Apply(
                MLst< Func<Seq<A>, Func<Seq<B>, Seq<C>>>>.Inst.Return(
                    (Seq<A> a) =>
                        (Seq<B> b) =>
                            ApplSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Option&lt;Seq&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Option<Seq<C>> SelectMany< A, B, C>(
            this Option<Seq<A>> ma,
            Func<A, Option<Seq<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MOption<Seq<A>>, Option<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MOption<Seq<C>>, Option<Seq<C>>, MSeq<C>, Seq<C>, C>(ma, a =>
                    Trans<MOption<Seq<B>>, Option<Seq<B>>, MSeq<B>, Seq<B>, B>
                        .Inst.Bind<MOption<Seq<C>>, Option<Seq<C>>, MSeq<C>, Seq<C>, C>(bind(a), b =>
                            default(MSeq<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;Seq&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<Seq<A>> Where< A>(this Option<Seq<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<Seq<A>>, Option<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MOption<Seq<A>>, Option<Seq<A>>, MSeq<A>, Seq<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Seq<B>> Select< A, B>(this Option<Seq<A>> ma, Func<A, B> f) =>
            Trans<MOption<Seq<A>>, Option<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Map<MOption<Seq<B>>, Option<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Option&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Seq&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Option&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Option<Seq<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<Seq<A>>, Option<Seq<A>>, MSeq<A>, Seq<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Option&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Seq&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Option&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Option<Seq<A>> ma) =>
            Trans<MOption<Seq<A>>, Option<Seq<A>>, MSeq<A>, Seq<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Seq<B>> BindT< A, B>(this Option<Seq<A>> ma, Func<A, Seq<B>> f) =>
            Trans<MOption<Seq<A>>, Option<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MOption<Seq<B>>, Option<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Seq<B>> BindT< A, B>(this Option<Seq<A>> ma, Func<A, Option<Seq<B>>> f) =>
            Trans<MOption<Seq<A>>, Option<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MOption<Seq<B>>, Option<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Option&lt;Seq&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Seq&lt;Option&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;Option&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Seq<Option<B>> Traverse< A, B>(this Option<Seq<A>> ma, Func<A, B> f) =>
            SeqTrans<MOption<Seq<A>>, Option<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Traverse<MSeq<Option<B>>, Seq<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Option&lt;Seq&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Seq&lt;Option&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Seq<Option<A>> Sequence< A>(this Option<Seq<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Seq<B>> MapT< A, B>(this Option<Seq<A>> ma, Func<A, B> f) =>
            Trans<MOption<Seq<A>>, Option<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Map<MOption<Seq<B>>, Option<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Option<Seq<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Seq<A>>, Option<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Option<Seq<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Seq<A>>, Option<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Option<Seq<A>> ma, Func<A, bool> f) =>
            Trans<MOption<Seq<A>>, Option<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Option<Seq<A>> ma, Func<A, bool> f) =>
            Trans<MOption<Seq<A>>, Option<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Option&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Option<Seq<A>> ma, Action<A> f) =>
            Trans<MOption<Seq<A>>, Option<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;Seq&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<Seq<A>> FilterT< A>(this Option<Seq<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<Seq<A>>, Option<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MOption<Seq<A>>, Option<Seq<A>>, MSeq<A>, Seq<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Seq&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Option<Seq<A>> PlusT<NUM,  A>(this Option<Seq<A>> x, Option<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Seq&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Option<Seq<A>> SubtractT<NUM,  A>(this Option<Seq<A>> x, Option<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Option<Seq<A>> ProductT<NUM,  A>(this Option<Seq<A>> x, Option<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Option<Seq<A>> DivideT<NUM,  A>(this Option<Seq<A>> x, Option<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Option<Seq<A>> AppendT<SEMI,  A>(this Option<Seq<A>> x, Option<Seq<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Option<Seq<A>> x, Option<Seq<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Option<Seq<A>> x, Option<Seq<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Option&lt;Seq&lt;A&gt;&gt;`</param>
        /// <returns>`Option&lt;Seq&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Option<Seq<B>> ApplyT< A, B>(this Func<A, B> fab, Option<Seq<A>> fa) =>
            ApplOption< Seq<A>, Seq<B>>.Inst.Apply(
                 MOption< Func<Seq<A>, Seq<B>>>.Inst.Return((Seq<A> a) => ApplSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Option&lt;Seq&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Option&lt;Seq&lt;A&gt;&gt;`</param>
        /// <returns>`Option&lt;Seq&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Option<Seq<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Option<Seq<A>> fa, Option<Seq<B>> fb) =>
            ApplOption< Seq<A>, Seq<B>, Seq<C>>.Inst.Apply(
                MOption< Func<Seq<A>, Func<Seq<B>, Seq<C>>>>.Inst.Return(
                    (Seq<A> a) =>
                        (Seq<B> b) =>
                            ApplSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionUnsafe&lt;Seq&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<Seq<C>> SelectMany< A, B, C>(
            this OptionUnsafe<Seq<A>> ma,
            Func<A, OptionUnsafe<Seq<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MOptionUnsafe<Seq<A>>, OptionUnsafe<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MOptionUnsafe<Seq<C>>, OptionUnsafe<Seq<C>>, MSeq<C>, Seq<C>, C>(ma, a =>
                    Trans<MOptionUnsafe<Seq<B>>, OptionUnsafe<Seq<B>>, MSeq<B>, Seq<B>, B>
                        .Inst.Bind<MOptionUnsafe<Seq<C>>, OptionUnsafe<Seq<C>>, MSeq<C>, Seq<C>, C>(bind(a), b =>
                            default(MSeq<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;Seq&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<Seq<A>> Where< A>(this OptionUnsafe<Seq<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<Seq<A>>, OptionUnsafe<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MOptionUnsafe<Seq<A>>, OptionUnsafe<Seq<A>>, MSeq<A>, Seq<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Seq<B>> Select< A, B>(this OptionUnsafe<Seq<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Seq<A>>, OptionUnsafe<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Map<MOptionUnsafe<Seq<B>>, OptionUnsafe<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionUnsafe&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Seq&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionUnsafe&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this OptionUnsafe<Seq<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<Seq<A>>, OptionUnsafe<Seq<A>>, MSeq<A>, Seq<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionUnsafe&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Seq&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionUnsafe&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this OptionUnsafe<Seq<A>> ma) =>
            Trans<MOptionUnsafe<Seq<A>>, OptionUnsafe<Seq<A>>, MSeq<A>, Seq<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Seq<B>> BindT< A, B>(this OptionUnsafe<Seq<A>> ma, Func<A, Seq<B>> f) =>
            Trans<MOptionUnsafe<Seq<A>>, OptionUnsafe<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MOptionUnsafe<Seq<B>>, OptionUnsafe<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Seq<B>> BindT< A, B>(this OptionUnsafe<Seq<A>> ma, Func<A, OptionUnsafe<Seq<B>>> f) =>
            Trans<MOptionUnsafe<Seq<A>>, OptionUnsafe<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MOptionUnsafe<Seq<B>>, OptionUnsafe<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionUnsafe&lt;Seq&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Seq&lt;OptionUnsafe&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;OptionUnsafe&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Seq<OptionUnsafe<B>> Traverse< A, B>(this OptionUnsafe<Seq<A>> ma, Func<A, B> f) =>
            SeqTrans<MOptionUnsafe<Seq<A>>, OptionUnsafe<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Traverse<MSeq<OptionUnsafe<B>>, Seq<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionUnsafe&lt;Seq&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Seq&lt;OptionUnsafe&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Seq<OptionUnsafe<A>> Sequence< A>(this OptionUnsafe<Seq<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Seq<B>> MapT< A, B>(this OptionUnsafe<Seq<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Seq<A>>, OptionUnsafe<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Map<MOptionUnsafe<Seq<B>>, OptionUnsafe<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this OptionUnsafe<Seq<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Seq<A>>, OptionUnsafe<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this OptionUnsafe<Seq<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Seq<A>>, OptionUnsafe<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this OptionUnsafe<Seq<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Seq<A>>, OptionUnsafe<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this OptionUnsafe<Seq<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Seq<A>>, OptionUnsafe<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionUnsafe&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this OptionUnsafe<Seq<A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<Seq<A>>, OptionUnsafe<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;Seq&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<Seq<A>> FilterT< A>(this OptionUnsafe<Seq<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<Seq<A>>, OptionUnsafe<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MOptionUnsafe<Seq<A>>, OptionUnsafe<Seq<A>>, MSeq<A>, Seq<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Seq&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<Seq<A>> PlusT<NUM,  A>(this OptionUnsafe<Seq<A>> x, OptionUnsafe<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Seq&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<Seq<A>> SubtractT<NUM,  A>(this OptionUnsafe<Seq<A>> x, OptionUnsafe<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionUnsafe<Seq<A>> ProductT<NUM,  A>(this OptionUnsafe<Seq<A>> x, OptionUnsafe<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionUnsafe<Seq<A>> DivideT<NUM,  A>(this OptionUnsafe<Seq<A>> x, OptionUnsafe<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionUnsafe<Seq<A>> AppendT<SEMI,  A>(this OptionUnsafe<Seq<A>> x, OptionUnsafe<Seq<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this OptionUnsafe<Seq<A>> x, OptionUnsafe<Seq<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this OptionUnsafe<Seq<A>> x, OptionUnsafe<Seq<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe&lt;Seq&lt;A&gt;&gt;`</param>
        /// <returns>`OptionUnsafe&lt;Seq&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionUnsafe<Seq<B>> ApplyT< A, B>(this Func<A, B> fab, OptionUnsafe<Seq<A>> fa) =>
            ApplOptionUnsafe< Seq<A>, Seq<B>>.Inst.Apply(
                 MOptionUnsafe< Func<Seq<A>, Seq<B>>>.Inst.Return((Seq<A> a) => ApplSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe&lt;Seq&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `OptionUnsafe&lt;Seq&lt;A&gt;&gt;`</param>
        /// <returns>`OptionUnsafe&lt;Seq&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionUnsafe<Seq<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, OptionUnsafe<Seq<A>> fa, OptionUnsafe<Seq<B>> fb) =>
            ApplOptionUnsafe< Seq<A>, Seq<B>, Seq<C>>.Inst.Apply(
                MOptionUnsafe< Func<Seq<A>, Func<Seq<B>, Seq<C>>>>.Inst.Return(
                    (Seq<A> a) =>
                        (Seq<B> b) =>
                            ApplSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Either&lt;L, Seq&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, Seq<C>> SelectMany<L, A, B, C>(
            this Either<L, Seq<A>> ma,
            Func<A, Either<L, Seq<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MEither<L, Seq<A>>, Either<L, Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MEither<L, Seq<C>>, Either<L, Seq<C>>, MSeq<C>, Seq<C>, C>(ma, a =>
                    Trans<MEither<L, Seq<B>>, Either<L, Seq<B>>, MSeq<B>, Seq<B>, B>
                        .Inst.Bind<MEither<L, Seq<C>>, Either<L, Seq<C>>, MSeq<C>, Seq<C>, C>(bind(a), b =>
                            default(MSeq<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, Seq&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, Seq<A>> Where<L, A>(this Either<L, Seq<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, Seq<A>>, Either<L, Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MEither<L, Seq<A>>, Either<L, Seq<A>>, MSeq<A>, Seq<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Seq<B>> Select<L, A, B>(this Either<L, Seq<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Seq<A>>, Either<L, Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Map<MEither<L, Seq<B>>, Either<L, Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Either&lt;L, Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Seq&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Either&lt;L, Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Either<L, Seq<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, Seq<A>>, Either<L, Seq<A>>, MSeq<A>, Seq<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Either&lt;L, Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Seq&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Either&lt;L, Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this Either<L, Seq<A>> ma) =>
            Trans<MEither<L, Seq<A>>, Either<L, Seq<A>>, MSeq<A>, Seq<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either&lt;L, Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Seq<B>> BindT<L, A, B>(this Either<L, Seq<A>> ma, Func<A, Seq<B>> f) =>
            Trans<MEither<L, Seq<A>>, Either<L, Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MEither<L, Seq<B>>, Either<L, Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either&lt;L, Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Seq<B>> BindT<L, A, B>(this Either<L, Seq<A>> ma, Func<A, Either<L, Seq<B>>> f) =>
            Trans<MEither<L, Seq<A>>, Either<L, Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MEither<L, Seq<B>>, Either<L, Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Either&lt;L, Seq&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Seq&lt;Either&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;Either&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static Seq<Either<L, B>> Traverse<L, A, B>(this Either<L, Seq<A>> ma, Func<A, B> f) =>
            SeqTrans<MEither<L, Seq<A>>, Either<L, Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Traverse<MSeq<Either<L, B>>, Seq<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Either&lt;L, Seq&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Seq&lt;Either&lt;L, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static Seq<Either<L, A>> Sequence<L, A>(this Either<L, Seq<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Seq<B>> MapT<L, A, B>(this Either<L, Seq<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Seq<A>>, Either<L, Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Map<MEither<L, Seq<B>>, Either<L, Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Either<L, Seq<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Seq<A>>, Either<L, Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Either<L, Seq<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Seq<A>>, Either<L, Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Either<L, Seq<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Seq<A>>, Either<L, Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Either<L, Seq<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Seq<A>>, Either<L, Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Either&lt;L, Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Either<L, Seq<A>> ma, Action<A> f) =>
            Trans<MEither<L, Seq<A>>, Either<L, Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, Seq&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, Seq<A>> FilterT<L, A>(this Either<L, Seq<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, Seq<A>>, Either<L, Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MEither<L, Seq<A>>, Either<L, Seq<A>>, MSeq<A>, Seq<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Seq&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, Seq<A>> PlusT<NUM, L, A>(this Either<L, Seq<A>> x, Either<L, Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Seq&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, Seq<A>> SubtractT<NUM, L, A>(this Either<L, Seq<A>> x, Either<L, Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Seq&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Either<L, Seq<A>> ProductT<NUM, L, A>(this Either<L, Seq<A>> x, Either<L, Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Seq&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Either<L, Seq<A>> DivideT<NUM, L, A>(this Either<L, Seq<A>> x, Either<L, Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Seq&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Either<L, Seq<A>> AppendT<SEMI, L, A>(this Either<L, Seq<A>> x, Either<L, Seq<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Either<L, Seq<A>> x, Either<L, Seq<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Seq&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Either<L, Seq<A>> x, Either<L, Seq<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Either&lt;L, Seq&lt;A&gt;&gt;`</param>
        /// <returns>`Either&lt;L, Seq&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Either<L, Seq<B>> ApplyT<L, A, B>(this Func<A, B> fab, Either<L, Seq<A>> fa) =>
            ApplEither<L, Seq<A>, Seq<B>>.Inst.Apply(
                 MEither<L, Func<Seq<A>, Seq<B>>>.Inst.Return((Seq<A> a) => ApplSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Either&lt;L, Seq&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Either&lt;L, Seq&lt;A&gt;&gt;`</param>
        /// <returns>`Either&lt;L, Seq&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Either<L, Seq<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Either<L, Seq<A>> fa, Either<L, Seq<B>> fb) =>
            ApplEither<L, Seq<A>, Seq<B>, Seq<C>>.Inst.Apply(
                MEither<L, Func<Seq<A>, Func<Seq<B>, Seq<C>>>>.Inst.Return(
                    (Seq<A> a) =>
                        (Seq<B> b) =>
                            ApplSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`EitherUnsafe&lt;L, Seq&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, Seq<C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, Seq<A>> ma,
            Func<A, EitherUnsafe<L, Seq<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MEitherUnsafe<L, Seq<A>>, EitherUnsafe<L, Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Seq<C>>, EitherUnsafe<L, Seq<C>>, MSeq<C>, Seq<C>, C>(ma, a =>
                    Trans<MEitherUnsafe<L, Seq<B>>, EitherUnsafe<L, Seq<B>>, MSeq<B>, Seq<B>, B>
                        .Inst.Bind<MEitherUnsafe<L, Seq<C>>, EitherUnsafe<L, Seq<C>>, MSeq<C>, Seq<C>, C>(bind(a), b =>
                            default(MSeq<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, Seq&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, Seq<A>> Where<L, A>(this EitherUnsafe<L, Seq<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, Seq<A>>, EitherUnsafe<L, Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Seq<A>>, EitherUnsafe<L, Seq<A>>, MSeq<A>, Seq<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Seq<B>> Select<L, A, B>(this EitherUnsafe<L, Seq<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Seq<A>>, EitherUnsafe<L, Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Map<MEitherUnsafe<L, Seq<B>>, EitherUnsafe<L, Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherUnsafe&lt;L, Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Seq&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherUnsafe&lt;L, Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this EitherUnsafe<L, Seq<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, Seq<A>>, EitherUnsafe<L, Seq<A>>, MSeq<A>, Seq<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherUnsafe&lt;L, Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Seq&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherUnsafe&lt;L, Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this EitherUnsafe<L, Seq<A>> ma) =>
            Trans<MEitherUnsafe<L, Seq<A>>, EitherUnsafe<L, Seq<A>>, MSeq<A>, Seq<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Seq<B>> BindT<L, A, B>(this EitherUnsafe<L, Seq<A>> ma, Func<A, Seq<B>> f) =>
            Trans<MEitherUnsafe<L, Seq<A>>, EitherUnsafe<L, Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Seq<B>>, EitherUnsafe<L, Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Seq<B>> BindT<L, A, B>(this EitherUnsafe<L, Seq<A>> ma, Func<A, EitherUnsafe<L, Seq<B>>> f) =>
            Trans<MEitherUnsafe<L, Seq<A>>, EitherUnsafe<L, Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Seq<B>>, EitherUnsafe<L, Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `EitherUnsafe&lt;L, Seq&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Seq&lt;EitherUnsafe&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;EitherUnsafe&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static Seq<EitherUnsafe<L, B>> Traverse<L, A, B>(this EitherUnsafe<L, Seq<A>> ma, Func<A, B> f) =>
            SeqTrans<MEitherUnsafe<L, Seq<A>>, EitherUnsafe<L, Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Traverse<MSeq<EitherUnsafe<L, B>>, Seq<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `EitherUnsafe&lt;L, Seq&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Seq&lt;EitherUnsafe&lt;L, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static Seq<EitherUnsafe<L, A>> Sequence<L, A>(this EitherUnsafe<L, Seq<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Seq<B>> MapT<L, A, B>(this EitherUnsafe<L, Seq<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Seq<A>>, EitherUnsafe<L, Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Map<MEitherUnsafe<L, Seq<B>>, EitherUnsafe<L, Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this EitherUnsafe<L, Seq<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Seq<A>>, EitherUnsafe<L, Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this EitherUnsafe<L, Seq<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Seq<A>>, EitherUnsafe<L, Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this EitherUnsafe<L, Seq<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Seq<A>>, EitherUnsafe<L, Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this EitherUnsafe<L, Seq<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Seq<A>>, EitherUnsafe<L, Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherUnsafe&lt;L, Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this EitherUnsafe<L, Seq<A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, Seq<A>>, EitherUnsafe<L, Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, Seq&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, Seq<A>> FilterT<L, A>(this EitherUnsafe<L, Seq<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, Seq<A>>, EitherUnsafe<L, Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Seq<A>>, EitherUnsafe<L, Seq<A>>, MSeq<A>, Seq<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Seq&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, Seq<A>> PlusT<NUM, L, A>(this EitherUnsafe<L, Seq<A>> x, EitherUnsafe<L, Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Seq&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, Seq<A>> SubtractT<NUM, L, A>(this EitherUnsafe<L, Seq<A>> x, EitherUnsafe<L, Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Seq&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherUnsafe<L, Seq<A>> ProductT<NUM, L, A>(this EitherUnsafe<L, Seq<A>> x, EitherUnsafe<L, Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Seq&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherUnsafe<L, Seq<A>> DivideT<NUM, L, A>(this EitherUnsafe<L, Seq<A>> x, EitherUnsafe<L, Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Seq&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherUnsafe<L, Seq<A>> AppendT<SEMI, L, A>(this EitherUnsafe<L, Seq<A>> x, EitherUnsafe<L, Seq<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this EitherUnsafe<L, Seq<A>> x, EitherUnsafe<L, Seq<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Seq&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this EitherUnsafe<L, Seq<A>> x, EitherUnsafe<L, Seq<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe&lt;L, Seq&lt;A&gt;&gt;`</param>
        /// <returns>`EitherUnsafe&lt;L, Seq&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherUnsafe<L, Seq<B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherUnsafe<L, Seq<A>> fa) =>
            ApplEitherUnsafe<L, Seq<A>, Seq<B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<Seq<A>, Seq<B>>>.Inst.Return((Seq<A> a) => ApplSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe&lt;L, Seq&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `EitherUnsafe&lt;L, Seq&lt;A&gt;&gt;`</param>
        /// <returns>`EitherUnsafe&lt;L, Seq&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherUnsafe<L, Seq<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherUnsafe<L, Seq<A>> fa, EitherUnsafe<L, Seq<B>> fb) =>
            ApplEitherUnsafe<L, Seq<A>, Seq<B>, Seq<C>>.Inst.Apply(
                MEitherUnsafe<L, Func<Seq<A>, Func<Seq<B>, Seq<C>>>>.Inst.Return(
                    (Seq<A> a) =>
                        (Seq<B> b) =>
                            ApplSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Try&lt;Seq&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Try<Seq<C>> SelectMany< A, B, C>(
            this Try<Seq<A>> ma,
            Func<A, Try<Seq<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MTry<Seq<A>>, Try<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MTry<Seq<C>>, Try<Seq<C>>, MSeq<C>, Seq<C>, C>(ma, a =>
                    Trans<MTry<Seq<B>>, Try<Seq<B>>, MSeq<B>, Seq<B>, B>
                        .Inst.Bind<MTry<Seq<C>>, Try<Seq<C>>, MSeq<C>, Seq<C>, C>(bind(a), b =>
                            default(MSeq<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;Seq&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<Seq<A>> Where< A>(this Try<Seq<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<Seq<A>>, Try<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MTry<Seq<A>>, Try<Seq<A>>, MSeq<A>, Seq<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Seq<B>> Select< A, B>(this Try<Seq<A>> ma, Func<A, B> f) =>
            Trans<MTry<Seq<A>>, Try<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Map<MTry<Seq<B>>, Try<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Try&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Seq&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Try&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Try<Seq<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<Seq<A>>, Try<Seq<A>>, MSeq<A>, Seq<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Try&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Seq&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Try&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Try<Seq<A>> ma) =>
            Trans<MTry<Seq<A>>, Try<Seq<A>>, MSeq<A>, Seq<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Seq<B>> BindT< A, B>(this Try<Seq<A>> ma, Func<A, Seq<B>> f) =>
            Trans<MTry<Seq<A>>, Try<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MTry<Seq<B>>, Try<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Seq<B>> BindT< A, B>(this Try<Seq<A>> ma, Func<A, Try<Seq<B>>> f) =>
            Trans<MTry<Seq<A>>, Try<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MTry<Seq<B>>, Try<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Try&lt;Seq&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Seq&lt;Try&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;Try&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Seq<Try<B>> Traverse< A, B>(this Try<Seq<A>> ma, Func<A, B> f) =>
            SeqTrans<MTry<Seq<A>>, Try<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Traverse<MSeq<Try<B>>, Seq<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Try&lt;Seq&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Seq&lt;Try&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Seq<Try<A>> Sequence< A>(this Try<Seq<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Seq<B>> MapT< A, B>(this Try<Seq<A>> ma, Func<A, B> f) =>
            Trans<MTry<Seq<A>>, Try<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Map<MTry<Seq<B>>, Try<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Try<Seq<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Seq<A>>, Try<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Try<Seq<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Seq<A>>, Try<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Try<Seq<A>> ma, Func<A, bool> f) =>
            Trans<MTry<Seq<A>>, Try<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Try<Seq<A>> ma, Func<A, bool> f) =>
            Trans<MTry<Seq<A>>, Try<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Try&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Try<Seq<A>> ma, Action<A> f) =>
            Trans<MTry<Seq<A>>, Try<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;Seq&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<Seq<A>> FilterT< A>(this Try<Seq<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<Seq<A>>, Try<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MTry<Seq<A>>, Try<Seq<A>>, MSeq<A>, Seq<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Seq&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Try<Seq<A>> PlusT<NUM,  A>(this Try<Seq<A>> x, Try<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Seq&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Try<Seq<A>> SubtractT<NUM,  A>(this Try<Seq<A>> x, Try<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Try<Seq<A>> ProductT<NUM,  A>(this Try<Seq<A>> x, Try<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Try<Seq<A>> DivideT<NUM,  A>(this Try<Seq<A>> x, Try<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Try<Seq<A>> AppendT<SEMI,  A>(this Try<Seq<A>> x, Try<Seq<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Try<Seq<A>> x, Try<Seq<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Try<Seq<A>> x, Try<Seq<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Try&lt;Seq&lt;A&gt;&gt;`</param>
        /// <returns>`Try&lt;Seq&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Try<Seq<B>> ApplyT< A, B>(this Func<A, B> fab, Try<Seq<A>> fa) =>
            ApplTry< Seq<A>, Seq<B>>.Inst.Apply(
                 MTry< Func<Seq<A>, Seq<B>>>.Inst.Return((Seq<A> a) => ApplSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Try&lt;Seq&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Try&lt;Seq&lt;A&gt;&gt;`</param>
        /// <returns>`Try&lt;Seq&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Try<Seq<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Try<Seq<A>> fa, Try<Seq<B>> fb) =>
            ApplTry< Seq<A>, Seq<B>, Seq<C>>.Inst.Apply(
                MTry< Func<Seq<A>, Func<Seq<B>, Seq<C>>>>.Inst.Return(
                    (Seq<A> a) =>
                        (Seq<B> b) =>
                            ApplSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOption&lt;Seq&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<Seq<C>> SelectMany< A, B, C>(
            this TryOption<Seq<A>> ma,
            Func<A, TryOption<Seq<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MTryOption<Seq<A>>, TryOption<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MTryOption<Seq<C>>, TryOption<Seq<C>>, MSeq<C>, Seq<C>, C>(ma, a =>
                    Trans<MTryOption<Seq<B>>, TryOption<Seq<B>>, MSeq<B>, Seq<B>, B>
                        .Inst.Bind<MTryOption<Seq<C>>, TryOption<Seq<C>>, MSeq<C>, Seq<C>, C>(bind(a), b =>
                            default(MSeq<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;Seq&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<Seq<A>> Where< A>(this TryOption<Seq<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<Seq<A>>, TryOption<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MTryOption<Seq<A>>, TryOption<Seq<A>>, MSeq<A>, Seq<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Seq<B>> Select< A, B>(this TryOption<Seq<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Seq<A>>, TryOption<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Map<MTryOption<Seq<B>>, TryOption<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOption&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Seq&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOption&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryOption<Seq<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<Seq<A>>, TryOption<Seq<A>>, MSeq<A>, Seq<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOption&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Seq&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOption&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this TryOption<Seq<A>> ma) =>
            Trans<MTryOption<Seq<A>>, TryOption<Seq<A>>, MSeq<A>, Seq<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Seq<B>> BindT< A, B>(this TryOption<Seq<A>> ma, Func<A, Seq<B>> f) =>
            Trans<MTryOption<Seq<A>>, TryOption<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MTryOption<Seq<B>>, TryOption<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Seq<B>> BindT< A, B>(this TryOption<Seq<A>> ma, Func<A, TryOption<Seq<B>>> f) =>
            Trans<MTryOption<Seq<A>>, TryOption<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MTryOption<Seq<B>>, TryOption<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOption&lt;Seq&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Seq&lt;TryOption&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;TryOption&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Seq<TryOption<B>> Traverse< A, B>(this TryOption<Seq<A>> ma, Func<A, B> f) =>
            SeqTrans<MTryOption<Seq<A>>, TryOption<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Traverse<MSeq<TryOption<B>>, Seq<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOption&lt;Seq&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Seq&lt;TryOption&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Seq<TryOption<A>> Sequence< A>(this TryOption<Seq<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Seq<B>> MapT< A, B>(this TryOption<Seq<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Seq<A>>, TryOption<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Map<MTryOption<Seq<B>>, TryOption<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryOption<Seq<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Seq<A>>, TryOption<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryOption<Seq<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Seq<A>>, TryOption<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryOption<Seq<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Seq<A>>, TryOption<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryOption<Seq<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Seq<A>>, TryOption<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOption&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryOption<Seq<A>> ma, Action<A> f) =>
            Trans<MTryOption<Seq<A>>, TryOption<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;Seq&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<Seq<A>> FilterT< A>(this TryOption<Seq<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<Seq<A>>, TryOption<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MTryOption<Seq<A>>, TryOption<Seq<A>>, MSeq<A>, Seq<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Seq&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<Seq<A>> PlusT<NUM,  A>(this TryOption<Seq<A>> x, TryOption<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Seq&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<Seq<A>> SubtractT<NUM,  A>(this TryOption<Seq<A>> x, TryOption<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOption<Seq<A>> ProductT<NUM,  A>(this TryOption<Seq<A>> x, TryOption<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOption<Seq<A>> DivideT<NUM,  A>(this TryOption<Seq<A>> x, TryOption<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOption<Seq<A>> AppendT<SEMI,  A>(this TryOption<Seq<A>> x, TryOption<Seq<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryOption<Seq<A>> x, TryOption<Seq<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryOption<Seq<A>> x, TryOption<Seq<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOption&lt;Seq&lt;A&gt;&gt;`</param>
        /// <returns>`TryOption&lt;Seq&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOption<Seq<B>> ApplyT< A, B>(this Func<A, B> fab, TryOption<Seq<A>> fa) =>
            ApplTryOption< Seq<A>, Seq<B>>.Inst.Apply(
                 MTryOption< Func<Seq<A>, Seq<B>>>.Inst.Return((Seq<A> a) => ApplSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOption&lt;Seq&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryOption&lt;Seq&lt;A&gt;&gt;`</param>
        /// <returns>`TryOption&lt;Seq&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOption<Seq<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOption<Seq<A>> fa, TryOption<Seq<B>> fb) =>
            ApplTryOption< Seq<A>, Seq<B>, Seq<C>>.Inst.Apply(
                MTryOption< Func<Seq<A>, Func<Seq<B>, Seq<C>>>>.Inst.Return(
                    (Seq<A> a) =>
                        (Seq<B> b) =>
                            ApplSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`IEnumerable&lt;Seq&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<Seq<C>> SelectMany< A, B, C>(
            this IEnumerable<Seq<A>> ma,
            Func<A, IEnumerable<Seq<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MEnumerable<Seq<A>>, IEnumerable<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MEnumerable<Seq<C>>, IEnumerable<Seq<C>>, MSeq<C>, Seq<C>, C>(ma, a =>
                    SeqTrans<MEnumerable<Seq<B>>, IEnumerable<Seq<B>>, MSeq<B>, Seq<B>, B>
                        .Inst.Bind<MEnumerable<Seq<C>>, IEnumerable<Seq<C>>, MSeq<C>, Seq<C>, C>(bind(a), b =>
                            default(MSeq<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;Seq&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<Seq<A>> Where< A>(this IEnumerable<Seq<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MEnumerable<Seq<A>>, IEnumerable<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MEnumerable<Seq<A>>, IEnumerable<Seq<A>>, MSeq<A>, Seq<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Seq<B>> Select< A, B>(this IEnumerable<Seq<A>> ma, Func<A, B> f) =>
            SeqTrans<MEnumerable<Seq<A>>, IEnumerable<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Map<MEnumerable<Seq<B>>, IEnumerable<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `IEnumerable&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Seq&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `IEnumerable&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this IEnumerable<Seq<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MEnumerable<Seq<A>>, IEnumerable<Seq<A>>, MSeq<A>, Seq<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `IEnumerable&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Seq&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `IEnumerable&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this IEnumerable<Seq<A>> ma) =>
            SeqTrans<MEnumerable<Seq<A>>, IEnumerable<Seq<A>>, MSeq<A>, Seq<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Seq<B>> BindT< A, B>(this IEnumerable<Seq<A>> ma, Func<A, Seq<B>> f) =>
            SeqTrans<MEnumerable<Seq<A>>, IEnumerable<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MEnumerable<Seq<B>>, IEnumerable<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Seq<B>> BindT< A, B>(this IEnumerable<Seq<A>> ma, Func<A, IEnumerable<Seq<B>>> f) =>
            SeqTrans<MEnumerable<Seq<A>>, IEnumerable<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MEnumerable<Seq<B>>, IEnumerable<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `IEnumerable&lt;Seq&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Seq&lt;IEnumerable&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;IEnumerable&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Seq<IEnumerable<B>> Traverse< A, B>(this IEnumerable<Seq<A>> ma, Func<A, B> f) =>
            SeqTrans<MEnumerable<Seq<A>>, IEnumerable<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Traverse<MSeq<IEnumerable<B>>, Seq<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `IEnumerable&lt;Seq&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Seq&lt;IEnumerable&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Seq<IEnumerable<A>> Sequence< A>(this IEnumerable<Seq<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Seq<B>> MapT< A, B>(this IEnumerable<Seq<A>> ma, Func<A, B> f) =>
            SeqTrans<MEnumerable<Seq<A>>, IEnumerable<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Map<MEnumerable<Seq<B>>, IEnumerable<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this IEnumerable<Seq<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MEnumerable<Seq<A>>, IEnumerable<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this IEnumerable<Seq<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MEnumerable<Seq<A>>, IEnumerable<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this IEnumerable<Seq<A>> ma, Func<A, bool> f) =>
            SeqTrans<MEnumerable<Seq<A>>, IEnumerable<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this IEnumerable<Seq<A>> ma, Func<A, bool> f) =>
            SeqTrans<MEnumerable<Seq<A>>, IEnumerable<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `IEnumerable&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this IEnumerable<Seq<A>> ma, Action<A> f) =>
            SeqTrans<MEnumerable<Seq<A>>, IEnumerable<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;Seq&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<Seq<A>> FilterT< A>(this IEnumerable<Seq<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MEnumerable<Seq<A>>, IEnumerable<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MEnumerable<Seq<A>>, IEnumerable<Seq<A>>, MSeq<A>, Seq<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Seq&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<Seq<A>> PlusT<NUM,  A>(this IEnumerable<Seq<A>> x, IEnumerable<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Seq&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<Seq<A>> SubtractT<NUM,  A>(this IEnumerable<Seq<A>> x, IEnumerable<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static IEnumerable<Seq<A>> ProductT<NUM,  A>(this IEnumerable<Seq<A>> x, IEnumerable<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static IEnumerable<Seq<A>> DivideT<NUM,  A>(this IEnumerable<Seq<A>> x, IEnumerable<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static IEnumerable<Seq<A>> AppendT<SEMI,  A>(this IEnumerable<Seq<A>> x, IEnumerable<Seq<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this IEnumerable<Seq<A>> x, IEnumerable<Seq<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this IEnumerable<Seq<A>> x, IEnumerable<Seq<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `IEnumerable&lt;Seq&lt;A&gt;&gt;`</param>
        /// <returns>`IEnumerable&lt;Seq&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static IEnumerable<Seq<B>> ApplyT< A, B>(this Func<A, B> fab, IEnumerable<Seq<A>> fa) =>
            ApplEnumerable< Seq<A>, Seq<B>>.Inst.Apply(
                 MEnumerable< Func<Seq<A>, Seq<B>>>.Inst.Return((Seq<A> a) => ApplSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `IEnumerable&lt;Seq&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `IEnumerable&lt;Seq&lt;A&gt;&gt;`</param>
        /// <returns>`IEnumerable&lt;Seq&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static IEnumerable<Seq<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, IEnumerable<Seq<A>> fa, IEnumerable<Seq<B>> fb) =>
            ApplEnumerable< Seq<A>, Seq<B>, Seq<C>>.Inst.Apply(
                MEnumerable< Func<Seq<A>, Func<Seq<B>, Seq<C>>>>.Inst.Return(
                    (Seq<A> a) =>
                        (Seq<B> b) =>
                            ApplSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Seq&lt;Seq&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Seq<Seq<C>> SelectMany< A, B, C>(
            this Seq<Seq<A>> ma,
            Func<A, Seq<Seq<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MSeq<Seq<A>>, Seq<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MSeq<Seq<C>>, Seq<Seq<C>>, MSeq<C>, Seq<C>, C>(ma, a =>
                    SeqTrans<MSeq<Seq<B>>, Seq<Seq<B>>, MSeq<B>, Seq<B>, B>
                        .Inst.Bind<MSeq<Seq<C>>, Seq<Seq<C>>, MSeq<C>, Seq<C>, C>(bind(a), b =>
                            default(MSeq<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;Seq&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<Seq<A>> Where< A>(this Seq<Seq<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSeq<Seq<A>>, Seq<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MSeq<Seq<A>>, Seq<Seq<A>>, MSeq<A>, Seq<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<Seq<B>> Select< A, B>(this Seq<Seq<A>> ma, Func<A, B> f) =>
            SeqTrans<MSeq<Seq<A>>, Seq<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Map<MSeq<Seq<B>>, Seq<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Seq&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Seq&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Seq&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Seq<Seq<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MSeq<Seq<A>>, Seq<Seq<A>>, MSeq<A>, Seq<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Seq&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Seq&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Seq&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Seq<Seq<A>> ma) =>
            SeqTrans<MSeq<Seq<A>>, Seq<Seq<A>>, MSeq<A>, Seq<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Seq&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<Seq<B>> BindT< A, B>(this Seq<Seq<A>> ma, Func<A, Seq<B>> f) =>
            SeqTrans<MSeq<Seq<A>>, Seq<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MSeq<Seq<B>>, Seq<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Seq&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<Seq<B>> BindT< A, B>(this Seq<Seq<A>> ma, Func<A, Seq<Seq<B>>> f) =>
            SeqTrans<MSeq<Seq<A>>, Seq<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MSeq<Seq<B>>, Seq<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Seq&lt;Seq&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Seq&lt;Seq&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;Seq&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Seq<Seq<B>> Traverse< A, B>(this Seq<Seq<A>> ma, Func<A, B> f) =>
            SeqTrans<MSeq<Seq<A>>, Seq<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Traverse<MSeq<Seq<B>>, Seq<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Seq&lt;Seq&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Seq&lt;Seq&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Seq<Seq<A>> Sequence< A>(this Seq<Seq<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<Seq<B>> MapT< A, B>(this Seq<Seq<A>> ma, Func<A, B> f) =>
            SeqTrans<MSeq<Seq<A>>, Seq<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Map<MSeq<Seq<B>>, Seq<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Seq<Seq<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSeq<Seq<A>>, Seq<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Seq<Seq<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSeq<Seq<A>>, Seq<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Seq<Seq<A>> ma, Func<A, bool> f) =>
            SeqTrans<MSeq<Seq<A>>, Seq<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Seq<Seq<A>> ma, Func<A, bool> f) =>
            SeqTrans<MSeq<Seq<A>>, Seq<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Seq&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Seq<Seq<A>> ma, Action<A> f) =>
            SeqTrans<MSeq<Seq<A>>, Seq<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;Seq&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<Seq<A>> FilterT< A>(this Seq<Seq<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSeq<Seq<A>>, Seq<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MSeq<Seq<A>>, Seq<Seq<A>>, MSeq<A>, Seq<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Seq&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Seq<Seq<A>> PlusT<NUM,  A>(this Seq<Seq<A>> x, Seq<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Seq&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Seq<Seq<A>> SubtractT<NUM,  A>(this Seq<Seq<A>> x, Seq<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Seq<Seq<A>> ProductT<NUM,  A>(this Seq<Seq<A>> x, Seq<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Seq<Seq<A>> DivideT<NUM,  A>(this Seq<Seq<A>> x, Seq<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Seq<Seq<A>> AppendT<SEMI,  A>(this Seq<Seq<A>> x, Seq<Seq<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Seq<Seq<A>> x, Seq<Seq<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Seq<Seq<A>> x, Seq<Seq<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Seq&lt;Seq&lt;A&gt;&gt;`</param>
        /// <returns>`Seq&lt;Seq&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Seq<Seq<B>> ApplyT< A, B>(this Func<A, B> fab, Seq<Seq<A>> fa) =>
            ApplSeq< Seq<A>, Seq<B>>.Inst.Apply(
                 MSeq< Func<Seq<A>, Seq<B>>>.Inst.Return((Seq<A> a) => ApplSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Seq&lt;Seq&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Seq&lt;Seq&lt;A&gt;&gt;`</param>
        /// <returns>`Seq&lt;Seq&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Seq<Seq<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Seq<Seq<A>> fa, Seq<Seq<B>> fb) =>
            ApplSeq< Seq<A>, Seq<B>, Seq<C>>.Inst.Apply(
                MSeq< Func<Seq<A>, Func<Seq<B>, Seq<C>>>>.Inst.Return(
                    (Seq<A> a) =>
                        (Seq<B> b) =>
                            ApplSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Set&lt;Seq&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Set<Seq<C>> SelectMany< A, B, C>(
            this Set<Seq<A>> ma,
            Func<A, Set<Seq<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MSet<Seq<A>>, Set<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MSet<Seq<C>>, Set<Seq<C>>, MSeq<C>, Seq<C>, C>(ma, a =>
                    SeqTrans<MSet<Seq<B>>, Set<Seq<B>>, MSeq<B>, Seq<B>, B>
                        .Inst.Bind<MSet<Seq<C>>, Set<Seq<C>>, MSeq<C>, Seq<C>, C>(bind(a), b =>
                            default(MSeq<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;Seq&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<Seq<A>> Where< A>(this Set<Seq<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSet<Seq<A>>, Set<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MSet<Seq<A>>, Set<Seq<A>>, MSeq<A>, Seq<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Seq<B>> Select< A, B>(this Set<Seq<A>> ma, Func<A, B> f) =>
            SeqTrans<MSet<Seq<A>>, Set<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Map<MSet<Seq<B>>, Set<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Set&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Seq&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Set&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Set<Seq<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MSet<Seq<A>>, Set<Seq<A>>, MSeq<A>, Seq<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Set&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Seq&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Set&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Set<Seq<A>> ma) =>
            SeqTrans<MSet<Seq<A>>, Set<Seq<A>>, MSeq<A>, Seq<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Seq<B>> BindT< A, B>(this Set<Seq<A>> ma, Func<A, Seq<B>> f) =>
            SeqTrans<MSet<Seq<A>>, Set<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MSet<Seq<B>>, Set<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Seq<B>> BindT< A, B>(this Set<Seq<A>> ma, Func<A, Set<Seq<B>>> f) =>
            SeqTrans<MSet<Seq<A>>, Set<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MSet<Seq<B>>, Set<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Set&lt;Seq&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Seq&lt;Set&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;Set&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Seq<Set<B>> Traverse< A, B>(this Set<Seq<A>> ma, Func<A, B> f) =>
            SeqTrans<MSet<Seq<A>>, Set<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Traverse<MSeq<Set<B>>, Seq<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Set&lt;Seq&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Seq&lt;Set&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Seq<Set<A>> Sequence< A>(this Set<Seq<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Seq<B>> MapT< A, B>(this Set<Seq<A>> ma, Func<A, B> f) =>
            SeqTrans<MSet<Seq<A>>, Set<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Map<MSet<Seq<B>>, Set<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Set<Seq<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSet<Seq<A>>, Set<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Set<Seq<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSet<Seq<A>>, Set<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Set<Seq<A>> ma, Func<A, bool> f) =>
            SeqTrans<MSet<Seq<A>>, Set<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Set<Seq<A>> ma, Func<A, bool> f) =>
            SeqTrans<MSet<Seq<A>>, Set<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Set&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Set<Seq<A>> ma, Action<A> f) =>
            SeqTrans<MSet<Seq<A>>, Set<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;Seq&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<Seq<A>> FilterT< A>(this Set<Seq<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSet<Seq<A>>, Set<Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MSet<Seq<A>>, Set<Seq<A>>, MSeq<A>, Seq<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Seq&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Set<Seq<A>> PlusT<NUM,  A>(this Set<Seq<A>> x, Set<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Seq&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Set<Seq<A>> SubtractT<NUM,  A>(this Set<Seq<A>> x, Set<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Set<Seq<A>> ProductT<NUM,  A>(this Set<Seq<A>> x, Set<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Set<Seq<A>> DivideT<NUM,  A>(this Set<Seq<A>> x, Set<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Set<Seq<A>> AppendT<SEMI,  A>(this Set<Seq<A>> x, Set<Seq<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Set<Seq<A>> x, Set<Seq<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Set<Seq<A>> x, Set<Seq<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Set&lt;Seq&lt;A&gt;&gt;`</param>
        /// <returns>`Set&lt;Seq&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Set<Seq<B>> ApplyT< A, B>(this Func<A, B> fab, Set<Seq<A>> fa) =>
            ApplSet< Seq<A>, Seq<B>>.Inst.Apply(
                 MSet< Func<Seq<A>, Seq<B>>>.Inst.Return((Seq<A> a) => ApplSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Set&lt;Seq&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Set&lt;Seq&lt;A&gt;&gt;`</param>
        /// <returns>`Set&lt;Seq&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Set<Seq<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Set<Seq<A>> fa, Set<Seq<B>> fb) =>
            ApplSet< Seq<A>, Seq<B>, Seq<C>>.Inst.Apply(
                MSet< Func<Seq<A>, Func<Seq<B>, Seq<C>>>>.Inst.Return(
                    (Seq<A> a) =>
                        (Seq<B> b) =>
                            ApplSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Validation&lt;FAIL, Seq&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Validation<FAIL, Seq<C>> SelectMany<FAIL, A, B, C>(
            this Validation<FAIL, Seq<A>> ma,
            Func<A, Validation<FAIL, Seq<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MValidation<FAIL, Seq<A>>, Validation<FAIL, Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MValidation<FAIL, Seq<C>>, Validation<FAIL, Seq<C>>, MSeq<C>, Seq<C>, C>(ma, a =>
                    Trans<MValidation<FAIL, Seq<B>>, Validation<FAIL, Seq<B>>, MSeq<B>, Seq<B>, B>
                        .Inst.Bind<MValidation<FAIL, Seq<C>>, Validation<FAIL, Seq<C>>, MSeq<C>, Seq<C>, C>(bind(a), b =>
                            default(MSeq<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, Seq&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, Seq<A>> Where<FAIL, A>(this Validation<FAIL, Seq<A>> ma, Func<A, bool> pred) =>
            Trans<MValidation<FAIL, Seq<A>>, Validation<FAIL, Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MValidation<FAIL, Seq<A>>, Validation<FAIL, Seq<A>>, MSeq<A>, Seq<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, Seq<B>> Select<FAIL, A, B>(this Validation<FAIL, Seq<A>> ma, Func<A, B> f) =>
            Trans<MValidation<FAIL, Seq<A>>, Validation<FAIL, Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Map<MValidation<FAIL, Seq<B>>, Validation<FAIL, Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Validation&lt;FAIL, Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Seq&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Validation&lt;FAIL, Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, FAIL, A>(this Validation<FAIL, Seq<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MValidation<FAIL, Seq<A>>, Validation<FAIL, Seq<A>>, MSeq<A>, Seq<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Validation&lt;FAIL, Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Seq&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Validation&lt;FAIL, Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<FAIL, A>(this Validation<FAIL, Seq<A>> ma) =>
            Trans<MValidation<FAIL, Seq<A>>, Validation<FAIL, Seq<A>>, MSeq<A>, Seq<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Validation&lt;FAIL, Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, Seq<B>> BindT<FAIL, A, B>(this Validation<FAIL, Seq<A>> ma, Func<A, Seq<B>> f) =>
            Trans<MValidation<FAIL, Seq<A>>, Validation<FAIL, Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MValidation<FAIL, Seq<B>>, Validation<FAIL, Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Validation&lt;FAIL, Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, Seq<B>> BindT<FAIL, A, B>(this Validation<FAIL, Seq<A>> ma, Func<A, Validation<FAIL, Seq<B>>> f) =>
            Trans<MValidation<FAIL, Seq<A>>, Validation<FAIL, Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MValidation<FAIL, Seq<B>>, Validation<FAIL, Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Validation&lt;FAIL, Seq&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Seq&lt;Validation&lt;FAIL, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;Validation&lt;FAIL, B&gt;&gt;`</returns>
        [Pure]
        public static Seq<Validation<FAIL, B>> Traverse<FAIL, A, B>(this Validation<FAIL, Seq<A>> ma, Func<A, B> f) =>
            SeqTrans<MValidation<FAIL, Seq<A>>, Validation<FAIL, Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Traverse<MSeq<Validation<FAIL, B>>, Seq<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Validation&lt;FAIL, Seq&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Seq&lt;Validation&lt;FAIL, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<FAIL, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static Seq<Validation<FAIL, A>> Sequence<FAIL, A>(this Validation<FAIL, Seq<A>> ma) =>
            ma.Traverse<FAIL, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, Seq<B>> MapT<FAIL, A, B>(this Validation<FAIL, Seq<A>> ma, Func<A, B> f) =>
            Trans<MValidation<FAIL, Seq<A>>, Validation<FAIL, Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Map<MValidation<FAIL, Seq<B>>, Validation<FAIL, Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, FAIL, A>(this Validation<FAIL, Seq<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MValidation<FAIL, Seq<A>>, Validation<FAIL, Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, FAIL, A>(this Validation<FAIL, Seq<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MValidation<FAIL, Seq<A>>, Validation<FAIL, Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<FAIL, A>(this Validation<FAIL, Seq<A>> ma, Func<A, bool> f) =>
            Trans<MValidation<FAIL, Seq<A>>, Validation<FAIL, Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<FAIL, A>(this Validation<FAIL, Seq<A>> ma, Func<A, bool> f) =>
            Trans<MValidation<FAIL, Seq<A>>, Validation<FAIL, Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Validation&lt;FAIL, Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<FAIL, A>(this Validation<FAIL, Seq<A>> ma, Action<A> f) =>
            Trans<MValidation<FAIL, Seq<A>>, Validation<FAIL, Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, Seq&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, Seq<A>> FilterT<FAIL, A>(this Validation<FAIL, Seq<A>> ma, Func<A, bool> pred) =>
            Trans<MValidation<FAIL, Seq<A>>, Validation<FAIL, Seq<A>>, MSeq<A>, Seq<A>, A>
                .Inst.Bind<MValidation<FAIL, Seq<A>>, Validation<FAIL, Seq<A>>, MSeq<A>, Seq<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSeq<A>).Return(a)
                        : default(MSeq<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Seq&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Validation<FAIL, Seq<A>> PlusT<NUM, FAIL, A>(this Validation<FAIL, Seq<A>> x, Validation<FAIL, Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Seq&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Validation<FAIL, Seq<A>> SubtractT<NUM, FAIL, A>(this Validation<FAIL, Seq<A>> x, Validation<FAIL, Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Seq&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Validation<FAIL, Seq<A>> ProductT<NUM, FAIL, A>(this Validation<FAIL, Seq<A>> x, Validation<FAIL, Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Seq&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Validation<FAIL, Seq<A>> DivideT<NUM, FAIL, A>(this Validation<FAIL, Seq<A>> x, Validation<FAIL, Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Seq&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Validation<FAIL, Seq<A>> AppendT<SEMI, FAIL, A>(this Validation<FAIL, Seq<A>> x, Validation<FAIL, Seq<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, FAIL, A>(this Validation<FAIL, Seq<A>> x, Validation<FAIL, Seq<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Seq&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, FAIL, A>(this Validation<FAIL, Seq<A>> x, Validation<FAIL, Seq<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Validation&lt;FAIL, Seq&lt;A&gt;&gt;`</param>
        /// <returns>`Validation&lt;FAIL, Seq&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Validation<FAIL, Seq<B>> ApplyT<FAIL, A, B>(this Func<A, B> fab, Validation<FAIL, Seq<A>> fa) =>
            ApplValidation<FAIL, Seq<A>, Seq<B>>.Inst.Apply(
                 MValidation<FAIL, Func<Seq<A>, Seq<B>>>.Inst.Return((Seq<A> a) => ApplSeq< A, B>.Inst.Apply(
                     MSeq< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Validation&lt;FAIL, Seq&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Validation&lt;FAIL, Seq&lt;A&gt;&gt;`</param>
        /// <returns>`Validation&lt;FAIL, Seq&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Validation<FAIL, Seq<C>> ApplyT<FAIL, A, B, C>(this Func<A, B, C> fabc, Validation<FAIL, Seq<A>> fa, Validation<FAIL, Seq<B>> fb) =>
            ApplValidation<FAIL, Seq<A>, Seq<B>, Seq<C>>.Inst.Apply(
                MValidation<FAIL, Func<Seq<A>, Func<Seq<B>, Seq<C>>>>.Inst.Return(
                    (Seq<A> a) =>
                        (Seq<B> b) =>
                            ApplSeq< A, B, C>.Inst.Apply(
                                MSeq< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    /// <summary>
    /// Monad transformer for Set, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class SetT_Extensions
    {
        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Arr&lt;Set&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<Set<C>> SelectMany< A, B, C>(
            this Arr<Set<A>> ma,
            Func<A, Arr<Set<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MArr<Set<C>>, Arr<Set<C>>, MSet<C>, Set<C>, C>(ma, a =>
                    SeqTrans<MArr<Set<B>>, Arr<Set<B>>, MSet<B>, Set<B>, B>
                        .Inst.Bind<MArr<Set<C>>, Arr<Set<C>>, MSet<C>, Set<C>, C>(bind(a), b =>
                            default(MSet<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;Set&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<Set<A>> Where< A>(this Arr<Set<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Set<B>> Select< A, B>(this Arr<Set<A>> ma, Func<A, B> f) =>
            SeqTrans<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MArr<Set<B>>, Arr<Set<B>>, MSet<B>, Set<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Arr&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Set&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Arr&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Arr<Set<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Arr&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Set&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Arr&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Arr<Set<A>> ma) =>
            SeqTrans<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Set<B>> BindT< A, B>(this Arr<Set<A>> ma, Func<A, Set<B>> f) =>
            SeqTrans<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MArr<Set<B>>, Arr<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Set<B>> BindT< A, B>(this Arr<Set<A>> ma, Func<A, Arr<Set<B>>> f) =>
            SeqTrans<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MArr<Set<B>>, Arr<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Arr&lt;Set&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Set&lt;Arr&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;Arr&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Set<Arr<B>> Traverse< A, B>(this Arr<Set<A>> ma, Func<A, B> f) =>
            SeqTrans<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<Arr<B>>, Set<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Arr&lt;Set&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Set&lt;Arr&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Set<Arr<A>> Sequence< A>(this Arr<Set<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Set<B>> MapT< A, B>(this Arr<Set<A>> ma, Func<A, B> f) =>
            SeqTrans<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MArr<Set<B>>, Arr<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Arr<Set<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Arr<Set<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Arr<Set<A>> ma, Func<A, bool> f) =>
            SeqTrans<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Arr<Set<A>> ma, Func<A, bool> f) =>
            SeqTrans<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Arr&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Arr<Set<A>> ma, Action<A> f) =>
            SeqTrans<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;Set&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<Set<A>> FilterT< A>(this Arr<Set<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MArr<Set<A>>, Arr<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Set&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Arr<Set<A>> PlusT<NUM,  A>(this Arr<Set<A>> x, Arr<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Set&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Arr<Set<A>> SubtractT<NUM,  A>(this Arr<Set<A>> x, Arr<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Set&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Arr<Set<A>> ProductT<NUM,  A>(this Arr<Set<A>> x, Arr<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Set&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Arr<Set<A>> DivideT<NUM,  A>(this Arr<Set<A>> x, Arr<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Set&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Arr<Set<A>> AppendT<SEMI,  A>(this Arr<Set<A>> x, Arr<Set<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Arr<Set<A>> x, Arr<Set<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Set&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Arr<Set<A>> x, Arr<Set<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Arr&lt;Set&lt;A&gt;&gt;`</param>
        /// <returns>`Arr&lt;Set&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Arr<Set<B>> ApplyT< A, B>(this Func<A, B> fab, Arr<Set<A>> fa) =>
            ApplArr< Set<A>, Set<B>>.Inst.Apply(
                 MArr< Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => ApplSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Arr&lt;Set&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Arr&lt;Set&lt;A&gt;&gt;`</param>
        /// <returns>`Arr&lt;Set&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Arr<Set<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Arr<Set<A>> fa, Arr<Set<B>> fb) =>
            ApplArr< Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MArr< Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            ApplSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`HashSet&lt;Set&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<Set<C>> SelectMany< A, B, C>(
            this HashSet<Set<A>> ma,
            Func<A, HashSet<Set<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MHashSet<Set<C>>, HashSet<Set<C>>, MSet<C>, Set<C>, C>(ma, a =>
                    SeqTrans<MHashSet<Set<B>>, HashSet<Set<B>>, MSet<B>, Set<B>, B>
                        .Inst.Bind<MHashSet<Set<C>>, HashSet<Set<C>>, MSet<C>, Set<C>, C>(bind(a), b =>
                            default(MSet<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;Set&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<Set<A>> Where< A>(this HashSet<Set<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Set<B>> Select< A, B>(this HashSet<Set<A>> ma, Func<A, B> f) =>
            SeqTrans<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MHashSet<Set<B>>, HashSet<Set<B>>, MSet<B>, Set<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `HashSet&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Set&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `HashSet&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this HashSet<Set<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `HashSet&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Set&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `HashSet&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this HashSet<Set<A>> ma) =>
            SeqTrans<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Set<B>> BindT< A, B>(this HashSet<Set<A>> ma, Func<A, Set<B>> f) =>
            SeqTrans<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MHashSet<Set<B>>, HashSet<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Set<B>> BindT< A, B>(this HashSet<Set<A>> ma, Func<A, HashSet<Set<B>>> f) =>
            SeqTrans<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MHashSet<Set<B>>, HashSet<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `HashSet&lt;Set&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Set&lt;HashSet&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;HashSet&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Set<HashSet<B>> Traverse< A, B>(this HashSet<Set<A>> ma, Func<A, B> f) =>
            SeqTrans<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<HashSet<B>>, Set<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `HashSet&lt;Set&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Set&lt;HashSet&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Set<HashSet<A>> Sequence< A>(this HashSet<Set<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Set<B>> MapT< A, B>(this HashSet<Set<A>> ma, Func<A, B> f) =>
            SeqTrans<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MHashSet<Set<B>>, HashSet<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this HashSet<Set<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this HashSet<Set<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this HashSet<Set<A>> ma, Func<A, bool> f) =>
            SeqTrans<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this HashSet<Set<A>> ma, Func<A, bool> f) =>
            SeqTrans<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `HashSet&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this HashSet<Set<A>> ma, Action<A> f) =>
            SeqTrans<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;Set&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<Set<A>> FilterT< A>(this HashSet<Set<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MHashSet<Set<A>>, HashSet<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Set&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<Set<A>> PlusT<NUM,  A>(this HashSet<Set<A>> x, HashSet<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Set&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<Set<A>> SubtractT<NUM,  A>(this HashSet<Set<A>> x, HashSet<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Set&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static HashSet<Set<A>> ProductT<NUM,  A>(this HashSet<Set<A>> x, HashSet<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Set&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static HashSet<Set<A>> DivideT<NUM,  A>(this HashSet<Set<A>> x, HashSet<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Set&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static HashSet<Set<A>> AppendT<SEMI,  A>(this HashSet<Set<A>> x, HashSet<Set<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this HashSet<Set<A>> x, HashSet<Set<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Set&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this HashSet<Set<A>> x, HashSet<Set<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `HashSet&lt;Set&lt;A&gt;&gt;`</param>
        /// <returns>`HashSet&lt;Set&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static HashSet<Set<B>> ApplyT< A, B>(this Func<A, B> fab, HashSet<Set<A>> fa) =>
            ApplHashSet< Set<A>, Set<B>>.Inst.Apply(
                 MHashSet< Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => ApplSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `HashSet&lt;Set&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `HashSet&lt;Set&lt;A&gt;&gt;`</param>
        /// <returns>`HashSet&lt;Set&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static HashSet<Set<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, HashSet<Set<A>> fa, HashSet<Set<B>> fb) =>
            ApplHashSet< Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MHashSet< Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            ApplSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Lst&lt;Set&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<Set<C>> SelectMany< A, B, C>(
            this Lst<Set<A>> ma,
            Func<A, Lst<Set<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MLst<Set<C>>, Lst<Set<C>>, MSet<C>, Set<C>, C>(ma, a =>
                    SeqTrans<MLst<Set<B>>, Lst<Set<B>>, MSet<B>, Set<B>, B>
                        .Inst.Bind<MLst<Set<C>>, Lst<Set<C>>, MSet<C>, Set<C>, C>(bind(a), b =>
                            default(MSet<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;Set&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<Set<A>> Where< A>(this Lst<Set<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Set<B>> Select< A, B>(this Lst<Set<A>> ma, Func<A, B> f) =>
            SeqTrans<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MLst<Set<B>>, Lst<Set<B>>, MSet<B>, Set<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Lst&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Set&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Lst&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Lst<Set<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Lst&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Set&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Lst&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Lst<Set<A>> ma) =>
            SeqTrans<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Set<B>> BindT< A, B>(this Lst<Set<A>> ma, Func<A, Set<B>> f) =>
            SeqTrans<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MLst<Set<B>>, Lst<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Set<B>> BindT< A, B>(this Lst<Set<A>> ma, Func<A, Lst<Set<B>>> f) =>
            SeqTrans<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MLst<Set<B>>, Lst<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Lst&lt;Set&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Set&lt;Lst&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;Lst&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Set<Lst<B>> Traverse< A, B>(this Lst<Set<A>> ma, Func<A, B> f) =>
            SeqTrans<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<Lst<B>>, Set<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Lst&lt;Set&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Set&lt;Lst&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Set<Lst<A>> Sequence< A>(this Lst<Set<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Set<B>> MapT< A, B>(this Lst<Set<A>> ma, Func<A, B> f) =>
            SeqTrans<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MLst<Set<B>>, Lst<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Lst<Set<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Lst<Set<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Lst<Set<A>> ma, Func<A, bool> f) =>
            SeqTrans<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Lst<Set<A>> ma, Func<A, bool> f) =>
            SeqTrans<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Lst&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Lst<Set<A>> ma, Action<A> f) =>
            SeqTrans<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;Set&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<Set<A>> FilterT< A>(this Lst<Set<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MLst<Set<A>>, Lst<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Set&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Lst<Set<A>> PlusT<NUM,  A>(this Lst<Set<A>> x, Lst<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Set&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Lst<Set<A>> SubtractT<NUM,  A>(this Lst<Set<A>> x, Lst<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Set&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Lst<Set<A>> ProductT<NUM,  A>(this Lst<Set<A>> x, Lst<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Set&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Lst<Set<A>> DivideT<NUM,  A>(this Lst<Set<A>> x, Lst<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Set&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Lst<Set<A>> AppendT<SEMI,  A>(this Lst<Set<A>> x, Lst<Set<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Lst<Set<A>> x, Lst<Set<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Set&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Lst<Set<A>> x, Lst<Set<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Lst&lt;Set&lt;A&gt;&gt;`</param>
        /// <returns>`Lst&lt;Set&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Lst<Set<B>> ApplyT< A, B>(this Func<A, B> fab, Lst<Set<A>> fa) =>
            ApplLst< Set<A>, Set<B>>.Inst.Apply(
                 MLst< Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => ApplSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Lst&lt;Set&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Lst&lt;Set&lt;A&gt;&gt;`</param>
        /// <returns>`Lst&lt;Set&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Lst<Set<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Lst<Set<A>> fa, Lst<Set<B>> fb) =>
            ApplLst< Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MLst< Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            ApplSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Option&lt;Set&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Option<Set<C>> SelectMany< A, B, C>(
            this Option<Set<A>> ma,
            Func<A, Option<Set<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MOption<Set<C>>, Option<Set<C>>, MSet<C>, Set<C>, C>(ma, a =>
                    Trans<MOption<Set<B>>, Option<Set<B>>, MSet<B>, Set<B>, B>
                        .Inst.Bind<MOption<Set<C>>, Option<Set<C>>, MSet<C>, Set<C>, C>(bind(a), b =>
                            default(MSet<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;Set&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<Set<A>> Where< A>(this Option<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Set<B>> Select< A, B>(this Option<Set<A>> ma, Func<A, B> f) =>
            Trans<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MOption<Set<B>>, Option<Set<B>>, MSet<B>, Set<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Option&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Set&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Option&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Option<Set<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Option&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Set&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Option&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Option<Set<A>> ma) =>
            Trans<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Set<B>> BindT< A, B>(this Option<Set<A>> ma, Func<A, Set<B>> f) =>
            Trans<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MOption<Set<B>>, Option<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Set<B>> BindT< A, B>(this Option<Set<A>> ma, Func<A, Option<Set<B>>> f) =>
            Trans<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MOption<Set<B>>, Option<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Option&lt;Set&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Set&lt;Option&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;Option&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Set<Option<B>> Traverse< A, B>(this Option<Set<A>> ma, Func<A, B> f) =>
            SeqTrans<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<Option<B>>, Set<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Option&lt;Set&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Set&lt;Option&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Set<Option<A>> Sequence< A>(this Option<Set<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Set<B>> MapT< A, B>(this Option<Set<A>> ma, Func<A, B> f) =>
            Trans<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MOption<Set<B>>, Option<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Option<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Option<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Option<Set<A>> ma, Func<A, bool> f) =>
            Trans<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Option<Set<A>> ma, Func<A, bool> f) =>
            Trans<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Option&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Option<Set<A>> ma, Action<A> f) =>
            Trans<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;Set&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<Set<A>> FilterT< A>(this Option<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MOption<Set<A>>, Option<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Set&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Option<Set<A>> PlusT<NUM,  A>(this Option<Set<A>> x, Option<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Set&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Option<Set<A>> SubtractT<NUM,  A>(this Option<Set<A>> x, Option<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Set&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Option<Set<A>> ProductT<NUM,  A>(this Option<Set<A>> x, Option<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Set&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Option<Set<A>> DivideT<NUM,  A>(this Option<Set<A>> x, Option<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Set&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Option<Set<A>> AppendT<SEMI,  A>(this Option<Set<A>> x, Option<Set<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Option<Set<A>> x, Option<Set<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Set&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Option<Set<A>> x, Option<Set<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Option&lt;Set&lt;A&gt;&gt;`</param>
        /// <returns>`Option&lt;Set&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Option<Set<B>> ApplyT< A, B>(this Func<A, B> fab, Option<Set<A>> fa) =>
            ApplOption< Set<A>, Set<B>>.Inst.Apply(
                 MOption< Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => ApplSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Option&lt;Set&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Option&lt;Set&lt;A&gt;&gt;`</param>
        /// <returns>`Option&lt;Set&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Option<Set<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Option<Set<A>> fa, Option<Set<B>> fb) =>
            ApplOption< Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MOption< Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            ApplSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionUnsafe&lt;Set&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<Set<C>> SelectMany< A, B, C>(
            this OptionUnsafe<Set<A>> ma,
            Func<A, OptionUnsafe<Set<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MOptionUnsafe<Set<C>>, OptionUnsafe<Set<C>>, MSet<C>, Set<C>, C>(ma, a =>
                    Trans<MOptionUnsafe<Set<B>>, OptionUnsafe<Set<B>>, MSet<B>, Set<B>, B>
                        .Inst.Bind<MOptionUnsafe<Set<C>>, OptionUnsafe<Set<C>>, MSet<C>, Set<C>, C>(bind(a), b =>
                            default(MSet<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;Set&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<Set<A>> Where< A>(this OptionUnsafe<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Set<B>> Select< A, B>(this OptionUnsafe<Set<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MOptionUnsafe<Set<B>>, OptionUnsafe<Set<B>>, MSet<B>, Set<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionUnsafe&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Set&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionUnsafe&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this OptionUnsafe<Set<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionUnsafe&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Set&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionUnsafe&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this OptionUnsafe<Set<A>> ma) =>
            Trans<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Set<B>> BindT< A, B>(this OptionUnsafe<Set<A>> ma, Func<A, Set<B>> f) =>
            Trans<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MOptionUnsafe<Set<B>>, OptionUnsafe<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Set<B>> BindT< A, B>(this OptionUnsafe<Set<A>> ma, Func<A, OptionUnsafe<Set<B>>> f) =>
            Trans<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MOptionUnsafe<Set<B>>, OptionUnsafe<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionUnsafe&lt;Set&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Set&lt;OptionUnsafe&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;OptionUnsafe&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Set<OptionUnsafe<B>> Traverse< A, B>(this OptionUnsafe<Set<A>> ma, Func<A, B> f) =>
            SeqTrans<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<OptionUnsafe<B>>, Set<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionUnsafe&lt;Set&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Set&lt;OptionUnsafe&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Set<OptionUnsafe<A>> Sequence< A>(this OptionUnsafe<Set<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Set<B>> MapT< A, B>(this OptionUnsafe<Set<A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MOptionUnsafe<Set<B>>, OptionUnsafe<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this OptionUnsafe<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this OptionUnsafe<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this OptionUnsafe<Set<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this OptionUnsafe<Set<A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionUnsafe&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this OptionUnsafe<Set<A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;Set&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<Set<A>> FilterT< A>(this OptionUnsafe<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MOptionUnsafe<Set<A>>, OptionUnsafe<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Set&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<Set<A>> PlusT<NUM,  A>(this OptionUnsafe<Set<A>> x, OptionUnsafe<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Set&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<Set<A>> SubtractT<NUM,  A>(this OptionUnsafe<Set<A>> x, OptionUnsafe<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Set&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionUnsafe<Set<A>> ProductT<NUM,  A>(this OptionUnsafe<Set<A>> x, OptionUnsafe<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Set&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionUnsafe<Set<A>> DivideT<NUM,  A>(this OptionUnsafe<Set<A>> x, OptionUnsafe<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Set&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionUnsafe<Set<A>> AppendT<SEMI,  A>(this OptionUnsafe<Set<A>> x, OptionUnsafe<Set<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this OptionUnsafe<Set<A>> x, OptionUnsafe<Set<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Set&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this OptionUnsafe<Set<A>> x, OptionUnsafe<Set<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe&lt;Set&lt;A&gt;&gt;`</param>
        /// <returns>`OptionUnsafe&lt;Set&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionUnsafe<Set<B>> ApplyT< A, B>(this Func<A, B> fab, OptionUnsafe<Set<A>> fa) =>
            ApplOptionUnsafe< Set<A>, Set<B>>.Inst.Apply(
                 MOptionUnsafe< Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => ApplSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe&lt;Set&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `OptionUnsafe&lt;Set&lt;A&gt;&gt;`</param>
        /// <returns>`OptionUnsafe&lt;Set&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionUnsafe<Set<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, OptionUnsafe<Set<A>> fa, OptionUnsafe<Set<B>> fb) =>
            ApplOptionUnsafe< Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MOptionUnsafe< Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            ApplSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Either&lt;L, Set&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, Set<C>> SelectMany<L, A, B, C>(
            this Either<L, Set<A>> ma,
            Func<A, Either<L, Set<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MEither<L, Set<C>>, Either<L, Set<C>>, MSet<C>, Set<C>, C>(ma, a =>
                    Trans<MEither<L, Set<B>>, Either<L, Set<B>>, MSet<B>, Set<B>, B>
                        .Inst.Bind<MEither<L, Set<C>>, Either<L, Set<C>>, MSet<C>, Set<C>, C>(bind(a), b =>
                            default(MSet<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, Set&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, Set<A>> Where<L, A>(this Either<L, Set<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Set<B>> Select<L, A, B>(this Either<L, Set<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MEither<L, Set<B>>, Either<L, Set<B>>, MSet<B>, Set<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Either&lt;L, Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Set&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Either&lt;L, Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this Either<L, Set<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Either&lt;L, Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Set&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Either&lt;L, Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this Either<L, Set<A>> ma) =>
            Trans<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either&lt;L, Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Set<B>> BindT<L, A, B>(this Either<L, Set<A>> ma, Func<A, Set<B>> f) =>
            Trans<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MEither<L, Set<B>>, Either<L, Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either&lt;L, Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Set<B>> BindT<L, A, B>(this Either<L, Set<A>> ma, Func<A, Either<L, Set<B>>> f) =>
            Trans<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MEither<L, Set<B>>, Either<L, Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Either&lt;L, Set&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Set&lt;Either&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;Either&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static Set<Either<L, B>> Traverse<L, A, B>(this Either<L, Set<A>> ma, Func<A, B> f) =>
            SeqTrans<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<Either<L, B>>, Set<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Either&lt;L, Set&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Set&lt;Either&lt;L, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static Set<Either<L, A>> Sequence<L, A>(this Either<L, Set<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Set<B>> MapT<L, A, B>(this Either<L, Set<A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MEither<L, Set<B>>, Either<L, Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this Either<L, Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this Either<L, Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this Either<L, Set<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this Either<L, Set<A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Either&lt;L, Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this Either<L, Set<A>> ma, Action<A> f) =>
            Trans<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, Set&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, Set<A>> FilterT<L, A>(this Either<L, Set<A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MEither<L, Set<A>>, Either<L, Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Set&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, Set<A>> PlusT<NUM, L, A>(this Either<L, Set<A>> x, Either<L, Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Set&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, Set<A>> SubtractT<NUM, L, A>(this Either<L, Set<A>> x, Either<L, Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Set&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Either<L, Set<A>> ProductT<NUM, L, A>(this Either<L, Set<A>> x, Either<L, Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Set&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Either<L, Set<A>> DivideT<NUM, L, A>(this Either<L, Set<A>> x, Either<L, Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Set&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Either<L, Set<A>> AppendT<SEMI, L, A>(this Either<L, Set<A>> x, Either<L, Set<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this Either<L, Set<A>> x, Either<L, Set<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Set&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this Either<L, Set<A>> x, Either<L, Set<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Either&lt;L, Set&lt;A&gt;&gt;`</param>
        /// <returns>`Either&lt;L, Set&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Either<L, Set<B>> ApplyT<L, A, B>(this Func<A, B> fab, Either<L, Set<A>> fa) =>
            ApplEither<L, Set<A>, Set<B>>.Inst.Apply(
                 MEither<L, Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => ApplSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Either&lt;L, Set&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Either&lt;L, Set&lt;A&gt;&gt;`</param>
        /// <returns>`Either&lt;L, Set&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Either<L, Set<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Either<L, Set<A>> fa, Either<L, Set<B>> fb) =>
            ApplEither<L, Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MEither<L, Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            ApplSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`EitherUnsafe&lt;L, Set&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, Set<C>> SelectMany<L, A, B, C>(
            this EitherUnsafe<L, Set<A>> ma,
            Func<A, EitherUnsafe<L, Set<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Set<C>>, EitherUnsafe<L, Set<C>>, MSet<C>, Set<C>, C>(ma, a =>
                    Trans<MEitherUnsafe<L, Set<B>>, EitherUnsafe<L, Set<B>>, MSet<B>, Set<B>, B>
                        .Inst.Bind<MEitherUnsafe<L, Set<C>>, EitherUnsafe<L, Set<C>>, MSet<C>, Set<C>, C>(bind(a), b =>
                            default(MSet<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, Set&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, Set<A>> Where<L, A>(this EitherUnsafe<L, Set<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Set<B>> Select<L, A, B>(this EitherUnsafe<L, Set<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MEitherUnsafe<L, Set<B>>, EitherUnsafe<L, Set<B>>, MSet<B>, Set<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherUnsafe&lt;L, Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Set&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherUnsafe&lt;L, Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, A>(this EitherUnsafe<L, Set<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherUnsafe&lt;L, Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Set&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherUnsafe&lt;L, Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, A>(this EitherUnsafe<L, Set<A>> ma) =>
            Trans<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Set<B>> BindT<L, A, B>(this EitherUnsafe<L, Set<A>> ma, Func<A, Set<B>> f) =>
            Trans<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Set<B>>, EitherUnsafe<L, Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Set<B>> BindT<L, A, B>(this EitherUnsafe<L, Set<A>> ma, Func<A, EitherUnsafe<L, Set<B>>> f) =>
            Trans<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Set<B>>, EitherUnsafe<L, Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `EitherUnsafe&lt;L, Set&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Set&lt;EitherUnsafe&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;EitherUnsafe&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static Set<EitherUnsafe<L, B>> Traverse<L, A, B>(this EitherUnsafe<L, Set<A>> ma, Func<A, B> f) =>
            SeqTrans<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<EitherUnsafe<L, B>>, Set<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `EitherUnsafe&lt;L, Set&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Set&lt;EitherUnsafe&lt;L, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static Set<EitherUnsafe<L, A>> Sequence<L, A>(this EitherUnsafe<L, Set<A>> ma) =>
            ma.Traverse<L, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Set<B>> MapT<L, A, B>(this EitherUnsafe<L, Set<A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MEitherUnsafe<L, Set<B>>, EitherUnsafe<L, Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, A>(this EitherUnsafe<L, Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, A>(this EitherUnsafe<L, Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, A>(this EitherUnsafe<L, Set<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, A>(this EitherUnsafe<L, Set<A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherUnsafe&lt;L, Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, A>(this EitherUnsafe<L, Set<A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, Set&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, Set<A>> FilterT<L, A>(this EitherUnsafe<L, Set<A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MEitherUnsafe<L, Set<A>>, EitherUnsafe<L, Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Set&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, Set<A>> PlusT<NUM, L, A>(this EitherUnsafe<L, Set<A>> x, EitherUnsafe<L, Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Set&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, Set<A>> SubtractT<NUM, L, A>(this EitherUnsafe<L, Set<A>> x, EitherUnsafe<L, Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Set&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherUnsafe<L, Set<A>> ProductT<NUM, L, A>(this EitherUnsafe<L, Set<A>> x, EitherUnsafe<L, Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Set&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherUnsafe<L, Set<A>> DivideT<NUM, L, A>(this EitherUnsafe<L, Set<A>> x, EitherUnsafe<L, Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Set&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherUnsafe<L, Set<A>> AppendT<SEMI, L, A>(this EitherUnsafe<L, Set<A>> x, EitherUnsafe<L, Set<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, A>(this EitherUnsafe<L, Set<A>> x, EitherUnsafe<L, Set<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Set&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, A>(this EitherUnsafe<L, Set<A>> x, EitherUnsafe<L, Set<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe&lt;L, Set&lt;A&gt;&gt;`</param>
        /// <returns>`EitherUnsafe&lt;L, Set&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherUnsafe<L, Set<B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherUnsafe<L, Set<A>> fa) =>
            ApplEitherUnsafe<L, Set<A>, Set<B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => ApplSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe&lt;L, Set&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `EitherUnsafe&lt;L, Set&lt;A&gt;&gt;`</param>
        /// <returns>`EitherUnsafe&lt;L, Set&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherUnsafe<L, Set<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherUnsafe<L, Set<A>> fa, EitherUnsafe<L, Set<B>> fb) =>
            ApplEitherUnsafe<L, Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MEitherUnsafe<L, Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            ApplSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Try&lt;Set&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Try<Set<C>> SelectMany< A, B, C>(
            this Try<Set<A>> ma,
            Func<A, Try<Set<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MTry<Set<C>>, Try<Set<C>>, MSet<C>, Set<C>, C>(ma, a =>
                    Trans<MTry<Set<B>>, Try<Set<B>>, MSet<B>, Set<B>, B>
                        .Inst.Bind<MTry<Set<C>>, Try<Set<C>>, MSet<C>, Set<C>, C>(bind(a), b =>
                            default(MSet<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;Set&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<Set<A>> Where< A>(this Try<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Set<B>> Select< A, B>(this Try<Set<A>> ma, Func<A, B> f) =>
            Trans<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MTry<Set<B>>, Try<Set<B>>, MSet<B>, Set<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Try&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Set&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Try&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Try<Set<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Try&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Set&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Try&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Try<Set<A>> ma) =>
            Trans<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Set<B>> BindT< A, B>(this Try<Set<A>> ma, Func<A, Set<B>> f) =>
            Trans<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MTry<Set<B>>, Try<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Set<B>> BindT< A, B>(this Try<Set<A>> ma, Func<A, Try<Set<B>>> f) =>
            Trans<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MTry<Set<B>>, Try<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Try&lt;Set&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Set&lt;Try&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;Try&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Set<Try<B>> Traverse< A, B>(this Try<Set<A>> ma, Func<A, B> f) =>
            SeqTrans<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<Try<B>>, Set<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Try&lt;Set&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Set&lt;Try&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Set<Try<A>> Sequence< A>(this Try<Set<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Set<B>> MapT< A, B>(this Try<Set<A>> ma, Func<A, B> f) =>
            Trans<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MTry<Set<B>>, Try<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Try<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Try<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Try<Set<A>> ma, Func<A, bool> f) =>
            Trans<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Try<Set<A>> ma, Func<A, bool> f) =>
            Trans<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Try&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Try<Set<A>> ma, Action<A> f) =>
            Trans<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;Set&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<Set<A>> FilterT< A>(this Try<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MTry<Set<A>>, Try<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Set&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Try<Set<A>> PlusT<NUM,  A>(this Try<Set<A>> x, Try<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Set&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Try<Set<A>> SubtractT<NUM,  A>(this Try<Set<A>> x, Try<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Set&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Try<Set<A>> ProductT<NUM,  A>(this Try<Set<A>> x, Try<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Set&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Try<Set<A>> DivideT<NUM,  A>(this Try<Set<A>> x, Try<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Set&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Try<Set<A>> AppendT<SEMI,  A>(this Try<Set<A>> x, Try<Set<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Try<Set<A>> x, Try<Set<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Set&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Try<Set<A>> x, Try<Set<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Try&lt;Set&lt;A&gt;&gt;`</param>
        /// <returns>`Try&lt;Set&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Try<Set<B>> ApplyT< A, B>(this Func<A, B> fab, Try<Set<A>> fa) =>
            ApplTry< Set<A>, Set<B>>.Inst.Apply(
                 MTry< Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => ApplSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Try&lt;Set&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Try&lt;Set&lt;A&gt;&gt;`</param>
        /// <returns>`Try&lt;Set&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Try<Set<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Try<Set<A>> fa, Try<Set<B>> fb) =>
            ApplTry< Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MTry< Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            ApplSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOption&lt;Set&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<Set<C>> SelectMany< A, B, C>(
            this TryOption<Set<A>> ma,
            Func<A, TryOption<Set<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MTryOption<Set<C>>, TryOption<Set<C>>, MSet<C>, Set<C>, C>(ma, a =>
                    Trans<MTryOption<Set<B>>, TryOption<Set<B>>, MSet<B>, Set<B>, B>
                        .Inst.Bind<MTryOption<Set<C>>, TryOption<Set<C>>, MSet<C>, Set<C>, C>(bind(a), b =>
                            default(MSet<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;Set&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<Set<A>> Where< A>(this TryOption<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Set<B>> Select< A, B>(this TryOption<Set<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MTryOption<Set<B>>, TryOption<Set<B>>, MSet<B>, Set<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOption&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Set&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOption&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this TryOption<Set<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOption&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Set&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOption&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this TryOption<Set<A>> ma) =>
            Trans<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Set<B>> BindT< A, B>(this TryOption<Set<A>> ma, Func<A, Set<B>> f) =>
            Trans<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MTryOption<Set<B>>, TryOption<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Set<B>> BindT< A, B>(this TryOption<Set<A>> ma, Func<A, TryOption<Set<B>>> f) =>
            Trans<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MTryOption<Set<B>>, TryOption<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOption&lt;Set&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Set&lt;TryOption&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;TryOption&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Set<TryOption<B>> Traverse< A, B>(this TryOption<Set<A>> ma, Func<A, B> f) =>
            SeqTrans<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<TryOption<B>>, Set<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOption&lt;Set&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Set&lt;TryOption&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Set<TryOption<A>> Sequence< A>(this TryOption<Set<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Set<B>> MapT< A, B>(this TryOption<Set<A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MTryOption<Set<B>>, TryOption<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this TryOption<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this TryOption<Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this TryOption<Set<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this TryOption<Set<A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOption&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this TryOption<Set<A>> ma, Action<A> f) =>
            Trans<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;Set&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<Set<A>> FilterT< A>(this TryOption<Set<A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MTryOption<Set<A>>, TryOption<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Set&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<Set<A>> PlusT<NUM,  A>(this TryOption<Set<A>> x, TryOption<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Set&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<Set<A>> SubtractT<NUM,  A>(this TryOption<Set<A>> x, TryOption<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Set&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOption<Set<A>> ProductT<NUM,  A>(this TryOption<Set<A>> x, TryOption<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Set&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOption<Set<A>> DivideT<NUM,  A>(this TryOption<Set<A>> x, TryOption<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Set&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOption<Set<A>> AppendT<SEMI,  A>(this TryOption<Set<A>> x, TryOption<Set<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this TryOption<Set<A>> x, TryOption<Set<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Set&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this TryOption<Set<A>> x, TryOption<Set<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOption&lt;Set&lt;A&gt;&gt;`</param>
        /// <returns>`TryOption&lt;Set&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOption<Set<B>> ApplyT< A, B>(this Func<A, B> fab, TryOption<Set<A>> fa) =>
            ApplTryOption< Set<A>, Set<B>>.Inst.Apply(
                 MTryOption< Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => ApplSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOption&lt;Set&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryOption&lt;Set&lt;A&gt;&gt;`</param>
        /// <returns>`TryOption&lt;Set&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOption<Set<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOption<Set<A>> fa, TryOption<Set<B>> fb) =>
            ApplTryOption< Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MTryOption< Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            ApplSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`IEnumerable&lt;Set&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<Set<C>> SelectMany< A, B, C>(
            this IEnumerable<Set<A>> ma,
            Func<A, IEnumerable<Set<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MEnumerable<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MEnumerable<Set<C>>, IEnumerable<Set<C>>, MSet<C>, Set<C>, C>(ma, a =>
                    SeqTrans<MEnumerable<Set<B>>, IEnumerable<Set<B>>, MSet<B>, Set<B>, B>
                        .Inst.Bind<MEnumerable<Set<C>>, IEnumerable<Set<C>>, MSet<C>, Set<C>, C>(bind(a), b =>
                            default(MSet<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;Set&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<Set<A>> Where< A>(this IEnumerable<Set<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MEnumerable<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MEnumerable<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Set<B>> Select< A, B>(this IEnumerable<Set<A>> ma, Func<A, B> f) =>
            SeqTrans<MEnumerable<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MEnumerable<Set<B>>, IEnumerable<Set<B>>, MSet<B>, Set<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `IEnumerable&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Set&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `IEnumerable&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this IEnumerable<Set<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MEnumerable<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `IEnumerable&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Set&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `IEnumerable&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this IEnumerable<Set<A>> ma) =>
            SeqTrans<MEnumerable<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Set<B>> BindT< A, B>(this IEnumerable<Set<A>> ma, Func<A, Set<B>> f) =>
            SeqTrans<MEnumerable<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MEnumerable<Set<B>>, IEnumerable<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Set<B>> BindT< A, B>(this IEnumerable<Set<A>> ma, Func<A, IEnumerable<Set<B>>> f) =>
            SeqTrans<MEnumerable<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MEnumerable<Set<B>>, IEnumerable<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `IEnumerable&lt;Set&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Set&lt;IEnumerable&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;IEnumerable&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Set<IEnumerable<B>> Traverse< A, B>(this IEnumerable<Set<A>> ma, Func<A, B> f) =>
            SeqTrans<MEnumerable<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<IEnumerable<B>>, Set<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `IEnumerable&lt;Set&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Set&lt;IEnumerable&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Set<IEnumerable<A>> Sequence< A>(this IEnumerable<Set<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Set<B>> MapT< A, B>(this IEnumerable<Set<A>> ma, Func<A, B> f) =>
            SeqTrans<MEnumerable<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MEnumerable<Set<B>>, IEnumerable<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this IEnumerable<Set<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MEnumerable<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this IEnumerable<Set<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MEnumerable<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this IEnumerable<Set<A>> ma, Func<A, bool> f) =>
            SeqTrans<MEnumerable<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this IEnumerable<Set<A>> ma, Func<A, bool> f) =>
            SeqTrans<MEnumerable<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `IEnumerable&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this IEnumerable<Set<A>> ma, Action<A> f) =>
            SeqTrans<MEnumerable<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;Set&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<Set<A>> FilterT< A>(this IEnumerable<Set<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MEnumerable<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MEnumerable<Set<A>>, IEnumerable<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Set&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<Set<A>> PlusT<NUM,  A>(this IEnumerable<Set<A>> x, IEnumerable<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Set&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<Set<A>> SubtractT<NUM,  A>(this IEnumerable<Set<A>> x, IEnumerable<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Set&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static IEnumerable<Set<A>> ProductT<NUM,  A>(this IEnumerable<Set<A>> x, IEnumerable<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Set&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static IEnumerable<Set<A>> DivideT<NUM,  A>(this IEnumerable<Set<A>> x, IEnumerable<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Set&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static IEnumerable<Set<A>> AppendT<SEMI,  A>(this IEnumerable<Set<A>> x, IEnumerable<Set<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this IEnumerable<Set<A>> x, IEnumerable<Set<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Set&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this IEnumerable<Set<A>> x, IEnumerable<Set<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `IEnumerable&lt;Set&lt;A&gt;&gt;`</param>
        /// <returns>`IEnumerable&lt;Set&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static IEnumerable<Set<B>> ApplyT< A, B>(this Func<A, B> fab, IEnumerable<Set<A>> fa) =>
            ApplEnumerable< Set<A>, Set<B>>.Inst.Apply(
                 MEnumerable< Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => ApplSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `IEnumerable&lt;Set&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `IEnumerable&lt;Set&lt;A&gt;&gt;`</param>
        /// <returns>`IEnumerable&lt;Set&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static IEnumerable<Set<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, IEnumerable<Set<A>> fa, IEnumerable<Set<B>> fb) =>
            ApplEnumerable< Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MEnumerable< Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            ApplSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Seq&lt;Set&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Seq<Set<C>> SelectMany< A, B, C>(
            this Seq<Set<A>> ma,
            Func<A, Seq<Set<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MSeq<Set<A>>, Seq<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MSeq<Set<C>>, Seq<Set<C>>, MSet<C>, Set<C>, C>(ma, a =>
                    SeqTrans<MSeq<Set<B>>, Seq<Set<B>>, MSet<B>, Set<B>, B>
                        .Inst.Bind<MSeq<Set<C>>, Seq<Set<C>>, MSet<C>, Set<C>, C>(bind(a), b =>
                            default(MSet<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;Set&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<Set<A>> Where< A>(this Seq<Set<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSeq<Set<A>>, Seq<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MSeq<Set<A>>, Seq<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<Set<B>> Select< A, B>(this Seq<Set<A>> ma, Func<A, B> f) =>
            SeqTrans<MSeq<Set<A>>, Seq<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MSeq<Set<B>>, Seq<Set<B>>, MSet<B>, Set<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Seq&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Set&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Seq&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Seq<Set<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MSeq<Set<A>>, Seq<Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Seq&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Set&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Seq&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Seq<Set<A>> ma) =>
            SeqTrans<MSeq<Set<A>>, Seq<Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Seq&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<Set<B>> BindT< A, B>(this Seq<Set<A>> ma, Func<A, Set<B>> f) =>
            SeqTrans<MSeq<Set<A>>, Seq<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MSeq<Set<B>>, Seq<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Seq&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<Set<B>> BindT< A, B>(this Seq<Set<A>> ma, Func<A, Seq<Set<B>>> f) =>
            SeqTrans<MSeq<Set<A>>, Seq<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MSeq<Set<B>>, Seq<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Seq&lt;Set&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Set&lt;Seq&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;Seq&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Set<Seq<B>> Traverse< A, B>(this Seq<Set<A>> ma, Func<A, B> f) =>
            SeqTrans<MSeq<Set<A>>, Seq<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<Seq<B>>, Set<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Seq&lt;Set&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Set&lt;Seq&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Set<Seq<A>> Sequence< A>(this Seq<Set<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<Set<B>> MapT< A, B>(this Seq<Set<A>> ma, Func<A, B> f) =>
            SeqTrans<MSeq<Set<A>>, Seq<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MSeq<Set<B>>, Seq<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Seq<Set<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSeq<Set<A>>, Seq<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Seq<Set<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSeq<Set<A>>, Seq<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Seq<Set<A>> ma, Func<A, bool> f) =>
            SeqTrans<MSeq<Set<A>>, Seq<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Seq<Set<A>> ma, Func<A, bool> f) =>
            SeqTrans<MSeq<Set<A>>, Seq<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Seq&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Seq<Set<A>> ma, Action<A> f) =>
            SeqTrans<MSeq<Set<A>>, Seq<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;Set&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<Set<A>> FilterT< A>(this Seq<Set<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSeq<Set<A>>, Seq<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MSeq<Set<A>>, Seq<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Set&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Seq<Set<A>> PlusT<NUM,  A>(this Seq<Set<A>> x, Seq<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Set&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Seq<Set<A>> SubtractT<NUM,  A>(this Seq<Set<A>> x, Seq<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Set&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Seq<Set<A>> ProductT<NUM,  A>(this Seq<Set<A>> x, Seq<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Set&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Seq<Set<A>> DivideT<NUM,  A>(this Seq<Set<A>> x, Seq<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Set&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Seq<Set<A>> AppendT<SEMI,  A>(this Seq<Set<A>> x, Seq<Set<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Seq<Set<A>> x, Seq<Set<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Set&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Seq<Set<A>> x, Seq<Set<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Seq&lt;Set&lt;A&gt;&gt;`</param>
        /// <returns>`Seq&lt;Set&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Seq<Set<B>> ApplyT< A, B>(this Func<A, B> fab, Seq<Set<A>> fa) =>
            ApplSeq< Set<A>, Set<B>>.Inst.Apply(
                 MSeq< Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => ApplSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Seq&lt;Set&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Seq&lt;Set&lt;A&gt;&gt;`</param>
        /// <returns>`Seq&lt;Set&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Seq<Set<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Seq<Set<A>> fa, Seq<Set<B>> fb) =>
            ApplSeq< Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MSeq< Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            ApplSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Set&lt;Set&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Set<Set<C>> SelectMany< A, B, C>(
            this Set<Set<A>> ma,
            Func<A, Set<Set<B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MSet<Set<C>>, Set<Set<C>>, MSet<C>, Set<C>, C>(ma, a =>
                    SeqTrans<MSet<Set<B>>, Set<Set<B>>, MSet<B>, Set<B>, B>
                        .Inst.Bind<MSet<Set<C>>, Set<Set<C>>, MSet<C>, Set<C>, C>(bind(a), b =>
                            default(MSet<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;Set&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<Set<A>> Where< A>(this Set<Set<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Set<B>> Select< A, B>(this Set<Set<A>> ma, Func<A, B> f) =>
            SeqTrans<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MSet<Set<B>>, Set<Set<B>>, MSet<B>, Set<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Set&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Set&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Set&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA,  A>(this Set<Set<A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Set&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Set&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Set&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT< A>(this Set<Set<A>> ma) =>
            SeqTrans<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Set<B>> BindT< A, B>(this Set<Set<A>> ma, Func<A, Set<B>> f) =>
            SeqTrans<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MSet<Set<B>>, Set<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Set<B>> BindT< A, B>(this Set<Set<A>> ma, Func<A, Set<Set<B>>> f) =>
            SeqTrans<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MSet<Set<B>>, Set<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Set&lt;Set&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Set&lt;Set&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;Set&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Set<Set<B>> Traverse< A, B>(this Set<Set<A>> ma, Func<A, B> f) =>
            SeqTrans<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<Set<B>>, Set<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Set&lt;Set&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Set&lt;Set&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse< A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Set<Set<A>> Sequence< A>(this Set<Set<A>> ma) =>
            ma.Traverse< A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Set<B>> MapT< A, B>(this Set<Set<A>> ma, Func<A, B> f) =>
            SeqTrans<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MSet<Set<B>>, Set<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S,  A>(this Set<Set<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S,  A>(this Set<Set<A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT< A>(this Set<Set<A>> ma, Func<A, bool> f) =>
            SeqTrans<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT< A>(this Set<Set<A>> ma, Func<A, bool> f) =>
            SeqTrans<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Set&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT< A>(this Set<Set<A>> ma, Action<A> f) =>
            SeqTrans<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;Set&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<Set<A>> FilterT< A>(this Set<Set<A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MSet<Set<A>>, Set<Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Set&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Set<Set<A>> PlusT<NUM,  A>(this Set<Set<A>> x, Set<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Set&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Set<Set<A>> SubtractT<NUM,  A>(this Set<Set<A>> x, Set<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Set&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Set<Set<A>> ProductT<NUM,  A>(this Set<Set<A>> x, Set<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Set&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Set<Set<A>> DivideT<NUM,  A>(this Set<Set<A>> x, Set<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Set&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Set<Set<A>> AppendT<SEMI,  A>(this Set<Set<A>> x, Set<Set<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD,  A>(this Set<Set<A>> x, Set<Set<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Set&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ,  A>(this Set<Set<A>> x, Set<Set<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Set&lt;Set&lt;A&gt;&gt;`</param>
        /// <returns>`Set&lt;Set&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Set<Set<B>> ApplyT< A, B>(this Func<A, B> fab, Set<Set<A>> fa) =>
            ApplSet< Set<A>, Set<B>>.Inst.Apply(
                 MSet< Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => ApplSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Set&lt;Set&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Set&lt;Set&lt;A&gt;&gt;`</param>
        /// <returns>`Set&lt;Set&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Set<Set<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Set<Set<A>> fa, Set<Set<B>> fb) =>
            ApplSet< Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MSet< Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            ApplSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Validation&lt;FAIL, Set&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Validation<FAIL, Set<C>> SelectMany<FAIL, A, B, C>(
            this Validation<FAIL, Set<A>> ma,
            Func<A, Validation<FAIL, Set<B>>> bind,
            Func<A, B, C> project) =>
            Trans<MValidation<FAIL, Set<A>>, Validation<FAIL, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MValidation<FAIL, Set<C>>, Validation<FAIL, Set<C>>, MSet<C>, Set<C>, C>(ma, a =>
                    Trans<MValidation<FAIL, Set<B>>, Validation<FAIL, Set<B>>, MSet<B>, Set<B>, B>
                        .Inst.Bind<MValidation<FAIL, Set<C>>, Validation<FAIL, Set<C>>, MSet<C>, Set<C>, C>(bind(a), b =>
                            default(MSet<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, Set&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, Set<A>> Where<FAIL, A>(this Validation<FAIL, Set<A>> ma, Func<A, bool> pred) =>
            Trans<MValidation<FAIL, Set<A>>, Validation<FAIL, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MValidation<FAIL, Set<A>>, Validation<FAIL, Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, Set<B>> Select<FAIL, A, B>(this Validation<FAIL, Set<A>> ma, Func<A, B> f) =>
            Trans<MValidation<FAIL, Set<A>>, Validation<FAIL, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MValidation<FAIL, Set<B>>, Validation<FAIL, Set<B>>, MSet<B>, Set<B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Validation&lt;FAIL, Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Set&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Validation&lt;FAIL, Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, FAIL, A>(this Validation<FAIL, Set<A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MValidation<FAIL, Set<A>>, Validation<FAIL, Set<A>>, MSet<A>, Set<A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Validation&lt;FAIL, Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Set&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Validation&lt;FAIL, Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<FAIL, A>(this Validation<FAIL, Set<A>> ma) =>
            Trans<MValidation<FAIL, Set<A>>, Validation<FAIL, Set<A>>, MSet<A>, Set<A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Validation&lt;FAIL, Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, Set<B>> BindT<FAIL, A, B>(this Validation<FAIL, Set<A>> ma, Func<A, Set<B>> f) =>
            Trans<MValidation<FAIL, Set<A>>, Validation<FAIL, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MValidation<FAIL, Set<B>>, Validation<FAIL, Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Validation&lt;FAIL, Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, Set<B>> BindT<FAIL, A, B>(this Validation<FAIL, Set<A>> ma, Func<A, Validation<FAIL, Set<B>>> f) =>
            Trans<MValidation<FAIL, Set<A>>, Validation<FAIL, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MValidation<FAIL, Set<B>>, Validation<FAIL, Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Validation&lt;FAIL, Set&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Set&lt;Validation&lt;FAIL, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;Validation&lt;FAIL, B&gt;&gt;`</returns>
        [Pure]
        public static Set<Validation<FAIL, B>> Traverse<FAIL, A, B>(this Validation<FAIL, Set<A>> ma, Func<A, B> f) =>
            SeqTrans<MValidation<FAIL, Set<A>>, Validation<FAIL, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Traverse<MSet<Validation<FAIL, B>>, Set<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Validation&lt;FAIL, Set&lt;A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Set&lt;Validation&lt;FAIL, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<FAIL, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static Set<Validation<FAIL, A>> Sequence<FAIL, A>(this Validation<FAIL, Set<A>> ma) =>
            ma.Traverse<FAIL, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, Set<B>> MapT<FAIL, A, B>(this Validation<FAIL, Set<A>> ma, Func<A, B> f) =>
            Trans<MValidation<FAIL, Set<A>>, Validation<FAIL, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Map<MValidation<FAIL, Set<B>>, Validation<FAIL, Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, FAIL, A>(this Validation<FAIL, Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MValidation<FAIL, Set<A>>, Validation<FAIL, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, FAIL, A>(this Validation<FAIL, Set<A>> ma, S state, Func<S, A, S> f) =>
            Trans<MValidation<FAIL, Set<A>>, Validation<FAIL, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<FAIL, A>(this Validation<FAIL, Set<A>> ma, Func<A, bool> f) =>
            Trans<MValidation<FAIL, Set<A>>, Validation<FAIL, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<FAIL, A>(this Validation<FAIL, Set<A>> ma, Func<A, bool> f) =>
            Trans<MValidation<FAIL, Set<A>>, Validation<FAIL, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Validation&lt;FAIL, Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<FAIL, A>(this Validation<FAIL, Set<A>> ma, Action<A> f) =>
            Trans<MValidation<FAIL, Set<A>>, Validation<FAIL, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, Set&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, Set<A>> FilterT<FAIL, A>(this Validation<FAIL, Set<A>> ma, Func<A, bool> pred) =>
            Trans<MValidation<FAIL, Set<A>>, Validation<FAIL, Set<A>>, MSet<A>, Set<A>, A>
                .Inst.Bind<MValidation<FAIL, Set<A>>, Validation<FAIL, Set<A>>, MSet<A>, Set<A>, A>(ma, 
                    a => pred(a)
                        ? default(MSet<A>).Return(a)
                        : default(MSet<A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Set&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Validation<FAIL, Set<A>> PlusT<NUM, FAIL, A>(this Validation<FAIL, Set<A>> x, Validation<FAIL, Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Set&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Validation<FAIL, Set<A>> SubtractT<NUM, FAIL, A>(this Validation<FAIL, Set<A>> x, Validation<FAIL, Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Set&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Validation<FAIL, Set<A>> ProductT<NUM, FAIL, A>(this Validation<FAIL, Set<A>> x, Validation<FAIL, Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Set&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Validation<FAIL, Set<A>> DivideT<NUM, FAIL, A>(this Validation<FAIL, Set<A>> x, Validation<FAIL, Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Set&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Validation<FAIL, Set<A>> AppendT<SEMI, FAIL, A>(this Validation<FAIL, Set<A>> x, Validation<FAIL, Set<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, FAIL, A>(this Validation<FAIL, Set<A>> x, Validation<FAIL, Set<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Set&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, FAIL, A>(this Validation<FAIL, Set<A>> x, Validation<FAIL, Set<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Validation&lt;FAIL, Set&lt;A&gt;&gt;`</param>
        /// <returns>`Validation&lt;FAIL, Set&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Validation<FAIL, Set<B>> ApplyT<FAIL, A, B>(this Func<A, B> fab, Validation<FAIL, Set<A>> fa) =>
            ApplValidation<FAIL, Set<A>, Set<B>>.Inst.Apply(
                 MValidation<FAIL, Func<Set<A>, Set<B>>>.Inst.Return((Set<A> a) => ApplSet< A, B>.Inst.Apply(
                     MSet< Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Validation&lt;FAIL, Set&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Validation&lt;FAIL, Set&lt;A&gt;&gt;`</param>
        /// <returns>`Validation&lt;FAIL, Set&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Validation<FAIL, Set<C>> ApplyT<FAIL, A, B, C>(this Func<A, B, C> fabc, Validation<FAIL, Set<A>> fa, Validation<FAIL, Set<B>> fb) =>
            ApplValidation<FAIL, Set<A>, Set<B>, Set<C>>.Inst.Apply(
                MValidation<FAIL, Func<Set<A>, Func<Set<B>, Set<C>>>>.Inst.Return(
                    (Set<A> a) =>
                        (Set<B> b) =>
                            ApplSet< A, B, C>.Inst.Apply(
                                MSet< Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
    /// <summary>
    /// Monad transformer for Validation, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class ValidationT_Extensions
    {
        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Arr&lt;Validation&lt;FAIL, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Arr<Validation<FAIL, C>> SelectMany<FAIL, A, B, C>(
            this Arr<Validation<FAIL, A>> ma,
            Func<A, Arr<Validation<FAIL, B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MArr<Validation<FAIL, A>>, Arr<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MArr<Validation<FAIL, C>>, Arr<Validation<FAIL, C>>, MValidation<FAIL, C>, Validation<FAIL, C>, C>(ma, a =>
                    SeqTrans<MArr<Validation<FAIL, B>>, Arr<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>
                        .Inst.Bind<MArr<Validation<FAIL, C>>, Arr<Validation<FAIL, C>>, MValidation<FAIL, C>, Validation<FAIL, C>, C>(bind(a), b =>
                            default(MValidation<FAIL, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;Validation&lt;FAIL, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<Validation<FAIL, A>> Where<FAIL, A>(this Arr<Validation<FAIL, A>> ma, Func<A, bool> pred) =>
            SeqTrans<MArr<Validation<FAIL, A>>, Arr<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MArr<Validation<FAIL, A>>, Arr<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>(ma, 
                    a => pred(a)
                        ? default(MValidation<FAIL, A>).Return(a)
                        : default(MValidation<FAIL, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Validation<FAIL, B>> Select<FAIL, A, B>(this Arr<Validation<FAIL, A>> ma, Func<A, B> f) =>
            SeqTrans<MArr<Validation<FAIL, A>>, Arr<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Map<MArr<Validation<FAIL, B>>, Arr<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Arr&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Arr&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, FAIL, A>(this Arr<Validation<FAIL, A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MArr<Validation<FAIL, A>>, Arr<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Arr&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Arr&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<FAIL, A>(this Arr<Validation<FAIL, A>> ma) =>
            SeqTrans<MArr<Validation<FAIL, A>>, Arr<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Validation<FAIL, B>> BindT<FAIL, A, B>(this Arr<Validation<FAIL, A>> ma, Func<A, Validation<FAIL, B>> f) =>
            SeqTrans<MArr<Validation<FAIL, A>>, Arr<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MArr<Validation<FAIL, B>>, Arr<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Arr&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Validation<FAIL, B>> BindT<FAIL, A, B>(this Arr<Validation<FAIL, A>> ma, Func<A, Arr<Validation<FAIL, B>>> f) =>
            SeqTrans<MArr<Validation<FAIL, A>>, Arr<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MArr<Validation<FAIL, B>>, Arr<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Arr&lt;Validation&lt;FAIL, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Validation&lt;FAIL, Arr&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, Arr&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Validation<FAIL, Arr<B>> Traverse<FAIL, A, B>(this Arr<Validation<FAIL, A>> ma, Func<A, B> f) =>
            Trans<MArr<Validation<FAIL, A>>, Arr<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Traverse<MValidation<FAIL, Arr<B>>, Validation<FAIL, Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Arr&lt;Validation&lt;FAIL, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Validation&lt;FAIL, Arr&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<FAIL, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Validation<FAIL, Arr<A>> Sequence<FAIL, A>(this Arr<Validation<FAIL, A>> ma) =>
            ma.Traverse<FAIL, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Arr&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Arr<Validation<FAIL, B>> MapT<FAIL, A, B>(this Arr<Validation<FAIL, A>> ma, Func<A, B> f) =>
            SeqTrans<MArr<Validation<FAIL, A>>, Arr<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Map<MArr<Validation<FAIL, B>>, Arr<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, FAIL, A>(this Arr<Validation<FAIL, A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MArr<Validation<FAIL, A>>, Arr<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Arr&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, FAIL, A>(this Arr<Validation<FAIL, A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MArr<Validation<FAIL, A>>, Arr<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<FAIL, A>(this Arr<Validation<FAIL, A>> ma, Func<A, bool> f) =>
            SeqTrans<MArr<Validation<FAIL, A>>, Arr<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<FAIL, A>(this Arr<Validation<FAIL, A>> ma, Func<A, bool> f) =>
            SeqTrans<MArr<Validation<FAIL, A>>, Arr<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Arr&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<FAIL, A>(this Arr<Validation<FAIL, A>> ma, Action<A> f) =>
            SeqTrans<MArr<Validation<FAIL, A>>, Arr<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Arr&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Arr&lt;Validation&lt;FAIL, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Arr<Validation<FAIL, A>> FilterT<FAIL, A>(this Arr<Validation<FAIL, A>> ma, Func<A, bool> pred) =>
            SeqTrans<MArr<Validation<FAIL, A>>, Arr<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MArr<Validation<FAIL, A>>, Arr<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>(ma, 
                    a => pred(a)
                        ? default(MValidation<FAIL, A>).Return(a)
                        : default(MValidation<FAIL, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Arr<Validation<FAIL, A>> PlusT<NUM, FAIL, A>(this Arr<Validation<FAIL, A>> x, Arr<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Arr<Validation<FAIL, A>> SubtractT<NUM, FAIL, A>(this Arr<Validation<FAIL, A>> x, Arr<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Arr<Validation<FAIL, A>> ProductT<NUM, FAIL, A>(this Arr<Validation<FAIL, A>> x, Arr<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Arr<Validation<FAIL, A>> DivideT<NUM, FAIL, A>(this Arr<Validation<FAIL, A>> x, Arr<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Arr<Validation<FAIL, A>> AppendT<SEMI, FAIL, A>(this Arr<Validation<FAIL, A>> x, Arr<Validation<FAIL, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, FAIL, A>(this Arr<Validation<FAIL, A>> x, Arr<Validation<FAIL, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Arr&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, FAIL, A>(this Arr<Validation<FAIL, A>> x, Arr<Validation<FAIL, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Arr&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <returns>`Arr&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Arr<Validation<FAIL, B>> ApplyT<FAIL, A, B>(this Func<A, B> fab, Arr<Validation<FAIL, A>> fa) =>
            ApplArr< Validation<FAIL, A>, Validation<FAIL, B>>.Inst.Apply(
                 MArr< Func<Validation<FAIL, A>, Validation<FAIL, B>>>.Inst.Return((Validation<FAIL, A> a) => ApplValidation<FAIL, A, B>.Inst.Apply(
                     MValidation<FAIL, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Arr&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Arr&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <returns>`Arr&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Arr<Validation<FAIL, C>> ApplyT<FAIL, A, B, C>(this Func<A, B, C> fabc, Arr<Validation<FAIL, A>> fa, Arr<Validation<FAIL, B>> fb) =>
            ApplArr< Validation<FAIL, A>, Validation<FAIL, B>, Validation<FAIL, C>>.Inst.Apply(
                MArr< Func<Validation<FAIL, A>, Func<Validation<FAIL, B>, Validation<FAIL, C>>>>.Inst.Return(
                    (Validation<FAIL, A> a) =>
                        (Validation<FAIL, B> b) =>
                            ApplValidation<FAIL, A, B, C>.Inst.Apply(
                                MValidation<FAIL, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`HashSet&lt;Validation&lt;FAIL, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static HashSet<Validation<FAIL, C>> SelectMany<FAIL, A, B, C>(
            this HashSet<Validation<FAIL, A>> ma,
            Func<A, HashSet<Validation<FAIL, B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MHashSet<Validation<FAIL, A>>, HashSet<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MHashSet<Validation<FAIL, C>>, HashSet<Validation<FAIL, C>>, MValidation<FAIL, C>, Validation<FAIL, C>, C>(ma, a =>
                    SeqTrans<MHashSet<Validation<FAIL, B>>, HashSet<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>
                        .Inst.Bind<MHashSet<Validation<FAIL, C>>, HashSet<Validation<FAIL, C>>, MValidation<FAIL, C>, Validation<FAIL, C>, C>(bind(a), b =>
                            default(MValidation<FAIL, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;Validation&lt;FAIL, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<Validation<FAIL, A>> Where<FAIL, A>(this HashSet<Validation<FAIL, A>> ma, Func<A, bool> pred) =>
            SeqTrans<MHashSet<Validation<FAIL, A>>, HashSet<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MHashSet<Validation<FAIL, A>>, HashSet<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>(ma, 
                    a => pred(a)
                        ? default(MValidation<FAIL, A>).Return(a)
                        : default(MValidation<FAIL, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Validation<FAIL, B>> Select<FAIL, A, B>(this HashSet<Validation<FAIL, A>> ma, Func<A, B> f) =>
            SeqTrans<MHashSet<Validation<FAIL, A>>, HashSet<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Map<MHashSet<Validation<FAIL, B>>, HashSet<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `HashSet&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `HashSet&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, FAIL, A>(this HashSet<Validation<FAIL, A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MHashSet<Validation<FAIL, A>>, HashSet<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `HashSet&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `HashSet&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<FAIL, A>(this HashSet<Validation<FAIL, A>> ma) =>
            SeqTrans<MHashSet<Validation<FAIL, A>>, HashSet<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Validation<FAIL, B>> BindT<FAIL, A, B>(this HashSet<Validation<FAIL, A>> ma, Func<A, Validation<FAIL, B>> f) =>
            SeqTrans<MHashSet<Validation<FAIL, A>>, HashSet<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MHashSet<Validation<FAIL, B>>, HashSet<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`HashSet&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Validation<FAIL, B>> BindT<FAIL, A, B>(this HashSet<Validation<FAIL, A>> ma, Func<A, HashSet<Validation<FAIL, B>>> f) =>
            SeqTrans<MHashSet<Validation<FAIL, A>>, HashSet<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MHashSet<Validation<FAIL, B>>, HashSet<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `HashSet&lt;Validation&lt;FAIL, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Validation&lt;FAIL, HashSet&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, HashSet&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Validation<FAIL, HashSet<B>> Traverse<FAIL, A, B>(this HashSet<Validation<FAIL, A>> ma, Func<A, B> f) =>
            Trans<MHashSet<Validation<FAIL, A>>, HashSet<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Traverse<MValidation<FAIL, HashSet<B>>, Validation<FAIL, HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `HashSet&lt;Validation&lt;FAIL, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Validation&lt;FAIL, HashSet&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<FAIL, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Validation<FAIL, HashSet<A>> Sequence<FAIL, A>(this HashSet<Validation<FAIL, A>> ma) =>
            ma.Traverse<FAIL, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`HashSet&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static HashSet<Validation<FAIL, B>> MapT<FAIL, A, B>(this HashSet<Validation<FAIL, A>> ma, Func<A, B> f) =>
            SeqTrans<MHashSet<Validation<FAIL, A>>, HashSet<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Map<MHashSet<Validation<FAIL, B>>, HashSet<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, FAIL, A>(this HashSet<Validation<FAIL, A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MHashSet<Validation<FAIL, A>>, HashSet<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `HashSet&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, FAIL, A>(this HashSet<Validation<FAIL, A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MHashSet<Validation<FAIL, A>>, HashSet<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<FAIL, A>(this HashSet<Validation<FAIL, A>> ma, Func<A, bool> f) =>
            SeqTrans<MHashSet<Validation<FAIL, A>>, HashSet<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<FAIL, A>(this HashSet<Validation<FAIL, A>> ma, Func<A, bool> f) =>
            SeqTrans<MHashSet<Validation<FAIL, A>>, HashSet<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `HashSet&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<FAIL, A>(this HashSet<Validation<FAIL, A>> ma, Action<A> f) =>
            SeqTrans<MHashSet<Validation<FAIL, A>>, HashSet<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `HashSet&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`HashSet&lt;Validation&lt;FAIL, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static HashSet<Validation<FAIL, A>> FilterT<FAIL, A>(this HashSet<Validation<FAIL, A>> ma, Func<A, bool> pred) =>
            SeqTrans<MHashSet<Validation<FAIL, A>>, HashSet<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MHashSet<Validation<FAIL, A>>, HashSet<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>(ma, 
                    a => pred(a)
                        ? default(MValidation<FAIL, A>).Return(a)
                        : default(MValidation<FAIL, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static HashSet<Validation<FAIL, A>> PlusT<NUM, FAIL, A>(this HashSet<Validation<FAIL, A>> x, HashSet<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static HashSet<Validation<FAIL, A>> SubtractT<NUM, FAIL, A>(this HashSet<Validation<FAIL, A>> x, HashSet<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static HashSet<Validation<FAIL, A>> ProductT<NUM, FAIL, A>(this HashSet<Validation<FAIL, A>> x, HashSet<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static HashSet<Validation<FAIL, A>> DivideT<NUM, FAIL, A>(this HashSet<Validation<FAIL, A>> x, HashSet<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static HashSet<Validation<FAIL, A>> AppendT<SEMI, FAIL, A>(this HashSet<Validation<FAIL, A>> x, HashSet<Validation<FAIL, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, FAIL, A>(this HashSet<Validation<FAIL, A>> x, HashSet<Validation<FAIL, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`HashSet&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, FAIL, A>(this HashSet<Validation<FAIL, A>> x, HashSet<Validation<FAIL, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `HashSet&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <returns>`HashSet&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static HashSet<Validation<FAIL, B>> ApplyT<FAIL, A, B>(this Func<A, B> fab, HashSet<Validation<FAIL, A>> fa) =>
            ApplHashSet< Validation<FAIL, A>, Validation<FAIL, B>>.Inst.Apply(
                 MHashSet< Func<Validation<FAIL, A>, Validation<FAIL, B>>>.Inst.Return((Validation<FAIL, A> a) => ApplValidation<FAIL, A, B>.Inst.Apply(
                     MValidation<FAIL, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `HashSet&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `HashSet&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <returns>`HashSet&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static HashSet<Validation<FAIL, C>> ApplyT<FAIL, A, B, C>(this Func<A, B, C> fabc, HashSet<Validation<FAIL, A>> fa, HashSet<Validation<FAIL, B>> fb) =>
            ApplHashSet< Validation<FAIL, A>, Validation<FAIL, B>, Validation<FAIL, C>>.Inst.Apply(
                MHashSet< Func<Validation<FAIL, A>, Func<Validation<FAIL, B>, Validation<FAIL, C>>>>.Inst.Return(
                    (Validation<FAIL, A> a) =>
                        (Validation<FAIL, B> b) =>
                            ApplValidation<FAIL, A, B, C>.Inst.Apply(
                                MValidation<FAIL, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Lst&lt;Validation&lt;FAIL, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Lst<Validation<FAIL, C>> SelectMany<FAIL, A, B, C>(
            this Lst<Validation<FAIL, A>> ma,
            Func<A, Lst<Validation<FAIL, B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MLst<Validation<FAIL, A>>, Lst<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MLst<Validation<FAIL, C>>, Lst<Validation<FAIL, C>>, MValidation<FAIL, C>, Validation<FAIL, C>, C>(ma, a =>
                    SeqTrans<MLst<Validation<FAIL, B>>, Lst<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>
                        .Inst.Bind<MLst<Validation<FAIL, C>>, Lst<Validation<FAIL, C>>, MValidation<FAIL, C>, Validation<FAIL, C>, C>(bind(a), b =>
                            default(MValidation<FAIL, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;Validation&lt;FAIL, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<Validation<FAIL, A>> Where<FAIL, A>(this Lst<Validation<FAIL, A>> ma, Func<A, bool> pred) =>
            SeqTrans<MLst<Validation<FAIL, A>>, Lst<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MLst<Validation<FAIL, A>>, Lst<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>(ma, 
                    a => pred(a)
                        ? default(MValidation<FAIL, A>).Return(a)
                        : default(MValidation<FAIL, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Validation<FAIL, B>> Select<FAIL, A, B>(this Lst<Validation<FAIL, A>> ma, Func<A, B> f) =>
            SeqTrans<MLst<Validation<FAIL, A>>, Lst<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Map<MLst<Validation<FAIL, B>>, Lst<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Lst&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Lst&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, FAIL, A>(this Lst<Validation<FAIL, A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MLst<Validation<FAIL, A>>, Lst<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Lst&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Lst&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<FAIL, A>(this Lst<Validation<FAIL, A>> ma) =>
            SeqTrans<MLst<Validation<FAIL, A>>, Lst<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Validation<FAIL, B>> BindT<FAIL, A, B>(this Lst<Validation<FAIL, A>> ma, Func<A, Validation<FAIL, B>> f) =>
            SeqTrans<MLst<Validation<FAIL, A>>, Lst<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MLst<Validation<FAIL, B>>, Lst<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Lst&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Validation<FAIL, B>> BindT<FAIL, A, B>(this Lst<Validation<FAIL, A>> ma, Func<A, Lst<Validation<FAIL, B>>> f) =>
            SeqTrans<MLst<Validation<FAIL, A>>, Lst<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MLst<Validation<FAIL, B>>, Lst<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Lst&lt;Validation&lt;FAIL, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Validation&lt;FAIL, Lst&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, Lst&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Validation<FAIL, Lst<B>> Traverse<FAIL, A, B>(this Lst<Validation<FAIL, A>> ma, Func<A, B> f) =>
            Trans<MLst<Validation<FAIL, A>>, Lst<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Traverse<MValidation<FAIL, Lst<B>>, Validation<FAIL, Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Lst&lt;Validation&lt;FAIL, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Validation&lt;FAIL, Lst&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<FAIL, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Validation<FAIL, Lst<A>> Sequence<FAIL, A>(this Lst<Validation<FAIL, A>> ma) =>
            ma.Traverse<FAIL, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Lst&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Lst<Validation<FAIL, B>> MapT<FAIL, A, B>(this Lst<Validation<FAIL, A>> ma, Func<A, B> f) =>
            SeqTrans<MLst<Validation<FAIL, A>>, Lst<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Map<MLst<Validation<FAIL, B>>, Lst<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, FAIL, A>(this Lst<Validation<FAIL, A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MLst<Validation<FAIL, A>>, Lst<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Lst&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, FAIL, A>(this Lst<Validation<FAIL, A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MLst<Validation<FAIL, A>>, Lst<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<FAIL, A>(this Lst<Validation<FAIL, A>> ma, Func<A, bool> f) =>
            SeqTrans<MLst<Validation<FAIL, A>>, Lst<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<FAIL, A>(this Lst<Validation<FAIL, A>> ma, Func<A, bool> f) =>
            SeqTrans<MLst<Validation<FAIL, A>>, Lst<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Lst&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<FAIL, A>(this Lst<Validation<FAIL, A>> ma, Action<A> f) =>
            SeqTrans<MLst<Validation<FAIL, A>>, Lst<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Lst&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Lst&lt;Validation&lt;FAIL, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Lst<Validation<FAIL, A>> FilterT<FAIL, A>(this Lst<Validation<FAIL, A>> ma, Func<A, bool> pred) =>
            SeqTrans<MLst<Validation<FAIL, A>>, Lst<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MLst<Validation<FAIL, A>>, Lst<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>(ma, 
                    a => pred(a)
                        ? default(MValidation<FAIL, A>).Return(a)
                        : default(MValidation<FAIL, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Lst<Validation<FAIL, A>> PlusT<NUM, FAIL, A>(this Lst<Validation<FAIL, A>> x, Lst<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Lst<Validation<FAIL, A>> SubtractT<NUM, FAIL, A>(this Lst<Validation<FAIL, A>> x, Lst<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Lst<Validation<FAIL, A>> ProductT<NUM, FAIL, A>(this Lst<Validation<FAIL, A>> x, Lst<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Lst<Validation<FAIL, A>> DivideT<NUM, FAIL, A>(this Lst<Validation<FAIL, A>> x, Lst<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Lst<Validation<FAIL, A>> AppendT<SEMI, FAIL, A>(this Lst<Validation<FAIL, A>> x, Lst<Validation<FAIL, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, FAIL, A>(this Lst<Validation<FAIL, A>> x, Lst<Validation<FAIL, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Lst&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, FAIL, A>(this Lst<Validation<FAIL, A>> x, Lst<Validation<FAIL, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Lst&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <returns>`Lst&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Lst<Validation<FAIL, B>> ApplyT<FAIL, A, B>(this Func<A, B> fab, Lst<Validation<FAIL, A>> fa) =>
            ApplLst< Validation<FAIL, A>, Validation<FAIL, B>>.Inst.Apply(
                 MLst< Func<Validation<FAIL, A>, Validation<FAIL, B>>>.Inst.Return((Validation<FAIL, A> a) => ApplValidation<FAIL, A, B>.Inst.Apply(
                     MValidation<FAIL, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Lst&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Lst&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <returns>`Lst&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Lst<Validation<FAIL, C>> ApplyT<FAIL, A, B, C>(this Func<A, B, C> fabc, Lst<Validation<FAIL, A>> fa, Lst<Validation<FAIL, B>> fb) =>
            ApplLst< Validation<FAIL, A>, Validation<FAIL, B>, Validation<FAIL, C>>.Inst.Apply(
                MLst< Func<Validation<FAIL, A>, Func<Validation<FAIL, B>, Validation<FAIL, C>>>>.Inst.Return(
                    (Validation<FAIL, A> a) =>
                        (Validation<FAIL, B> b) =>
                            ApplValidation<FAIL, A, B, C>.Inst.Apply(
                                MValidation<FAIL, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Option&lt;Validation&lt;FAIL, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Option<Validation<FAIL, C>> SelectMany<FAIL, A, B, C>(
            this Option<Validation<FAIL, A>> ma,
            Func<A, Option<Validation<FAIL, B>>> bind,
            Func<A, B, C> project) =>
            Trans<MOption<Validation<FAIL, A>>, Option<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MOption<Validation<FAIL, C>>, Option<Validation<FAIL, C>>, MValidation<FAIL, C>, Validation<FAIL, C>, C>(ma, a =>
                    Trans<MOption<Validation<FAIL, B>>, Option<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>
                        .Inst.Bind<MOption<Validation<FAIL, C>>, Option<Validation<FAIL, C>>, MValidation<FAIL, C>, Validation<FAIL, C>, C>(bind(a), b =>
                            default(MValidation<FAIL, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;Validation&lt;FAIL, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<Validation<FAIL, A>> Where<FAIL, A>(this Option<Validation<FAIL, A>> ma, Func<A, bool> pred) =>
            Trans<MOption<Validation<FAIL, A>>, Option<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MOption<Validation<FAIL, A>>, Option<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>(ma, 
                    a => pred(a)
                        ? default(MValidation<FAIL, A>).Return(a)
                        : default(MValidation<FAIL, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Validation<FAIL, B>> Select<FAIL, A, B>(this Option<Validation<FAIL, A>> ma, Func<A, B> f) =>
            Trans<MOption<Validation<FAIL, A>>, Option<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Map<MOption<Validation<FAIL, B>>, Option<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Option&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Option&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, FAIL, A>(this Option<Validation<FAIL, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOption<Validation<FAIL, A>>, Option<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Option&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Option&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<FAIL, A>(this Option<Validation<FAIL, A>> ma) =>
            Trans<MOption<Validation<FAIL, A>>, Option<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Validation<FAIL, B>> BindT<FAIL, A, B>(this Option<Validation<FAIL, A>> ma, Func<A, Validation<FAIL, B>> f) =>
            Trans<MOption<Validation<FAIL, A>>, Option<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MOption<Validation<FAIL, B>>, Option<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Option&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Validation<FAIL, B>> BindT<FAIL, A, B>(this Option<Validation<FAIL, A>> ma, Func<A, Option<Validation<FAIL, B>>> f) =>
            Trans<MOption<Validation<FAIL, A>>, Option<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MOption<Validation<FAIL, B>>, Option<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Option&lt;Validation&lt;FAIL, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Validation&lt;FAIL, Option&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, Option&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Validation<FAIL, Option<B>> Traverse<FAIL, A, B>(this Option<Validation<FAIL, A>> ma, Func<A, B> f) =>
            Trans<MOption<Validation<FAIL, A>>, Option<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Traverse<MValidation<FAIL, Option<B>>, Validation<FAIL, Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Option&lt;Validation&lt;FAIL, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Validation&lt;FAIL, Option&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<FAIL, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Validation<FAIL, Option<A>> Sequence<FAIL, A>(this Option<Validation<FAIL, A>> ma) =>
            ma.Traverse<FAIL, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Option&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Option<Validation<FAIL, B>> MapT<FAIL, A, B>(this Option<Validation<FAIL, A>> ma, Func<A, B> f) =>
            Trans<MOption<Validation<FAIL, A>>, Option<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Map<MOption<Validation<FAIL, B>>, Option<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, FAIL, A>(this Option<Validation<FAIL, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Validation<FAIL, A>>, Option<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Option&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, FAIL, A>(this Option<Validation<FAIL, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOption<Validation<FAIL, A>>, Option<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<FAIL, A>(this Option<Validation<FAIL, A>> ma, Func<A, bool> f) =>
            Trans<MOption<Validation<FAIL, A>>, Option<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<FAIL, A>(this Option<Validation<FAIL, A>> ma, Func<A, bool> f) =>
            Trans<MOption<Validation<FAIL, A>>, Option<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Option&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<FAIL, A>(this Option<Validation<FAIL, A>> ma, Action<A> f) =>
            Trans<MOption<Validation<FAIL, A>>, Option<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Option&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Option&lt;Validation&lt;FAIL, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Option<Validation<FAIL, A>> FilterT<FAIL, A>(this Option<Validation<FAIL, A>> ma, Func<A, bool> pred) =>
            Trans<MOption<Validation<FAIL, A>>, Option<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MOption<Validation<FAIL, A>>, Option<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>(ma, 
                    a => pred(a)
                        ? default(MValidation<FAIL, A>).Return(a)
                        : default(MValidation<FAIL, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Option<Validation<FAIL, A>> PlusT<NUM, FAIL, A>(this Option<Validation<FAIL, A>> x, Option<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Option<Validation<FAIL, A>> SubtractT<NUM, FAIL, A>(this Option<Validation<FAIL, A>> x, Option<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Option<Validation<FAIL, A>> ProductT<NUM, FAIL, A>(this Option<Validation<FAIL, A>> x, Option<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Option<Validation<FAIL, A>> DivideT<NUM, FAIL, A>(this Option<Validation<FAIL, A>> x, Option<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Option<Validation<FAIL, A>> AppendT<SEMI, FAIL, A>(this Option<Validation<FAIL, A>> x, Option<Validation<FAIL, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, FAIL, A>(this Option<Validation<FAIL, A>> x, Option<Validation<FAIL, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Option&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, FAIL, A>(this Option<Validation<FAIL, A>> x, Option<Validation<FAIL, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Option&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <returns>`Option&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Option<Validation<FAIL, B>> ApplyT<FAIL, A, B>(this Func<A, B> fab, Option<Validation<FAIL, A>> fa) =>
            ApplOption< Validation<FAIL, A>, Validation<FAIL, B>>.Inst.Apply(
                 MOption< Func<Validation<FAIL, A>, Validation<FAIL, B>>>.Inst.Return((Validation<FAIL, A> a) => ApplValidation<FAIL, A, B>.Inst.Apply(
                     MValidation<FAIL, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Option&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Option&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <returns>`Option&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Option<Validation<FAIL, C>> ApplyT<FAIL, A, B, C>(this Func<A, B, C> fabc, Option<Validation<FAIL, A>> fa, Option<Validation<FAIL, B>> fb) =>
            ApplOption< Validation<FAIL, A>, Validation<FAIL, B>, Validation<FAIL, C>>.Inst.Apply(
                MOption< Func<Validation<FAIL, A>, Func<Validation<FAIL, B>, Validation<FAIL, C>>>>.Inst.Return(
                    (Validation<FAIL, A> a) =>
                        (Validation<FAIL, B> b) =>
                            ApplValidation<FAIL, A, B, C>.Inst.Apply(
                                MValidation<FAIL, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionUnsafe&lt;Validation&lt;FAIL, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionUnsafe<Validation<FAIL, C>> SelectMany<FAIL, A, B, C>(
            this OptionUnsafe<Validation<FAIL, A>> ma,
            Func<A, OptionUnsafe<Validation<FAIL, B>>> bind,
            Func<A, B, C> project) =>
            Trans<MOptionUnsafe<Validation<FAIL, A>>, OptionUnsafe<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MOptionUnsafe<Validation<FAIL, C>>, OptionUnsafe<Validation<FAIL, C>>, MValidation<FAIL, C>, Validation<FAIL, C>, C>(ma, a =>
                    Trans<MOptionUnsafe<Validation<FAIL, B>>, OptionUnsafe<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>
                        .Inst.Bind<MOptionUnsafe<Validation<FAIL, C>>, OptionUnsafe<Validation<FAIL, C>>, MValidation<FAIL, C>, Validation<FAIL, C>, C>(bind(a), b =>
                            default(MValidation<FAIL, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;Validation&lt;FAIL, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<Validation<FAIL, A>> Where<FAIL, A>(this OptionUnsafe<Validation<FAIL, A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<Validation<FAIL, A>>, OptionUnsafe<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MOptionUnsafe<Validation<FAIL, A>>, OptionUnsafe<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>(ma, 
                    a => pred(a)
                        ? default(MValidation<FAIL, A>).Return(a)
                        : default(MValidation<FAIL, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Validation<FAIL, B>> Select<FAIL, A, B>(this OptionUnsafe<Validation<FAIL, A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Validation<FAIL, A>>, OptionUnsafe<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Map<MOptionUnsafe<Validation<FAIL, B>>, OptionUnsafe<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionUnsafe&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionUnsafe&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, FAIL, A>(this OptionUnsafe<Validation<FAIL, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MOptionUnsafe<Validation<FAIL, A>>, OptionUnsafe<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionUnsafe&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionUnsafe&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<FAIL, A>(this OptionUnsafe<Validation<FAIL, A>> ma) =>
            Trans<MOptionUnsafe<Validation<FAIL, A>>, OptionUnsafe<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Validation<FAIL, B>> BindT<FAIL, A, B>(this OptionUnsafe<Validation<FAIL, A>> ma, Func<A, Validation<FAIL, B>> f) =>
            Trans<MOptionUnsafe<Validation<FAIL, A>>, OptionUnsafe<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MOptionUnsafe<Validation<FAIL, B>>, OptionUnsafe<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionUnsafe&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Validation<FAIL, B>> BindT<FAIL, A, B>(this OptionUnsafe<Validation<FAIL, A>> ma, Func<A, OptionUnsafe<Validation<FAIL, B>>> f) =>
            Trans<MOptionUnsafe<Validation<FAIL, A>>, OptionUnsafe<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MOptionUnsafe<Validation<FAIL, B>>, OptionUnsafe<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `OptionUnsafe&lt;Validation&lt;FAIL, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Validation&lt;FAIL, OptionUnsafe&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, OptionUnsafe&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Validation<FAIL, OptionUnsafe<B>> Traverse<FAIL, A, B>(this OptionUnsafe<Validation<FAIL, A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Validation<FAIL, A>>, OptionUnsafe<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Traverse<MValidation<FAIL, OptionUnsafe<B>>, Validation<FAIL, OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `OptionUnsafe&lt;Validation&lt;FAIL, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Validation&lt;FAIL, OptionUnsafe&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<FAIL, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Validation<FAIL, OptionUnsafe<A>> Sequence<FAIL, A>(this OptionUnsafe<Validation<FAIL, A>> ma) =>
            ma.Traverse<FAIL, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionUnsafe&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionUnsafe<Validation<FAIL, B>> MapT<FAIL, A, B>(this OptionUnsafe<Validation<FAIL, A>> ma, Func<A, B> f) =>
            Trans<MOptionUnsafe<Validation<FAIL, A>>, OptionUnsafe<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Map<MOptionUnsafe<Validation<FAIL, B>>, OptionUnsafe<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, FAIL, A>(this OptionUnsafe<Validation<FAIL, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Validation<FAIL, A>>, OptionUnsafe<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, FAIL, A>(this OptionUnsafe<Validation<FAIL, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MOptionUnsafe<Validation<FAIL, A>>, OptionUnsafe<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<FAIL, A>(this OptionUnsafe<Validation<FAIL, A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Validation<FAIL, A>>, OptionUnsafe<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<FAIL, A>(this OptionUnsafe<Validation<FAIL, A>> ma, Func<A, bool> f) =>
            Trans<MOptionUnsafe<Validation<FAIL, A>>, OptionUnsafe<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionUnsafe&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<FAIL, A>(this OptionUnsafe<Validation<FAIL, A>> ma, Action<A> f) =>
            Trans<MOptionUnsafe<Validation<FAIL, A>>, OptionUnsafe<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionUnsafe&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionUnsafe&lt;Validation&lt;FAIL, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionUnsafe<Validation<FAIL, A>> FilterT<FAIL, A>(this OptionUnsafe<Validation<FAIL, A>> ma, Func<A, bool> pred) =>
            Trans<MOptionUnsafe<Validation<FAIL, A>>, OptionUnsafe<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MOptionUnsafe<Validation<FAIL, A>>, OptionUnsafe<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>(ma, 
                    a => pred(a)
                        ? default(MValidation<FAIL, A>).Return(a)
                        : default(MValidation<FAIL, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static OptionUnsafe<Validation<FAIL, A>> PlusT<NUM, FAIL, A>(this OptionUnsafe<Validation<FAIL, A>> x, OptionUnsafe<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static OptionUnsafe<Validation<FAIL, A>> SubtractT<NUM, FAIL, A>(this OptionUnsafe<Validation<FAIL, A>> x, OptionUnsafe<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionUnsafe<Validation<FAIL, A>> ProductT<NUM, FAIL, A>(this OptionUnsafe<Validation<FAIL, A>> x, OptionUnsafe<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionUnsafe<Validation<FAIL, A>> DivideT<NUM, FAIL, A>(this OptionUnsafe<Validation<FAIL, A>> x, OptionUnsafe<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionUnsafe<Validation<FAIL, A>> AppendT<SEMI, FAIL, A>(this OptionUnsafe<Validation<FAIL, A>> x, OptionUnsafe<Validation<FAIL, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, FAIL, A>(this OptionUnsafe<Validation<FAIL, A>> x, OptionUnsafe<Validation<FAIL, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionUnsafe&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, FAIL, A>(this OptionUnsafe<Validation<FAIL, A>> x, OptionUnsafe<Validation<FAIL, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <returns>`OptionUnsafe&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionUnsafe<Validation<FAIL, B>> ApplyT<FAIL, A, B>(this Func<A, B> fab, OptionUnsafe<Validation<FAIL, A>> fa) =>
            ApplOptionUnsafe< Validation<FAIL, A>, Validation<FAIL, B>>.Inst.Apply(
                 MOptionUnsafe< Func<Validation<FAIL, A>, Validation<FAIL, B>>>.Inst.Return((Validation<FAIL, A> a) => ApplValidation<FAIL, A, B>.Inst.Apply(
                     MValidation<FAIL, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionUnsafe&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `OptionUnsafe&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <returns>`OptionUnsafe&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionUnsafe<Validation<FAIL, C>> ApplyT<FAIL, A, B, C>(this Func<A, B, C> fabc, OptionUnsafe<Validation<FAIL, A>> fa, OptionUnsafe<Validation<FAIL, B>> fb) =>
            ApplOptionUnsafe< Validation<FAIL, A>, Validation<FAIL, B>, Validation<FAIL, C>>.Inst.Apply(
                MOptionUnsafe< Func<Validation<FAIL, A>, Func<Validation<FAIL, B>, Validation<FAIL, C>>>>.Inst.Return(
                    (Validation<FAIL, A> a) =>
                        (Validation<FAIL, B> b) =>
                            ApplValidation<FAIL, A, B, C>.Inst.Apply(
                                MValidation<FAIL, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Either&lt;L, Validation&lt;FAIL, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Either<L, Validation<FAIL, C>> SelectMany<L, FAIL, A, B, C>(
            this Either<L, Validation<FAIL, A>> ma,
            Func<A, Either<L, Validation<FAIL, B>>> bind,
            Func<A, B, C> project) =>
            Trans<MEither<L, Validation<FAIL, A>>, Either<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MEither<L, Validation<FAIL, C>>, Either<L, Validation<FAIL, C>>, MValidation<FAIL, C>, Validation<FAIL, C>, C>(ma, a =>
                    Trans<MEither<L, Validation<FAIL, B>>, Either<L, Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>
                        .Inst.Bind<MEither<L, Validation<FAIL, C>>, Either<L, Validation<FAIL, C>>, MValidation<FAIL, C>, Validation<FAIL, C>, C>(bind(a), b =>
                            default(MValidation<FAIL, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, Validation&lt;FAIL, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, Validation<FAIL, A>> Where<L, FAIL, A>(this Either<L, Validation<FAIL, A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, Validation<FAIL, A>>, Either<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MEither<L, Validation<FAIL, A>>, Either<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>(ma, 
                    a => pred(a)
                        ? default(MValidation<FAIL, A>).Return(a)
                        : default(MValidation<FAIL, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Validation<FAIL, B>> Select<L, FAIL, A, B>(this Either<L, Validation<FAIL, A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Validation<FAIL, A>>, Either<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Map<MEither<L, Validation<FAIL, B>>, Either<L, Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Either&lt;L, Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Either&lt;L, Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, FAIL, A>(this Either<L, Validation<FAIL, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEither<L, Validation<FAIL, A>>, Either<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Either&lt;L, Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Either&lt;L, Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, FAIL, A>(this Either<L, Validation<FAIL, A>> ma) =>
            Trans<MEither<L, Validation<FAIL, A>>, Either<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either&lt;L, Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Validation<FAIL, B>> BindT<L, FAIL, A, B>(this Either<L, Validation<FAIL, A>> ma, Func<A, Validation<FAIL, B>> f) =>
            Trans<MEither<L, Validation<FAIL, A>>, Either<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MEither<L, Validation<FAIL, B>>, Either<L, Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Either&lt;L, Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Validation<FAIL, B>> BindT<L, FAIL, A, B>(this Either<L, Validation<FAIL, A>> ma, Func<A, Either<L, Validation<FAIL, B>>> f) =>
            Trans<MEither<L, Validation<FAIL, A>>, Either<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MEither<L, Validation<FAIL, B>>, Either<L, Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Either&lt;L, Validation&lt;FAIL, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Validation&lt;FAIL, Either&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, Either&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static Validation<FAIL, Either<L, B>> Traverse<L, FAIL, A, B>(this Either<L, Validation<FAIL, A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Validation<FAIL, A>>, Either<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Traverse<MValidation<FAIL, Either<L, B>>, Validation<FAIL, Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Either&lt;L, Validation&lt;FAIL, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Validation&lt;FAIL, Either&lt;L, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, FAIL, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static Validation<FAIL, Either<L, A>> Sequence<L, FAIL, A>(this Either<L, Validation<FAIL, A>> ma) =>
            ma.Traverse<L, FAIL, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Either&lt;L, Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Either<L, Validation<FAIL, B>> MapT<L, FAIL, A, B>(this Either<L, Validation<FAIL, A>> ma, Func<A, B> f) =>
            Trans<MEither<L, Validation<FAIL, A>>, Either<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Map<MEither<L, Validation<FAIL, B>>, Either<L, Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, FAIL, A>(this Either<L, Validation<FAIL, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Validation<FAIL, A>>, Either<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Either&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, FAIL, A>(this Either<L, Validation<FAIL, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEither<L, Validation<FAIL, A>>, Either<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, FAIL, A>(this Either<L, Validation<FAIL, A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Validation<FAIL, A>>, Either<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, FAIL, A>(this Either<L, Validation<FAIL, A>> ma, Func<A, bool> f) =>
            Trans<MEither<L, Validation<FAIL, A>>, Either<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Either&lt;L, Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, FAIL, A>(this Either<L, Validation<FAIL, A>> ma, Action<A> f) =>
            Trans<MEither<L, Validation<FAIL, A>>, Either<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Either&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Either&lt;L, Validation&lt;FAIL, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Either<L, Validation<FAIL, A>> FilterT<L, FAIL, A>(this Either<L, Validation<FAIL, A>> ma, Func<A, bool> pred) =>
            Trans<MEither<L, Validation<FAIL, A>>, Either<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MEither<L, Validation<FAIL, A>>, Either<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>(ma, 
                    a => pred(a)
                        ? default(MValidation<FAIL, A>).Return(a)
                        : default(MValidation<FAIL, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Validation&lt;FAIL, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Either<L, Validation<FAIL, A>> PlusT<NUM, L, FAIL, A>(this Either<L, Validation<FAIL, A>> x, Either<L, Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Validation&lt;FAIL, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Either<L, Validation<FAIL, A>> SubtractT<NUM, L, FAIL, A>(this Either<L, Validation<FAIL, A>> x, Either<L, Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Either<L, Validation<FAIL, A>> ProductT<NUM, L, FAIL, A>(this Either<L, Validation<FAIL, A>> x, Either<L, Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Either<L, Validation<FAIL, A>> DivideT<NUM, L, FAIL, A>(this Either<L, Validation<FAIL, A>> x, Either<L, Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Either<L, Validation<FAIL, A>> AppendT<SEMI, L, FAIL, A>(this Either<L, Validation<FAIL, A>> x, Either<L, Validation<FAIL, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, FAIL, A>(this Either<L, Validation<FAIL, A>> x, Either<L, Validation<FAIL, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Either&lt;L, Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, FAIL, A>(this Either<L, Validation<FAIL, A>> x, Either<L, Validation<FAIL, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Either&lt;L, Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <returns>`Either&lt;L, Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Either<L, Validation<FAIL, B>> ApplyT<L, FAIL, A, B>(this Func<A, B> fab, Either<L, Validation<FAIL, A>> fa) =>
            ApplEither<L, Validation<FAIL, A>, Validation<FAIL, B>>.Inst.Apply(
                 MEither<L, Func<Validation<FAIL, A>, Validation<FAIL, B>>>.Inst.Return((Validation<FAIL, A> a) => ApplValidation<FAIL, A, B>.Inst.Apply(
                     MValidation<FAIL, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Either&lt;L, Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Either&lt;L, Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <returns>`Either&lt;L, Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Either<L, Validation<FAIL, C>> ApplyT<L, FAIL, A, B, C>(this Func<A, B, C> fabc, Either<L, Validation<FAIL, A>> fa, Either<L, Validation<FAIL, B>> fb) =>
            ApplEither<L, Validation<FAIL, A>, Validation<FAIL, B>, Validation<FAIL, C>>.Inst.Apply(
                MEither<L, Func<Validation<FAIL, A>, Func<Validation<FAIL, B>, Validation<FAIL, C>>>>.Inst.Return(
                    (Validation<FAIL, A> a) =>
                        (Validation<FAIL, B> b) =>
                            ApplValidation<FAIL, A, B, C>.Inst.Apply(
                                MValidation<FAIL, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`EitherUnsafe&lt;L, Validation&lt;FAIL, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static EitherUnsafe<L, Validation<FAIL, C>> SelectMany<L, FAIL, A, B, C>(
            this EitherUnsafe<L, Validation<FAIL, A>> ma,
            Func<A, EitherUnsafe<L, Validation<FAIL, B>>> bind,
            Func<A, B, C> project) =>
            Trans<MEitherUnsafe<L, Validation<FAIL, A>>, EitherUnsafe<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MEitherUnsafe<L, Validation<FAIL, C>>, EitherUnsafe<L, Validation<FAIL, C>>, MValidation<FAIL, C>, Validation<FAIL, C>, C>(ma, a =>
                    Trans<MEitherUnsafe<L, Validation<FAIL, B>>, EitherUnsafe<L, Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>
                        .Inst.Bind<MEitherUnsafe<L, Validation<FAIL, C>>, EitherUnsafe<L, Validation<FAIL, C>>, MValidation<FAIL, C>, Validation<FAIL, C>, C>(bind(a), b =>
                            default(MValidation<FAIL, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, Validation&lt;FAIL, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, Validation<FAIL, A>> Where<L, FAIL, A>(this EitherUnsafe<L, Validation<FAIL, A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, Validation<FAIL, A>>, EitherUnsafe<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MEitherUnsafe<L, Validation<FAIL, A>>, EitherUnsafe<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>(ma, 
                    a => pred(a)
                        ? default(MValidation<FAIL, A>).Return(a)
                        : default(MValidation<FAIL, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Validation<FAIL, B>> Select<L, FAIL, A, B>(this EitherUnsafe<L, Validation<FAIL, A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Validation<FAIL, A>>, EitherUnsafe<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Map<MEitherUnsafe<L, Validation<FAIL, B>>, EitherUnsafe<L, Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherUnsafe&lt;L, Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherUnsafe&lt;L, Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, L, FAIL, A>(this EitherUnsafe<L, Validation<FAIL, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MEitherUnsafe<L, Validation<FAIL, A>>, EitherUnsafe<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherUnsafe&lt;L, Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherUnsafe&lt;L, Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<L, FAIL, A>(this EitherUnsafe<L, Validation<FAIL, A>> ma) =>
            Trans<MEitherUnsafe<L, Validation<FAIL, A>>, EitherUnsafe<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Validation<FAIL, B>> BindT<L, FAIL, A, B>(this EitherUnsafe<L, Validation<FAIL, A>> ma, Func<A, Validation<FAIL, B>> f) =>
            Trans<MEitherUnsafe<L, Validation<FAIL, A>>, EitherUnsafe<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MEitherUnsafe<L, Validation<FAIL, B>>, EitherUnsafe<L, Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Validation<FAIL, B>> BindT<L, FAIL, A, B>(this EitherUnsafe<L, Validation<FAIL, A>> ma, Func<A, EitherUnsafe<L, Validation<FAIL, B>>> f) =>
            Trans<MEitherUnsafe<L, Validation<FAIL, A>>, EitherUnsafe<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MEitherUnsafe<L, Validation<FAIL, B>>, EitherUnsafe<L, Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `EitherUnsafe&lt;L, Validation&lt;FAIL, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Validation&lt;FAIL, EitherUnsafe&lt;L, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, EitherUnsafe&lt;L, B&gt;&gt;`</returns>
        [Pure]
        public static Validation<FAIL, EitherUnsafe<L, B>> Traverse<L, FAIL, A, B>(this EitherUnsafe<L, Validation<FAIL, A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Validation<FAIL, A>>, EitherUnsafe<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Traverse<MValidation<FAIL, EitherUnsafe<L, B>>, Validation<FAIL, EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `EitherUnsafe&lt;L, Validation&lt;FAIL, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Validation&lt;FAIL, EitherUnsafe&lt;L, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<L, FAIL, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static Validation<FAIL, EitherUnsafe<L, A>> Sequence<L, FAIL, A>(this EitherUnsafe<L, Validation<FAIL, A>> ma) =>
            ma.Traverse<L, FAIL, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherUnsafe&lt;L, Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherUnsafe<L, Validation<FAIL, B>> MapT<L, FAIL, A, B>(this EitherUnsafe<L, Validation<FAIL, A>> ma, Func<A, B> f) =>
            Trans<MEitherUnsafe<L, Validation<FAIL, A>>, EitherUnsafe<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Map<MEitherUnsafe<L, Validation<FAIL, B>>, EitherUnsafe<L, Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, L, FAIL, A>(this EitherUnsafe<L, Validation<FAIL, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Validation<FAIL, A>>, EitherUnsafe<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, L, FAIL, A>(this EitherUnsafe<L, Validation<FAIL, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MEitherUnsafe<L, Validation<FAIL, A>>, EitherUnsafe<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<L, FAIL, A>(this EitherUnsafe<L, Validation<FAIL, A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Validation<FAIL, A>>, EitherUnsafe<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<L, FAIL, A>(this EitherUnsafe<L, Validation<FAIL, A>> ma, Func<A, bool> f) =>
            Trans<MEitherUnsafe<L, Validation<FAIL, A>>, EitherUnsafe<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherUnsafe&lt;L, Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<L, FAIL, A>(this EitherUnsafe<L, Validation<FAIL, A>> ma, Action<A> f) =>
            Trans<MEitherUnsafe<L, Validation<FAIL, A>>, EitherUnsafe<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherUnsafe&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherUnsafe&lt;L, Validation&lt;FAIL, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherUnsafe<L, Validation<FAIL, A>> FilterT<L, FAIL, A>(this EitherUnsafe<L, Validation<FAIL, A>> ma, Func<A, bool> pred) =>
            Trans<MEitherUnsafe<L, Validation<FAIL, A>>, EitherUnsafe<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MEitherUnsafe<L, Validation<FAIL, A>>, EitherUnsafe<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>(ma, 
                    a => pred(a)
                        ? default(MValidation<FAIL, A>).Return(a)
                        : default(MValidation<FAIL, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Validation&lt;FAIL, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static EitherUnsafe<L, Validation<FAIL, A>> PlusT<NUM, L, FAIL, A>(this EitherUnsafe<L, Validation<FAIL, A>> x, EitherUnsafe<L, Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Validation&lt;FAIL, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static EitherUnsafe<L, Validation<FAIL, A>> SubtractT<NUM, L, FAIL, A>(this EitherUnsafe<L, Validation<FAIL, A>> x, EitherUnsafe<L, Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherUnsafe<L, Validation<FAIL, A>> ProductT<NUM, L, FAIL, A>(this EitherUnsafe<L, Validation<FAIL, A>> x, EitherUnsafe<L, Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherUnsafe<L, Validation<FAIL, A>> DivideT<NUM, L, FAIL, A>(this EitherUnsafe<L, Validation<FAIL, A>> x, EitherUnsafe<L, Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherUnsafe<L, Validation<FAIL, A>> AppendT<SEMI, L, FAIL, A>(this EitherUnsafe<L, Validation<FAIL, A>> x, EitherUnsafe<L, Validation<FAIL, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, L, FAIL, A>(this EitherUnsafe<L, Validation<FAIL, A>> x, EitherUnsafe<L, Validation<FAIL, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherUnsafe&lt;L, Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, L, FAIL, A>(this EitherUnsafe<L, Validation<FAIL, A>> x, EitherUnsafe<L, Validation<FAIL, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe&lt;L, Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <returns>`EitherUnsafe&lt;L, Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherUnsafe<L, Validation<FAIL, B>> ApplyT<L, FAIL, A, B>(this Func<A, B> fab, EitherUnsafe<L, Validation<FAIL, A>> fa) =>
            ApplEitherUnsafe<L, Validation<FAIL, A>, Validation<FAIL, B>>.Inst.Apply(
                 MEitherUnsafe<L, Func<Validation<FAIL, A>, Validation<FAIL, B>>>.Inst.Return((Validation<FAIL, A> a) => ApplValidation<FAIL, A, B>.Inst.Apply(
                     MValidation<FAIL, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherUnsafe&lt;L, Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `EitherUnsafe&lt;L, Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <returns>`EitherUnsafe&lt;L, Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherUnsafe<L, Validation<FAIL, C>> ApplyT<L, FAIL, A, B, C>(this Func<A, B, C> fabc, EitherUnsafe<L, Validation<FAIL, A>> fa, EitherUnsafe<L, Validation<FAIL, B>> fb) =>
            ApplEitherUnsafe<L, Validation<FAIL, A>, Validation<FAIL, B>, Validation<FAIL, C>>.Inst.Apply(
                MEitherUnsafe<L, Func<Validation<FAIL, A>, Func<Validation<FAIL, B>, Validation<FAIL, C>>>>.Inst.Return(
                    (Validation<FAIL, A> a) =>
                        (Validation<FAIL, B> b) =>
                            ApplValidation<FAIL, A, B, C>.Inst.Apply(
                                MValidation<FAIL, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Try&lt;Validation&lt;FAIL, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Try<Validation<FAIL, C>> SelectMany<FAIL, A, B, C>(
            this Try<Validation<FAIL, A>> ma,
            Func<A, Try<Validation<FAIL, B>>> bind,
            Func<A, B, C> project) =>
            Trans<MTry<Validation<FAIL, A>>, Try<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MTry<Validation<FAIL, C>>, Try<Validation<FAIL, C>>, MValidation<FAIL, C>, Validation<FAIL, C>, C>(ma, a =>
                    Trans<MTry<Validation<FAIL, B>>, Try<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>
                        .Inst.Bind<MTry<Validation<FAIL, C>>, Try<Validation<FAIL, C>>, MValidation<FAIL, C>, Validation<FAIL, C>, C>(bind(a), b =>
                            default(MValidation<FAIL, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;Validation&lt;FAIL, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<Validation<FAIL, A>> Where<FAIL, A>(this Try<Validation<FAIL, A>> ma, Func<A, bool> pred) =>
            Trans<MTry<Validation<FAIL, A>>, Try<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MTry<Validation<FAIL, A>>, Try<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>(ma, 
                    a => pred(a)
                        ? default(MValidation<FAIL, A>).Return(a)
                        : default(MValidation<FAIL, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Validation<FAIL, B>> Select<FAIL, A, B>(this Try<Validation<FAIL, A>> ma, Func<A, B> f) =>
            Trans<MTry<Validation<FAIL, A>>, Try<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Map<MTry<Validation<FAIL, B>>, Try<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Try&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Try&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, FAIL, A>(this Try<Validation<FAIL, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTry<Validation<FAIL, A>>, Try<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Try&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Try&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<FAIL, A>(this Try<Validation<FAIL, A>> ma) =>
            Trans<MTry<Validation<FAIL, A>>, Try<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Validation<FAIL, B>> BindT<FAIL, A, B>(this Try<Validation<FAIL, A>> ma, Func<A, Validation<FAIL, B>> f) =>
            Trans<MTry<Validation<FAIL, A>>, Try<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MTry<Validation<FAIL, B>>, Try<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Try&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Validation<FAIL, B>> BindT<FAIL, A, B>(this Try<Validation<FAIL, A>> ma, Func<A, Try<Validation<FAIL, B>>> f) =>
            Trans<MTry<Validation<FAIL, A>>, Try<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MTry<Validation<FAIL, B>>, Try<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Try&lt;Validation&lt;FAIL, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Validation&lt;FAIL, Try&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, Try&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Validation<FAIL, Try<B>> Traverse<FAIL, A, B>(this Try<Validation<FAIL, A>> ma, Func<A, B> f) =>
            Trans<MTry<Validation<FAIL, A>>, Try<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Traverse<MValidation<FAIL, Try<B>>, Validation<FAIL, Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Try&lt;Validation&lt;FAIL, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Validation&lt;FAIL, Try&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<FAIL, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Validation<FAIL, Try<A>> Sequence<FAIL, A>(this Try<Validation<FAIL, A>> ma) =>
            ma.Traverse<FAIL, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Try&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Try<Validation<FAIL, B>> MapT<FAIL, A, B>(this Try<Validation<FAIL, A>> ma, Func<A, B> f) =>
            Trans<MTry<Validation<FAIL, A>>, Try<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Map<MTry<Validation<FAIL, B>>, Try<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, FAIL, A>(this Try<Validation<FAIL, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Validation<FAIL, A>>, Try<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Try&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, FAIL, A>(this Try<Validation<FAIL, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTry<Validation<FAIL, A>>, Try<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<FAIL, A>(this Try<Validation<FAIL, A>> ma, Func<A, bool> f) =>
            Trans<MTry<Validation<FAIL, A>>, Try<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<FAIL, A>(this Try<Validation<FAIL, A>> ma, Func<A, bool> f) =>
            Trans<MTry<Validation<FAIL, A>>, Try<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Try&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<FAIL, A>(this Try<Validation<FAIL, A>> ma, Action<A> f) =>
            Trans<MTry<Validation<FAIL, A>>, Try<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Try&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Try&lt;Validation&lt;FAIL, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Try<Validation<FAIL, A>> FilterT<FAIL, A>(this Try<Validation<FAIL, A>> ma, Func<A, bool> pred) =>
            Trans<MTry<Validation<FAIL, A>>, Try<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MTry<Validation<FAIL, A>>, Try<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>(ma, 
                    a => pred(a)
                        ? default(MValidation<FAIL, A>).Return(a)
                        : default(MValidation<FAIL, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Try<Validation<FAIL, A>> PlusT<NUM, FAIL, A>(this Try<Validation<FAIL, A>> x, Try<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Try<Validation<FAIL, A>> SubtractT<NUM, FAIL, A>(this Try<Validation<FAIL, A>> x, Try<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Try<Validation<FAIL, A>> ProductT<NUM, FAIL, A>(this Try<Validation<FAIL, A>> x, Try<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Try<Validation<FAIL, A>> DivideT<NUM, FAIL, A>(this Try<Validation<FAIL, A>> x, Try<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Try<Validation<FAIL, A>> AppendT<SEMI, FAIL, A>(this Try<Validation<FAIL, A>> x, Try<Validation<FAIL, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, FAIL, A>(this Try<Validation<FAIL, A>> x, Try<Validation<FAIL, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Try&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, FAIL, A>(this Try<Validation<FAIL, A>> x, Try<Validation<FAIL, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Try&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <returns>`Try&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Try<Validation<FAIL, B>> ApplyT<FAIL, A, B>(this Func<A, B> fab, Try<Validation<FAIL, A>> fa) =>
            ApplTry< Validation<FAIL, A>, Validation<FAIL, B>>.Inst.Apply(
                 MTry< Func<Validation<FAIL, A>, Validation<FAIL, B>>>.Inst.Return((Validation<FAIL, A> a) => ApplValidation<FAIL, A, B>.Inst.Apply(
                     MValidation<FAIL, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Try&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Try&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <returns>`Try&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Try<Validation<FAIL, C>> ApplyT<FAIL, A, B, C>(this Func<A, B, C> fabc, Try<Validation<FAIL, A>> fa, Try<Validation<FAIL, B>> fb) =>
            ApplTry< Validation<FAIL, A>, Validation<FAIL, B>, Validation<FAIL, C>>.Inst.Apply(
                MTry< Func<Validation<FAIL, A>, Func<Validation<FAIL, B>, Validation<FAIL, C>>>>.Inst.Return(
                    (Validation<FAIL, A> a) =>
                        (Validation<FAIL, B> b) =>
                            ApplValidation<FAIL, A, B, C>.Inst.Apply(
                                MValidation<FAIL, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOption&lt;Validation&lt;FAIL, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOption<Validation<FAIL, C>> SelectMany<FAIL, A, B, C>(
            this TryOption<Validation<FAIL, A>> ma,
            Func<A, TryOption<Validation<FAIL, B>>> bind,
            Func<A, B, C> project) =>
            Trans<MTryOption<Validation<FAIL, A>>, TryOption<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MTryOption<Validation<FAIL, C>>, TryOption<Validation<FAIL, C>>, MValidation<FAIL, C>, Validation<FAIL, C>, C>(ma, a =>
                    Trans<MTryOption<Validation<FAIL, B>>, TryOption<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>
                        .Inst.Bind<MTryOption<Validation<FAIL, C>>, TryOption<Validation<FAIL, C>>, MValidation<FAIL, C>, Validation<FAIL, C>, C>(bind(a), b =>
                            default(MValidation<FAIL, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;Validation&lt;FAIL, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<Validation<FAIL, A>> Where<FAIL, A>(this TryOption<Validation<FAIL, A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<Validation<FAIL, A>>, TryOption<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MTryOption<Validation<FAIL, A>>, TryOption<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>(ma, 
                    a => pred(a)
                        ? default(MValidation<FAIL, A>).Return(a)
                        : default(MValidation<FAIL, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Validation<FAIL, B>> Select<FAIL, A, B>(this TryOption<Validation<FAIL, A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Validation<FAIL, A>>, TryOption<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Map<MTryOption<Validation<FAIL, B>>, TryOption<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOption&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOption&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, FAIL, A>(this TryOption<Validation<FAIL, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MTryOption<Validation<FAIL, A>>, TryOption<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOption&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOption&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<FAIL, A>(this TryOption<Validation<FAIL, A>> ma) =>
            Trans<MTryOption<Validation<FAIL, A>>, TryOption<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Validation<FAIL, B>> BindT<FAIL, A, B>(this TryOption<Validation<FAIL, A>> ma, Func<A, Validation<FAIL, B>> f) =>
            Trans<MTryOption<Validation<FAIL, A>>, TryOption<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MTryOption<Validation<FAIL, B>>, TryOption<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOption&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Validation<FAIL, B>> BindT<FAIL, A, B>(this TryOption<Validation<FAIL, A>> ma, Func<A, TryOption<Validation<FAIL, B>>> f) =>
            Trans<MTryOption<Validation<FAIL, A>>, TryOption<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MTryOption<Validation<FAIL, B>>, TryOption<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `TryOption&lt;Validation&lt;FAIL, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Validation&lt;FAIL, TryOption&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, TryOption&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Validation<FAIL, TryOption<B>> Traverse<FAIL, A, B>(this TryOption<Validation<FAIL, A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Validation<FAIL, A>>, TryOption<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Traverse<MValidation<FAIL, TryOption<B>>, Validation<FAIL, TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `TryOption&lt;Validation&lt;FAIL, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Validation&lt;FAIL, TryOption&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<FAIL, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Validation<FAIL, TryOption<A>> Sequence<FAIL, A>(this TryOption<Validation<FAIL, A>> ma) =>
            ma.Traverse<FAIL, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOption&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOption<Validation<FAIL, B>> MapT<FAIL, A, B>(this TryOption<Validation<FAIL, A>> ma, Func<A, B> f) =>
            Trans<MTryOption<Validation<FAIL, A>>, TryOption<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Map<MTryOption<Validation<FAIL, B>>, TryOption<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, FAIL, A>(this TryOption<Validation<FAIL, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Validation<FAIL, A>>, TryOption<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOption&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, FAIL, A>(this TryOption<Validation<FAIL, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MTryOption<Validation<FAIL, A>>, TryOption<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<FAIL, A>(this TryOption<Validation<FAIL, A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Validation<FAIL, A>>, TryOption<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<FAIL, A>(this TryOption<Validation<FAIL, A>> ma, Func<A, bool> f) =>
            Trans<MTryOption<Validation<FAIL, A>>, TryOption<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOption&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<FAIL, A>(this TryOption<Validation<FAIL, A>> ma, Action<A> f) =>
            Trans<MTryOption<Validation<FAIL, A>>, TryOption<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOption&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOption&lt;Validation&lt;FAIL, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOption<Validation<FAIL, A>> FilterT<FAIL, A>(this TryOption<Validation<FAIL, A>> ma, Func<A, bool> pred) =>
            Trans<MTryOption<Validation<FAIL, A>>, TryOption<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MTryOption<Validation<FAIL, A>>, TryOption<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>(ma, 
                    a => pred(a)
                        ? default(MValidation<FAIL, A>).Return(a)
                        : default(MValidation<FAIL, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryOption<Validation<FAIL, A>> PlusT<NUM, FAIL, A>(this TryOption<Validation<FAIL, A>> x, TryOption<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryOption<Validation<FAIL, A>> SubtractT<NUM, FAIL, A>(this TryOption<Validation<FAIL, A>> x, TryOption<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOption<Validation<FAIL, A>> ProductT<NUM, FAIL, A>(this TryOption<Validation<FAIL, A>> x, TryOption<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOption<Validation<FAIL, A>> DivideT<NUM, FAIL, A>(this TryOption<Validation<FAIL, A>> x, TryOption<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOption<Validation<FAIL, A>> AppendT<SEMI, FAIL, A>(this TryOption<Validation<FAIL, A>> x, TryOption<Validation<FAIL, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, FAIL, A>(this TryOption<Validation<FAIL, A>> x, TryOption<Validation<FAIL, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOption&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, FAIL, A>(this TryOption<Validation<FAIL, A>> x, TryOption<Validation<FAIL, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOption&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <returns>`TryOption&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOption<Validation<FAIL, B>> ApplyT<FAIL, A, B>(this Func<A, B> fab, TryOption<Validation<FAIL, A>> fa) =>
            ApplTryOption< Validation<FAIL, A>, Validation<FAIL, B>>.Inst.Apply(
                 MTryOption< Func<Validation<FAIL, A>, Validation<FAIL, B>>>.Inst.Return((Validation<FAIL, A> a) => ApplValidation<FAIL, A, B>.Inst.Apply(
                     MValidation<FAIL, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOption&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryOption&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <returns>`TryOption&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOption<Validation<FAIL, C>> ApplyT<FAIL, A, B, C>(this Func<A, B, C> fabc, TryOption<Validation<FAIL, A>> fa, TryOption<Validation<FAIL, B>> fb) =>
            ApplTryOption< Validation<FAIL, A>, Validation<FAIL, B>, Validation<FAIL, C>>.Inst.Apply(
                MTryOption< Func<Validation<FAIL, A>, Func<Validation<FAIL, B>, Validation<FAIL, C>>>>.Inst.Return(
                    (Validation<FAIL, A> a) =>
                        (Validation<FAIL, B> b) =>
                            ApplValidation<FAIL, A, B, C>.Inst.Apply(
                                MValidation<FAIL, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`IEnumerable&lt;Validation&lt;FAIL, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static IEnumerable<Validation<FAIL, C>> SelectMany<FAIL, A, B, C>(
            this IEnumerable<Validation<FAIL, A>> ma,
            Func<A, IEnumerable<Validation<FAIL, B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MEnumerable<Validation<FAIL, A>>, IEnumerable<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MEnumerable<Validation<FAIL, C>>, IEnumerable<Validation<FAIL, C>>, MValidation<FAIL, C>, Validation<FAIL, C>, C>(ma, a =>
                    SeqTrans<MEnumerable<Validation<FAIL, B>>, IEnumerable<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>
                        .Inst.Bind<MEnumerable<Validation<FAIL, C>>, IEnumerable<Validation<FAIL, C>>, MValidation<FAIL, C>, Validation<FAIL, C>, C>(bind(a), b =>
                            default(MValidation<FAIL, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;Validation&lt;FAIL, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<Validation<FAIL, A>> Where<FAIL, A>(this IEnumerable<Validation<FAIL, A>> ma, Func<A, bool> pred) =>
            SeqTrans<MEnumerable<Validation<FAIL, A>>, IEnumerable<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MEnumerable<Validation<FAIL, A>>, IEnumerable<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>(ma, 
                    a => pred(a)
                        ? default(MValidation<FAIL, A>).Return(a)
                        : default(MValidation<FAIL, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Validation<FAIL, B>> Select<FAIL, A, B>(this IEnumerable<Validation<FAIL, A>> ma, Func<A, B> f) =>
            SeqTrans<MEnumerable<Validation<FAIL, A>>, IEnumerable<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Map<MEnumerable<Validation<FAIL, B>>, IEnumerable<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `IEnumerable&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `IEnumerable&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, FAIL, A>(this IEnumerable<Validation<FAIL, A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MEnumerable<Validation<FAIL, A>>, IEnumerable<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `IEnumerable&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `IEnumerable&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<FAIL, A>(this IEnumerable<Validation<FAIL, A>> ma) =>
            SeqTrans<MEnumerable<Validation<FAIL, A>>, IEnumerable<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Validation<FAIL, B>> BindT<FAIL, A, B>(this IEnumerable<Validation<FAIL, A>> ma, Func<A, Validation<FAIL, B>> f) =>
            SeqTrans<MEnumerable<Validation<FAIL, A>>, IEnumerable<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MEnumerable<Validation<FAIL, B>>, IEnumerable<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`IEnumerable&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Validation<FAIL, B>> BindT<FAIL, A, B>(this IEnumerable<Validation<FAIL, A>> ma, Func<A, IEnumerable<Validation<FAIL, B>>> f) =>
            SeqTrans<MEnumerable<Validation<FAIL, A>>, IEnumerable<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MEnumerable<Validation<FAIL, B>>, IEnumerable<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `IEnumerable&lt;Validation&lt;FAIL, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Validation&lt;FAIL, IEnumerable&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, IEnumerable&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Validation<FAIL, IEnumerable<B>> Traverse<FAIL, A, B>(this IEnumerable<Validation<FAIL, A>> ma, Func<A, B> f) =>
            Trans<MEnumerable<Validation<FAIL, A>>, IEnumerable<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Traverse<MValidation<FAIL, IEnumerable<B>>, Validation<FAIL, IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `IEnumerable&lt;Validation&lt;FAIL, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Validation&lt;FAIL, IEnumerable&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<FAIL, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Validation<FAIL, IEnumerable<A>> Sequence<FAIL, A>(this IEnumerable<Validation<FAIL, A>> ma) =>
            ma.Traverse<FAIL, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`IEnumerable&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static IEnumerable<Validation<FAIL, B>> MapT<FAIL, A, B>(this IEnumerable<Validation<FAIL, A>> ma, Func<A, B> f) =>
            SeqTrans<MEnumerable<Validation<FAIL, A>>, IEnumerable<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Map<MEnumerable<Validation<FAIL, B>>, IEnumerable<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, FAIL, A>(this IEnumerable<Validation<FAIL, A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MEnumerable<Validation<FAIL, A>>, IEnumerable<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, FAIL, A>(this IEnumerable<Validation<FAIL, A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MEnumerable<Validation<FAIL, A>>, IEnumerable<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<FAIL, A>(this IEnumerable<Validation<FAIL, A>> ma, Func<A, bool> f) =>
            SeqTrans<MEnumerable<Validation<FAIL, A>>, IEnumerable<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<FAIL, A>(this IEnumerable<Validation<FAIL, A>> ma, Func<A, bool> f) =>
            SeqTrans<MEnumerable<Validation<FAIL, A>>, IEnumerable<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `IEnumerable&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<FAIL, A>(this IEnumerable<Validation<FAIL, A>> ma, Action<A> f) =>
            SeqTrans<MEnumerable<Validation<FAIL, A>>, IEnumerable<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `IEnumerable&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`IEnumerable&lt;Validation&lt;FAIL, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static IEnumerable<Validation<FAIL, A>> FilterT<FAIL, A>(this IEnumerable<Validation<FAIL, A>> ma, Func<A, bool> pred) =>
            SeqTrans<MEnumerable<Validation<FAIL, A>>, IEnumerable<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MEnumerable<Validation<FAIL, A>>, IEnumerable<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>(ma, 
                    a => pred(a)
                        ? default(MValidation<FAIL, A>).Return(a)
                        : default(MValidation<FAIL, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static IEnumerable<Validation<FAIL, A>> PlusT<NUM, FAIL, A>(this IEnumerable<Validation<FAIL, A>> x, IEnumerable<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static IEnumerable<Validation<FAIL, A>> SubtractT<NUM, FAIL, A>(this IEnumerable<Validation<FAIL, A>> x, IEnumerable<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static IEnumerable<Validation<FAIL, A>> ProductT<NUM, FAIL, A>(this IEnumerable<Validation<FAIL, A>> x, IEnumerable<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static IEnumerable<Validation<FAIL, A>> DivideT<NUM, FAIL, A>(this IEnumerable<Validation<FAIL, A>> x, IEnumerable<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static IEnumerable<Validation<FAIL, A>> AppendT<SEMI, FAIL, A>(this IEnumerable<Validation<FAIL, A>> x, IEnumerable<Validation<FAIL, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, FAIL, A>(this IEnumerable<Validation<FAIL, A>> x, IEnumerable<Validation<FAIL, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`IEnumerable&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, FAIL, A>(this IEnumerable<Validation<FAIL, A>> x, IEnumerable<Validation<FAIL, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `IEnumerable&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <returns>`IEnumerable&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static IEnumerable<Validation<FAIL, B>> ApplyT<FAIL, A, B>(this Func<A, B> fab, IEnumerable<Validation<FAIL, A>> fa) =>
            ApplEnumerable< Validation<FAIL, A>, Validation<FAIL, B>>.Inst.Apply(
                 MEnumerable< Func<Validation<FAIL, A>, Validation<FAIL, B>>>.Inst.Return((Validation<FAIL, A> a) => ApplValidation<FAIL, A, B>.Inst.Apply(
                     MValidation<FAIL, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `IEnumerable&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `IEnumerable&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <returns>`IEnumerable&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static IEnumerable<Validation<FAIL, C>> ApplyT<FAIL, A, B, C>(this Func<A, B, C> fabc, IEnumerable<Validation<FAIL, A>> fa, IEnumerable<Validation<FAIL, B>> fb) =>
            ApplEnumerable< Validation<FAIL, A>, Validation<FAIL, B>, Validation<FAIL, C>>.Inst.Apply(
                MEnumerable< Func<Validation<FAIL, A>, Func<Validation<FAIL, B>, Validation<FAIL, C>>>>.Inst.Return(
                    (Validation<FAIL, A> a) =>
                        (Validation<FAIL, B> b) =>
                            ApplValidation<FAIL, A, B, C>.Inst.Apply(
                                MValidation<FAIL, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Seq&lt;Validation&lt;FAIL, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Seq<Validation<FAIL, C>> SelectMany<FAIL, A, B, C>(
            this Seq<Validation<FAIL, A>> ma,
            Func<A, Seq<Validation<FAIL, B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MSeq<Validation<FAIL, A>>, Seq<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MSeq<Validation<FAIL, C>>, Seq<Validation<FAIL, C>>, MValidation<FAIL, C>, Validation<FAIL, C>, C>(ma, a =>
                    SeqTrans<MSeq<Validation<FAIL, B>>, Seq<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>
                        .Inst.Bind<MSeq<Validation<FAIL, C>>, Seq<Validation<FAIL, C>>, MValidation<FAIL, C>, Validation<FAIL, C>, C>(bind(a), b =>
                            default(MValidation<FAIL, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;Validation&lt;FAIL, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<Validation<FAIL, A>> Where<FAIL, A>(this Seq<Validation<FAIL, A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSeq<Validation<FAIL, A>>, Seq<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MSeq<Validation<FAIL, A>>, Seq<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>(ma, 
                    a => pred(a)
                        ? default(MValidation<FAIL, A>).Return(a)
                        : default(MValidation<FAIL, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<Validation<FAIL, B>> Select<FAIL, A, B>(this Seq<Validation<FAIL, A>> ma, Func<A, B> f) =>
            SeqTrans<MSeq<Validation<FAIL, A>>, Seq<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Map<MSeq<Validation<FAIL, B>>, Seq<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Seq&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Seq&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, FAIL, A>(this Seq<Validation<FAIL, A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MSeq<Validation<FAIL, A>>, Seq<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Seq&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Seq&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<FAIL, A>(this Seq<Validation<FAIL, A>> ma) =>
            SeqTrans<MSeq<Validation<FAIL, A>>, Seq<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Seq&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<Validation<FAIL, B>> BindT<FAIL, A, B>(this Seq<Validation<FAIL, A>> ma, Func<A, Validation<FAIL, B>> f) =>
            SeqTrans<MSeq<Validation<FAIL, A>>, Seq<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MSeq<Validation<FAIL, B>>, Seq<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Seq&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<Validation<FAIL, B>> BindT<FAIL, A, B>(this Seq<Validation<FAIL, A>> ma, Func<A, Seq<Validation<FAIL, B>>> f) =>
            SeqTrans<MSeq<Validation<FAIL, A>>, Seq<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MSeq<Validation<FAIL, B>>, Seq<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Seq&lt;Validation&lt;FAIL, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Validation&lt;FAIL, Seq&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, Seq&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Validation<FAIL, Seq<B>> Traverse<FAIL, A, B>(this Seq<Validation<FAIL, A>> ma, Func<A, B> f) =>
            Trans<MSeq<Validation<FAIL, A>>, Seq<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Traverse<MValidation<FAIL, Seq<B>>, Validation<FAIL, Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Seq&lt;Validation&lt;FAIL, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Validation&lt;FAIL, Seq&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<FAIL, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Validation<FAIL, Seq<A>> Sequence<FAIL, A>(this Seq<Validation<FAIL, A>> ma) =>
            ma.Traverse<FAIL, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Seq&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Seq<Validation<FAIL, B>> MapT<FAIL, A, B>(this Seq<Validation<FAIL, A>> ma, Func<A, B> f) =>
            SeqTrans<MSeq<Validation<FAIL, A>>, Seq<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Map<MSeq<Validation<FAIL, B>>, Seq<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, FAIL, A>(this Seq<Validation<FAIL, A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSeq<Validation<FAIL, A>>, Seq<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Seq&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, FAIL, A>(this Seq<Validation<FAIL, A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSeq<Validation<FAIL, A>>, Seq<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<FAIL, A>(this Seq<Validation<FAIL, A>> ma, Func<A, bool> f) =>
            SeqTrans<MSeq<Validation<FAIL, A>>, Seq<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<FAIL, A>(this Seq<Validation<FAIL, A>> ma, Func<A, bool> f) =>
            SeqTrans<MSeq<Validation<FAIL, A>>, Seq<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Seq&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<FAIL, A>(this Seq<Validation<FAIL, A>> ma, Action<A> f) =>
            SeqTrans<MSeq<Validation<FAIL, A>>, Seq<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Seq&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Seq&lt;Validation&lt;FAIL, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Seq<Validation<FAIL, A>> FilterT<FAIL, A>(this Seq<Validation<FAIL, A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSeq<Validation<FAIL, A>>, Seq<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MSeq<Validation<FAIL, A>>, Seq<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>(ma, 
                    a => pred(a)
                        ? default(MValidation<FAIL, A>).Return(a)
                        : default(MValidation<FAIL, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Seq<Validation<FAIL, A>> PlusT<NUM, FAIL, A>(this Seq<Validation<FAIL, A>> x, Seq<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Seq<Validation<FAIL, A>> SubtractT<NUM, FAIL, A>(this Seq<Validation<FAIL, A>> x, Seq<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Seq<Validation<FAIL, A>> ProductT<NUM, FAIL, A>(this Seq<Validation<FAIL, A>> x, Seq<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Seq<Validation<FAIL, A>> DivideT<NUM, FAIL, A>(this Seq<Validation<FAIL, A>> x, Seq<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Seq<Validation<FAIL, A>> AppendT<SEMI, FAIL, A>(this Seq<Validation<FAIL, A>> x, Seq<Validation<FAIL, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, FAIL, A>(this Seq<Validation<FAIL, A>> x, Seq<Validation<FAIL, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Seq&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, FAIL, A>(this Seq<Validation<FAIL, A>> x, Seq<Validation<FAIL, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Seq&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <returns>`Seq&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Seq<Validation<FAIL, B>> ApplyT<FAIL, A, B>(this Func<A, B> fab, Seq<Validation<FAIL, A>> fa) =>
            ApplSeq< Validation<FAIL, A>, Validation<FAIL, B>>.Inst.Apply(
                 MSeq< Func<Validation<FAIL, A>, Validation<FAIL, B>>>.Inst.Return((Validation<FAIL, A> a) => ApplValidation<FAIL, A, B>.Inst.Apply(
                     MValidation<FAIL, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Seq&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Seq&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <returns>`Seq&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Seq<Validation<FAIL, C>> ApplyT<FAIL, A, B, C>(this Func<A, B, C> fabc, Seq<Validation<FAIL, A>> fa, Seq<Validation<FAIL, B>> fb) =>
            ApplSeq< Validation<FAIL, A>, Validation<FAIL, B>, Validation<FAIL, C>>.Inst.Apply(
                MSeq< Func<Validation<FAIL, A>, Func<Validation<FAIL, B>, Validation<FAIL, C>>>>.Inst.Return(
                    (Validation<FAIL, A> a) =>
                        (Validation<FAIL, B> b) =>
                            ApplValidation<FAIL, A, B, C>.Inst.Apply(
                                MValidation<FAIL, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Set&lt;Validation&lt;FAIL, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Set<Validation<FAIL, C>> SelectMany<FAIL, A, B, C>(
            this Set<Validation<FAIL, A>> ma,
            Func<A, Set<Validation<FAIL, B>>> bind,
            Func<A, B, C> project) =>
            SeqTrans<MSet<Validation<FAIL, A>>, Set<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MSet<Validation<FAIL, C>>, Set<Validation<FAIL, C>>, MValidation<FAIL, C>, Validation<FAIL, C>, C>(ma, a =>
                    SeqTrans<MSet<Validation<FAIL, B>>, Set<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>
                        .Inst.Bind<MSet<Validation<FAIL, C>>, Set<Validation<FAIL, C>>, MValidation<FAIL, C>, Validation<FAIL, C>, C>(bind(a), b =>
                            default(MValidation<FAIL, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;Validation&lt;FAIL, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<Validation<FAIL, A>> Where<FAIL, A>(this Set<Validation<FAIL, A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSet<Validation<FAIL, A>>, Set<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MSet<Validation<FAIL, A>>, Set<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>(ma, 
                    a => pred(a)
                        ? default(MValidation<FAIL, A>).Return(a)
                        : default(MValidation<FAIL, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Validation<FAIL, B>> Select<FAIL, A, B>(this Set<Validation<FAIL, A>> ma, Func<A, B> f) =>
            SeqTrans<MSet<Validation<FAIL, A>>, Set<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Map<MSet<Validation<FAIL, B>>, Set<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Set&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Set&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, FAIL, A>(this Set<Validation<FAIL, A>> ma)
            where NumA : struct, Num<A> =>
                SeqTrans<MSet<Validation<FAIL, A>>, Set<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Set&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Set&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<FAIL, A>(this Set<Validation<FAIL, A>> ma) =>
            SeqTrans<MSet<Validation<FAIL, A>>, Set<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Validation<FAIL, B>> BindT<FAIL, A, B>(this Set<Validation<FAIL, A>> ma, Func<A, Validation<FAIL, B>> f) =>
            SeqTrans<MSet<Validation<FAIL, A>>, Set<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MSet<Validation<FAIL, B>>, Set<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Set&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Validation<FAIL, B>> BindT<FAIL, A, B>(this Set<Validation<FAIL, A>> ma, Func<A, Set<Validation<FAIL, B>>> f) =>
            SeqTrans<MSet<Validation<FAIL, A>>, Set<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MSet<Validation<FAIL, B>>, Set<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Set&lt;Validation&lt;FAIL, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Validation&lt;FAIL, Set&lt;B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, Set&lt;B&gt;&gt;`</returns>
        [Pure]
        public static Validation<FAIL, Set<B>> Traverse<FAIL, A, B>(this Set<Validation<FAIL, A>> ma, Func<A, B> f) =>
            Trans<MSet<Validation<FAIL, A>>, Set<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Traverse<MValidation<FAIL, Set<B>>, Validation<FAIL, Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Set&lt;Validation&lt;FAIL, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Validation&lt;FAIL, Set&lt;A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<FAIL, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Validation<FAIL, Set<A>> Sequence<FAIL, A>(this Set<Validation<FAIL, A>> ma) =>
            ma.Traverse<FAIL, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Set&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Set<Validation<FAIL, B>> MapT<FAIL, A, B>(this Set<Validation<FAIL, A>> ma, Func<A, B> f) =>
            SeqTrans<MSet<Validation<FAIL, A>>, Set<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Map<MSet<Validation<FAIL, B>>, Set<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, FAIL, A>(this Set<Validation<FAIL, A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSet<Validation<FAIL, A>>, Set<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Set&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, FAIL, A>(this Set<Validation<FAIL, A>> ma, S state, Func<S, A, S> f) =>
            SeqTrans<MSet<Validation<FAIL, A>>, Set<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<FAIL, A>(this Set<Validation<FAIL, A>> ma, Func<A, bool> f) =>
            SeqTrans<MSet<Validation<FAIL, A>>, Set<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<FAIL, A>(this Set<Validation<FAIL, A>> ma, Func<A, bool> f) =>
            SeqTrans<MSet<Validation<FAIL, A>>, Set<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Set&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<FAIL, A>(this Set<Validation<FAIL, A>> ma, Action<A> f) =>
            SeqTrans<MSet<Validation<FAIL, A>>, Set<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Set&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Set&lt;Validation&lt;FAIL, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Set<Validation<FAIL, A>> FilterT<FAIL, A>(this Set<Validation<FAIL, A>> ma, Func<A, bool> pred) =>
            SeqTrans<MSet<Validation<FAIL, A>>, Set<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MSet<Validation<FAIL, A>>, Set<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>(ma, 
                    a => pred(a)
                        ? default(MValidation<FAIL, A>).Return(a)
                        : default(MValidation<FAIL, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Set<Validation<FAIL, A>> PlusT<NUM, FAIL, A>(this Set<Validation<FAIL, A>> x, Set<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Set<Validation<FAIL, A>> SubtractT<NUM, FAIL, A>(this Set<Validation<FAIL, A>> x, Set<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Set<Validation<FAIL, A>> ProductT<NUM, FAIL, A>(this Set<Validation<FAIL, A>> x, Set<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Set<Validation<FAIL, A>> DivideT<NUM, FAIL, A>(this Set<Validation<FAIL, A>> x, Set<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Set<Validation<FAIL, A>> AppendT<SEMI, FAIL, A>(this Set<Validation<FAIL, A>> x, Set<Validation<FAIL, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, FAIL, A>(this Set<Validation<FAIL, A>> x, Set<Validation<FAIL, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Set&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, FAIL, A>(this Set<Validation<FAIL, A>> x, Set<Validation<FAIL, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Set&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <returns>`Set&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Set<Validation<FAIL, B>> ApplyT<FAIL, A, B>(this Func<A, B> fab, Set<Validation<FAIL, A>> fa) =>
            ApplSet< Validation<FAIL, A>, Validation<FAIL, B>>.Inst.Apply(
                 MSet< Func<Validation<FAIL, A>, Validation<FAIL, B>>>.Inst.Return((Validation<FAIL, A> a) => ApplValidation<FAIL, A, B>.Inst.Apply(
                     MValidation<FAIL, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Set&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Set&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <returns>`Set&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Set<Validation<FAIL, C>> ApplyT<FAIL, A, B, C>(this Func<A, B, C> fabc, Set<Validation<FAIL, A>> fa, Set<Validation<FAIL, B>> fb) =>
            ApplSet< Validation<FAIL, A>, Validation<FAIL, B>, Validation<FAIL, C>>.Inst.Apply(
                MSet< Func<Validation<FAIL, A>, Func<Validation<FAIL, B>, Validation<FAIL, C>>>>.Inst.Return(
                    (Validation<FAIL, A> a) =>
                        (Validation<FAIL, B> b) =>
                            ApplValidation<FAIL, A, B, C>.Inst.Apply(
                                MValidation<FAIL, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Validation&lt;FAIL, Validation&lt;FAIL, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Validation<FAIL, Validation<FAIL, C>> SelectMany<FAIL, A, B, C>(
            this Validation<FAIL, Validation<FAIL, A>> ma,
            Func<A, Validation<FAIL, Validation<FAIL, B>>> bind,
            Func<A, B, C> project) =>
            Trans<MValidation<FAIL, Validation<FAIL, A>>, Validation<FAIL, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MValidation<FAIL, Validation<FAIL, C>>, Validation<FAIL, Validation<FAIL, C>>, MValidation<FAIL, C>, Validation<FAIL, C>, C>(ma, a =>
                    Trans<MValidation<FAIL, Validation<FAIL, B>>, Validation<FAIL, Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>
                        .Inst.Bind<MValidation<FAIL, Validation<FAIL, C>>, Validation<FAIL, Validation<FAIL, C>>, MValidation<FAIL, C>, Validation<FAIL, C>, C>(bind(a), b =>
                            default(MValidation<FAIL, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, Validation&lt;FAIL, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, Validation<FAIL, A>> Where<FAIL, A>(this Validation<FAIL, Validation<FAIL, A>> ma, Func<A, bool> pred) =>
            Trans<MValidation<FAIL, Validation<FAIL, A>>, Validation<FAIL, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MValidation<FAIL, Validation<FAIL, A>>, Validation<FAIL, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>(ma, 
                    a => pred(a)
                        ? default(MValidation<FAIL, A>).Return(a)
                        : default(MValidation<FAIL, A>).Zero());

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, Validation<FAIL, B>> Select<FAIL, A, B>(this Validation<FAIL, Validation<FAIL, A>> ma, Func<A, B> f) =>
            Trans<MValidation<FAIL, Validation<FAIL, A>>, Validation<FAIL, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Map<MValidation<FAIL, Validation<FAIL, B>>, Validation<FAIL, Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);
        /// <summary>
        /// Finds total of all the `Num<A>`s in `Validation&lt;FAIL, Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Validation&lt;FAIL, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Validation&lt;FAIL, Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static A SumT<NumA, FAIL, A>(this Validation<FAIL, Validation<FAIL, A>> ma)
            where NumA : struct, Num<A> =>
                Trans<MValidation<FAIL, Validation<FAIL, A>>, Validation<FAIL, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, NumA, A>.Inst.Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Validation&lt;FAIL, Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Validation&lt;FAIL, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Validation&lt;FAIL, Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static int CountT<FAIL, A>(this Validation<FAIL, Validation<FAIL, A>> ma) =>
            Trans<MValidation<FAIL, Validation<FAIL, A>>, Validation<FAIL, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>.Inst.Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Validation&lt;FAIL, Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, Validation<FAIL, B>> BindT<FAIL, A, B>(this Validation<FAIL, Validation<FAIL, A>> ma, Func<A, Validation<FAIL, B>> f) =>
            Trans<MValidation<FAIL, Validation<FAIL, A>>, Validation<FAIL, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MValidation<FAIL, Validation<FAIL, B>>, Validation<FAIL, Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Validation&lt;FAIL, Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, Validation<FAIL, B>> BindT<FAIL, A, B>(this Validation<FAIL, Validation<FAIL, A>> ma, Func<A, Validation<FAIL, Validation<FAIL, B>>> f) =>
            Trans<MValidation<FAIL, Validation<FAIL, A>>, Validation<FAIL, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MValidation<FAIL, Validation<FAIL, B>>, Validation<FAIL, Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Traverse operation.  Takes a value of type `Validation&lt;FAIL, Validation&lt;FAIL, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Validation&lt;FAIL, Validation&lt;FAIL, B&gt;&gt;` (by applying `a` to `f`).  So 
        /// it 'flips' the types whilst maintaining the rules of the inner and outer 
        /// types.  
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, Validation&lt;FAIL, B&gt;&gt;`</returns>
        [Pure]
        public static Validation<FAIL, Validation<FAIL, B>> Traverse<FAIL, A, B>(this Validation<FAIL, Validation<FAIL, A>> ma, Func<A, B> f) =>
            Trans<MValidation<FAIL, Validation<FAIL, A>>, Validation<FAIL, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Traverse<MValidation<FAIL, Validation<FAIL, B>>, Validation<FAIL, Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Sequence operation.  Takes a value of type `Validation&lt;FAIL, Validation&lt;FAIL, A&gt;&gt;`, traverses the inner
        /// values of type `A`, and returns `Validation&lt;FAIL, Validation&lt;FAIL, A&gt;&gt;`.  So it 'flips' the types
        /// whilst maintaining the rules of the inner and outer types.  This is the
        /// same as calling `ma.Traverse<FAIL, A, A>(identity)`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static Validation<FAIL, Validation<FAIL, A>> Sequence<FAIL, A>(this Validation<FAIL, Validation<FAIL, A>> ma) =>
            ma.Traverse<FAIL, A, A>(identity);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Validation&lt;FAIL, Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Validation<FAIL, Validation<FAIL, B>> MapT<FAIL, A, B>(this Validation<FAIL, Validation<FAIL, A>> ma, Func<A, B> f) =>
            Trans<MValidation<FAIL, Validation<FAIL, A>>, Validation<FAIL, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Map<MValidation<FAIL, Validation<FAIL, B>>, Validation<FAIL, Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldT<S, FAIL, A>(this Validation<FAIL, Validation<FAIL, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MValidation<FAIL, Validation<FAIL, A>>, Validation<FAIL, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static S FoldBackT<S, FAIL, A>(this Validation<FAIL, Validation<FAIL, A>> ma, S state, Func<S, A, S> f) =>
            Trans<MValidation<FAIL, Validation<FAIL, A>>, Validation<FAIL, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static bool ExistsT<FAIL, A>(this Validation<FAIL, Validation<FAIL, A>> ma, Func<A, bool> f) =>
            Trans<MValidation<FAIL, Validation<FAIL, A>>, Validation<FAIL, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static bool ForAllT<FAIL, A>(this Validation<FAIL, Validation<FAIL, A>> ma, Func<A, bool> f) =>
            Trans<MValidation<FAIL, Validation<FAIL, A>>, Validation<FAIL, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Validation&lt;FAIL, Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Unit IterT<FAIL, A>(this Validation<FAIL, Validation<FAIL, A>> ma, Action<A> f) =>
            Trans<MValidation<FAIL, Validation<FAIL, A>>, Validation<FAIL, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Validation&lt;FAIL, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Validation&lt;FAIL, Validation&lt;FAIL, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Validation<FAIL, Validation<FAIL, A>> FilterT<FAIL, A>(this Validation<FAIL, Validation<FAIL, A>> ma, Func<A, bool> pred) =>
            Trans<MValidation<FAIL, Validation<FAIL, A>>, Validation<FAIL, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>
                .Inst.Bind<MValidation<FAIL, Validation<FAIL, A>>, Validation<FAIL, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>(ma, 
                    a => pred(a)
                        ? default(MValidation<FAIL, A>).Return(a)
                        : default(MValidation<FAIL, A>).Zero());

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Validation&lt;FAIL, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Validation<FAIL, Validation<FAIL, A>> PlusT<NUM, FAIL, A>(this Validation<FAIL, Validation<FAIL, A>> x, Validation<FAIL, Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Validation&lt;FAIL, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Validation<FAIL, Validation<FAIL, A>> SubtractT<NUM, FAIL, A>(this Validation<FAIL, Validation<FAIL, A>> x, Validation<FAIL, Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Validation<FAIL, Validation<FAIL, A>> ProductT<NUM, FAIL, A>(this Validation<FAIL, Validation<FAIL, A>> x, Validation<FAIL, Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Validation<FAIL, Validation<FAIL, A>> DivideT<NUM, FAIL, A>(this Validation<FAIL, Validation<FAIL, A>> x, Validation<FAIL, Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Validation<FAIL, Validation<FAIL, A>> AppendT<SEMI, FAIL, A>(this Validation<FAIL, Validation<FAIL, A>> x, Validation<FAIL, Validation<FAIL, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static int CompareT<ORD, FAIL, A>(this Validation<FAIL, Validation<FAIL, A>> x, Validation<FAIL, Validation<FAIL, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Validation&lt;FAIL, Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static bool EqualsT<EQ, FAIL, A>(this Validation<FAIL, Validation<FAIL, A>> x, Validation<FAIL, Validation<FAIL, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Validation&lt;FAIL, Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <returns>`Validation&lt;FAIL, Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Validation<FAIL, Validation<FAIL, B>> ApplyT<FAIL, A, B>(this Func<A, B> fab, Validation<FAIL, Validation<FAIL, A>> fa) =>
            ApplValidation<FAIL, Validation<FAIL, A>, Validation<FAIL, B>>.Inst.Apply(
                 MValidation<FAIL, Func<Validation<FAIL, A>, Validation<FAIL, B>>>.Inst.Return((Validation<FAIL, A> a) => ApplValidation<FAIL, A, B>.Inst.Apply(
                     MValidation<FAIL, Func<A, B>>.Inst.Return(fab), 
                     a)),
                 fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Validation&lt;FAIL, Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Validation&lt;FAIL, Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <returns>`Validation&lt;FAIL, Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Validation<FAIL, Validation<FAIL, C>> ApplyT<FAIL, A, B, C>(this Func<A, B, C> fabc, Validation<FAIL, Validation<FAIL, A>> fa, Validation<FAIL, Validation<FAIL, B>> fb) =>
            ApplValidation<FAIL, Validation<FAIL, A>, Validation<FAIL, B>, Validation<FAIL, C>>.Inst.Apply(
                MValidation<FAIL, Func<Validation<FAIL, A>, Func<Validation<FAIL, B>, Validation<FAIL, C>>>>.Inst.Return(
                    (Validation<FAIL, A> a) =>
                        (Validation<FAIL, B> b) =>
                            ApplValidation<FAIL, A, B, C>.Inst.Apply(
                                MValidation<FAIL, Func<A, Func<B, C>>>.Inst.Return(curry(fabc)), a, b)), fa, fb);

    }
}
