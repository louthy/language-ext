<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<# 

    var noArgs = new string[0];

    var types = new [] {
        T("SeqTrans", "Arr"),
        T("SeqTrans", "HashSet"),
        T("SeqTrans", "Lst"),
        T("Trans", "Option"),
        T("Trans", "OptionUnsafe"),
        T("Trans", "Either", "L"),
        T("Trans", "EitherUnsafe", "L"),
        T("Trans", "Try"),
        T("Trans", "TryOption"), 
        T2("SeqTrans", "ApplEnumerable", "MEnumerable", "IEnumerable"),
        T("SeqTrans", "Seq"),
        T("SeqTrans", "Set"),
        T("Trans" ,"Validation", "FAIL"),
    };

    string header   = System.IO.File.ReadAllText(this.Host.ResolvePath("HKT.Extensions.Header.Template.txt"));
    string footer   = System.IO.File.ReadAllText(this.Host.ResolvePath("HKT.Extensions.Footer.Template.txt"));
    string linq     = System.IO.File.ReadAllText(this.Host.ResolvePath("HKT.LINQ.Template.txt"));
    string template = System.IO.File.ReadAllText(this.Host.ResolvePath("HKT.Extensions.Template.txt"));
#>
// <auto-generated/>

using System;
using System.Text;
using System.Linq;
using System.Threading.Tasks;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using LanguageExt.TypeClasses;
using LanguageExt.ClassInstances;
using static LanguageExt.Prelude;

namespace LanguageExt
{
<#
    foreach(var innerType in types)
    {
        StringBuilder b = new StringBuilder();

        b.Append(header.Replace("INNER_CLASS_NAME",innerType.Name));

        StringWrapper currentTemplate = innerType.Name == "IEnumerable"
            ? template
            : linq + template;

        foreach(var outerType in types)
        {
            var CLASS_NAME = outerType.Name+innerType.Name;
            var INNER_CLASS_NAME = innerType.Name;
            var OUTER_CLASS_NAME = outerType.Name;

            var INNER_A = innerType.TypeA;
            var INNER_B = innerType.TypeB;
            var INNER_C = innerType.TypeC;
            var M_INNER_A = innerType.MTypeA;
            var M_INNER_B = innerType.MTypeB;
            var M_INNER_C = innerType.MTypeC;

            var FLIPPED_INNER_B = outerType.TypeB;
            var FLIPPED_OUTER_B = innerType.OuterTypeB(outerType);
            var FLIPPED_OUTER_A = innerType.OuterTypeA(outerType);
            var M_FLIPPED_INNER_B = outerType.MTypeB;
            var M_FLIPPED_OUTER_B = innerType.MOuterTypeB(outerType);


            var OUTER_A = outerType.OuterTypeA(innerType);
            var OUTER_B = outerType.OuterTypeB(innerType);
            var OUTER_C = outerType.OuterTypeC(innerType);
            var OUTER_INT = outerType.OuterTypeInt(innerType);
            var OUTER_BOOL = outerType.OuterTypeBool(innerType);
            var M_OUTER_A = outerType.MOuterTypeA(innerType);
            var M_OUTER_B = outerType.MOuterTypeB(innerType);
            var M_OUTER_C = outerType.MOuterTypeC(innerType);

            var APPL_INNER_ABC  = outerType.ApplicativeInnerABC(innerType);
            var APPL_INNER_AB   = outerType.ApplicativeInnerAB(innerType);
            var APPL_ABC        = innerType.ApplicativeABC;
            var APPL_AB         = innerType.ApplicativeAB;

            var M_INNER_FUNC_ABC = outerType.MInnerFuncABC(innerType);
            var M_INNER_FUNC_AB  = outerType.MInnerFuncAB(innerType);

            var M_FUNC_ABC = innerType.MFuncABC;
            var M_FUNC_AB  = innerType.MFuncAB;

            var GENS = TypeDesc.Gens(outerType, innerType);

            b.AppendLine(currentTemplate.ReplaceInCodeAndDoc("INNER_CLASS_NAME", INNER_CLASS_NAME)
                                        .ReplaceInCodeAndDoc("OUTER_CLASS_NAME", OUTER_CLASS_NAME)
                                        .ReplaceInCodeAndDoc("CLASS_NAME", CLASS_NAME)
                                        .ReplaceInCodeAndDoc("M_FLIPPED_INNER_B", M_FLIPPED_INNER_B)
                                        .ReplaceInCodeAndDoc("M_FLIPPED_OUTER_B", M_FLIPPED_OUTER_B)
                                        .ReplaceInCodeAndDoc("FLIPPED_OUTER_B", FLIPPED_OUTER_B)
                                        .ReplaceInCodeAndDoc("FLIPPED_OUTER_A", FLIPPED_OUTER_A)
                                        .ReplaceInCodeAndDoc("FLIPPED_INNER_B", FLIPPED_INNER_B)
                                        .ReplaceInCodeAndDoc("APPL_ABC", APPL_ABC)
                                        .ReplaceInCodeAndDoc("APPL_AB", APPL_AB)
                                        .ReplaceInCodeAndDoc("APPL_INNER_ABC", APPL_INNER_ABC)
                                        .ReplaceInCodeAndDoc("APPL_INNER_AB", APPL_INNER_AB)
                                        .ReplaceInCodeAndDoc("M_INNER_FUNC_ABC", M_INNER_FUNC_ABC)
                                        .ReplaceInCodeAndDoc("M_INNER_FUNC_AB", M_INNER_FUNC_AB)
                                        .ReplaceInCodeAndDoc("M_FUNC_ABC", M_FUNC_ABC)
                                        .ReplaceInCodeAndDoc("M_FUNC_AB", M_FUNC_AB)
                                        .ReplaceInCodeAndDoc("M_OUTER_C", M_OUTER_C)
                                        .ReplaceInCodeAndDoc("M_OUTER_B", M_OUTER_B)
                                        .ReplaceInCodeAndDoc("M_OUTER_A", M_OUTER_A)
                                        .ReplaceInCodeAndDoc("M_INNER_C", M_INNER_C)
                                        .ReplaceInCodeAndDoc("M_INNER_B", M_INNER_B)
                                        .ReplaceInCodeAndDoc("M_INNER_A", M_INNER_A)
                                        .ReplaceInCodeAndDoc("OUTER_INT", OUTER_INT)
                                        .ReplaceInCodeAndDoc("OUTER_BOOL", OUTER_BOOL)
                                        .ReplaceInCodeAndDoc("OUTER_C", OUTER_C)
                                        .ReplaceInCodeAndDoc("OUTER_B", OUTER_B)
                                        .ReplaceInCodeAndDoc("OUTER_A", OUTER_A)
                                        .ReplaceInCodeAndDoc("INNER_C", INNER_C)
                                        .ReplaceInCodeAndDoc("INNER_B", INNER_B)
                                        .ReplaceInCodeAndDoc("INNER_A", INNER_A)
                                        .ReplaceInCodeAndDoc("GENS,", GENS)
                                        .ReplaceInCodeAndDoc("FLIP_TRANS", innerType.Trans)
                                        .ReplaceInCodeAndDoc("TRANS", outerType.Trans));
        }
        b.Append(footer);
#>
<#= b.ToString() #>
<#
    }

#>
}
<#+

    public struct StringWrapper
    {
        private readonly string _value;

        public StringWrapper(string value)
        {
            _value = value;
        }

        public StringWrapper ReplaceInCodeAndDoc(string original, string replacement)
        {
            return _value.Replace("`" + original + "`", "`" + replacement.Replace("<", "&lt;").Replace(">", "&gt;") + "`")
                         .Replace(original, replacement);
        }

        public static implicit operator StringWrapper(string value)
        {
            return new StringWrapper(value);
        }

        public static implicit operator string(StringWrapper value)
        {
            return value._value;
        }

        public override string ToString()
        {
            return _value;
        }
    }

    public class TypeDesc
    {
        public readonly string Trans;
        public readonly string FName;
        public readonly string MName;
        public readonly string Name;
        public readonly string[] Args;

        public TypeDesc(string trans, string fname, string mname, string name, params string[] args)
        {
            Trans = trans;
            FName = fname;
            MName = mname;
            Name = name;
            Args = args;
        }

        public static string Gens(TypeDesc outer, TypeDesc inner)
        {
            var gens = Enumerable.Concat(outer.Args, inner.Args).Distinct().ToArray();
            if(gens.Length == 0) return "";
            return String.Join(", ", gens)+",";
        }

        public string Gens()
        {
            var gens = Args.Distinct().ToArray();
            if(gens.Length == 0) return "";
            return String.Join(", ", gens)+",";
        }

        public string ArgsDisplay(string a) =>
            Args.Length == 0
                ? a
                : String.Join(", ", Args) + ", " + a;

        public string ArgsA => ArgsDisplay("A");
        public string ArgsB => ArgsDisplay("B");
        public string ArgsC => ArgsDisplay("C");

        public string Type(string a) =>
            $"{Name}<" + ArgsDisplay(a) + ">";

        public string MType(string a) =>
            $"{MName}<" + ArgsDisplay(a) + ">";

        public string TypeA => Type("A");
        public string TypeB => Type("B");
        public string TypeC => Type("C");

        public string MTypeA => MType("A");
        public string MTypeB => MType("B");
        public string MTypeC => MType("C");

        public string OuterType(TypeDesc inner, string a) => $"{Name}<" + ArgsDisplay(inner.Type(a)) + ">";
        public string OuterTypeA(TypeDesc inner) => OuterType(inner, "A");
        public string OuterTypeB(TypeDesc inner) => OuterType(inner, "B");
        public string OuterTypeC(TypeDesc inner) => OuterType(inner, "C");
        public string OuterTypeInt(TypeDesc inner) => OuterType(inner, "int");
        public string OuterTypeBool(TypeDesc inner) => OuterType(inner, "bool");

        public string MOuterType(TypeDesc inner, string a) => $"{MName}<" + ArgsDisplay(inner.Type(a)) + ">";
        public string MOuterTypeA(TypeDesc inner) => MOuterType(inner, "A");
        public string MOuterTypeB(TypeDesc inner) => MOuterType(inner, "B");
        public string MOuterTypeC(TypeDesc inner) => MOuterType(inner, "C");

        public string ApplicativeInnerABC(TypeDesc inner) => $"{FName}<{Gens()} {inner.TypeA}, {inner.TypeB}, {inner.TypeC}>";
        public string ApplicativeInnerAB(TypeDesc inner) => $"{FName}<{Gens()} {inner.TypeA}, {inner.TypeB}>";
        public string ApplicativeABC => $"{FName}<{Gens()} A, B, C>";
        public string ApplicativeAB => $"{FName}<{Gens()} A, B>";
        
        public string MInnerFuncABC(TypeDesc inner) => $"{MName}<{Gens()} Func<{inner.TypeA}, Func<{inner.TypeB}, {inner.TypeC}>>>";
        public string MInnerFuncAB(TypeDesc inner) => $"{MName}<{Gens()} Func<{inner.TypeA}, {inner.TypeB}>>";
        
        public string MFuncABC => $"{MName}<{Gens()} Func<A, Func<B, C>>>";
        public string MFuncAB => $"{MName}<{Gens()} Func<A, B>>";
    }

    public TypeDesc T(string trans, string name, params string[] args)
    {
        return new TypeDesc(trans, "Appl"+name, "M"+name, name,args);
    }

    public TypeDesc T2(string trans, string fname, string mname, string name, params string[] args)
    {
        return new TypeDesc(trans, fname, mname, name,args);
    }
#>
